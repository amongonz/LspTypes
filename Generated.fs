// This file was auto-generated.
namespace rec Amongonz.LspTypes

#nowarn "44" // Obsolete warnings

/// A set of predefined token types. This set is not fixed
/// an clients can specify additional token types via the
/// corresponding client capabilities.
///
/// @since 3.16.0
type SemanticTokenTypes = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module SemanticTokenTypes =

    [<return: Struct>]
    let (|Namespace|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("namespace") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Represents a generic type. Acts as a fallback for types which can&apos;t be mapped to
    /// a specific type like class or enum.
    [<return: Struct>]
    let (|Type|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("type") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Class|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("class") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Enum|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("enum") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Interface|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("interface") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Struct|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("struct") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|TypeParameter|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("typeParameter") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Parameter|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("parameter") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Variable|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("variable") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Property|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("property") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|EnumMember|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("enumMember") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Event|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("event") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Function|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("function") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Method|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("method") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Macro|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("macro") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Keyword|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("keyword") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Modifier|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("modifier") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Comment|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("comment") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|String|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("string") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Number|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("number") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Regexp|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("regexp") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Operator|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("operator") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// @since 3.17.0
    [<return: Struct>]
    let (|Decorator|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("decorator") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// A set of predefined token modifiers. This set is not fixed
/// an clients can specify additional token types via the
/// corresponding client capabilities.
///
/// @since 3.16.0
type SemanticTokenModifiers = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module SemanticTokenModifiers =

    [<return: Struct>]
    let (|Declaration|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("declaration") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Definition|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("definition") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Readonly|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("readonly") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Static|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("static") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Deprecated|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("deprecated") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Abstract|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("abstract") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Async|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("async") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Modification|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("modification") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Documentation|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("documentation") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|DefaultLibrary|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("defaultLibrary") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// The document diagnostic report kinds.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticReportKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | DocumentDiagnosticReportKind.Full
        | DocumentDiagnosticReportKind.Unchanged as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        DocumentDiagnosticReportKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (DocumentDiagnosticReportKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (DocumentDiagnosticReportKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module DocumentDiagnosticReportKind =

    /// A diagnostic report with a full
    /// set of problems.
    [<return: Struct>]
    let (|Full|_|) (value: DocumentDiagnosticReportKind) =
        if value.ValueEquals("full") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// A report indicating that the last
    /// returned report is still accurate.
    [<return: Struct>]
    let (|Unchanged|_|) (value: DocumentDiagnosticReportKind) =
        if value.ValueEquals("unchanged") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Predefined error codes.
type ErrorCodes = int

module ErrorCodes =

    [<Literal>]
    let ParseError = -32700

    [<Literal>]
    let InvalidRequest = -32600

    [<Literal>]
    let MethodNotFound = -32601

    [<Literal>]
    let InvalidParams = -32602

    [<Literal>]
    let InternalError = -32603

    /// Error code indicating that a server received a notification or
    /// request before the server has received the `initialize` request.
    [<Literal>]
    let ServerNotInitialized = -32002

    [<Literal>]
    let UnknownErrorCode = -32001

type LSPErrorCodes = int

module LSPErrorCodes =

    /// A request failed but it was syntactically correct, e.g the
    /// method name was known and the parameters were valid. The error
    /// message should contain human readable information about why
    /// the request failed.
    ///
    /// @since 3.17.0
    [<Literal>]
    let RequestFailed = -32803

    /// The server cancelled the request. This error code should
    /// only be used for requests that explicitly support being
    /// server cancellable.
    ///
    /// @since 3.17.0
    [<Literal>]
    let ServerCancelled = -32802

    /// The server detected that the content of a document got
    /// modified outside normal conditions. A server should
    /// NOT send this error code if it detects a content change
    /// in it unprocessed messages. The result even computed
    /// on an older state might still be useful for the client.
    ///
    /// If a client decides that a result is not of any use anymore
    /// the client should cancel the request.
    [<Literal>]
    let ContentModified = -32801

    /// The client has canceled a request and a server has detected
    /// the cancel.
    [<Literal>]
    let RequestCancelled = -32800

/// A set of predefined range kinds.
type FoldingRangeKind = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module FoldingRangeKind =

    /// Folding range for a comment
    [<return: Struct>]
    let (|Comment|_|) (value: FoldingRangeKind) =
        if value.ValueEquals("comment") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Folding range for an import or include
    [<return: Struct>]
    let (|Imports|_|) (value: FoldingRangeKind) =
        if value.ValueEquals("imports") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Folding range for a region (e.g. `#region`)
    [<return: Struct>]
    let (|Region|_|) (value: FoldingRangeKind) =
        if value.ValueEquals("region") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// A symbol kind.
type SymbolKind =
    | File = 1
    | Module = 2
    | Namespace = 3
    | Package = 4
    | Class = 5
    | Method = 6
    | Property = 7
    | Field = 8
    | Constructor = 9
    | Enum = 10
    | Interface = 11
    | Function = 12
    | Variable = 13
    | Constant = 14
    | String = 15
    | Number = 16
    | Boolean = 17
    | Array = 18
    | Object = 19
    | Key = 20
    | Null = 21
    | EnumMember = 22
    | Struct = 23
    | Event = 24
    | Operator = 25
    | TypeParameter = 26

/// Symbol tags are extra annotations that tweak the rendering of a symbol.
///
/// @since 3.16
type SymbolTag =

    /// Render a symbol as obsolete, usually using a strike-out.
    | Deprecated = 1

/// Moniker uniqueness level to define scope of the moniker.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type UniquenessLevel(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | UniquenessLevel.Document
        | UniquenessLevel.Project
        | UniquenessLevel.Group
        | UniquenessLevel.Scheme
        | UniquenessLevel.Global as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        UniquenessLevel(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (UniquenessLevel(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (UniquenessLevel(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module UniquenessLevel =

    /// The moniker is only unique inside a document
    [<return: Struct>]
    let (|Document|_|) (value: UniquenessLevel) =
        if value.ValueEquals("document") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is unique inside a project for which a dump got created
    [<return: Struct>]
    let (|Project|_|) (value: UniquenessLevel) =
        if value.ValueEquals("project") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is unique inside the group to which a project belongs
    [<return: Struct>]
    let (|Group|_|) (value: UniquenessLevel) =
        if value.ValueEquals("group") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is unique inside the moniker scheme.
    [<return: Struct>]
    let (|Scheme|_|) (value: UniquenessLevel) =
        if value.ValueEquals("scheme") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is globally unique
    [<return: Struct>]
    let (|Global|_|) (value: UniquenessLevel) =
        if value.ValueEquals("global") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// The moniker kind.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | MonikerKind.Import
        | MonikerKind.Export
        | MonikerKind.Local as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        MonikerKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (MonikerKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (MonikerKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module MonikerKind =

    /// The moniker represent a symbol that is imported into a project
    [<return: Struct>]
    let (|Import|_|) (value: MonikerKind) =
        if value.ValueEquals("import") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker represents a symbol that is exported from a project
    [<return: Struct>]
    let (|Export|_|) (value: MonikerKind) =
        if value.ValueEquals("export") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker represents a symbol that is local to a project (e.g. a local
    /// variable of a function, a class not visible outside the project, ...)
    [<return: Struct>]
    let (|Local|_|) (value: MonikerKind) =
        if value.ValueEquals("local") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Inlay hint kinds.
///
/// @since 3.17.0
type InlayHintKind =

    /// An inlay hint that for a type annotation.
    | Type = 1

    /// An inlay hint that is for a parameter.
    | Parameter = 2

/// The message type
type MessageType =

    /// An error message.
    | Error = 1

    /// A warning message.
    | Warning = 2

    /// An information message.
    | Info = 3

    /// A log message.
    | Log = 4

    /// A debug message.
    ///
    /// @since 3.18.0
    | Debug = 5

/// Defines how the host (editor) should sync
/// document changes to the language server.
type TextDocumentSyncKind =

    /// Documents should not be synced at all.
    | None = 0

    /// Documents are synced by always sending the full content
    /// of the document.
    | Full = 1

    /// Documents are synced by sending the full content on open.
    /// After that only incremental updates to the document are
    /// send.
    | Incremental = 2

/// Represents reasons why a text document is saved.
type TextDocumentSaveReason =

    /// Manually triggered, e.g. by the user pressing save, by starting debugging,
    /// or by an API call.
    | Manual = 1

    /// Automatic after a delay.
    | AfterDelay = 2

    /// When the editor lost focus.
    | FocusOut = 3

/// The kind of a completion entry.
type CompletionItemKind =
    | Text = 1
    | Method = 2
    | Function = 3
    | Constructor = 4
    | Field = 5
    | Variable = 6
    | Class = 7
    | Interface = 8
    | Module = 9
    | Property = 10
    | Unit = 11
    | Value = 12
    | Enum = 13
    | Keyword = 14
    | Snippet = 15
    | Color = 16
    | File = 17
    | Reference = 18
    | Folder = 19
    | EnumMember = 20
    | Constant = 21
    | Struct = 22
    | Event = 23
    | Operator = 24
    | TypeParameter = 25

/// Completion item tags are extra annotations that tweak the rendering of a completion
/// item.
///
/// @since 3.15.0
type CompletionItemTag =

    /// Render a completion as obsolete, usually using a strike-out.
    | Deprecated = 1

/// Defines whether the insert text in a completion item should be interpreted as
/// plain text or a snippet.
type InsertTextFormat =

    /// The primary text to be inserted is treated as a plain string.
    | PlainText = 1

    /// The primary text to be inserted is treated as a snippet.
    ///
    /// A snippet can define tab stops and placeholders with `$1`, `$2`
    /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
    /// the end of the snippet. Placeholders with equal identifiers are linked,
    /// that is typing in one will update others too.
    ///
    /// See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
    | Snippet = 2

/// How whitespace and indentation is handled during completion
/// item insertion.
///
/// @since 3.16.0
type InsertTextMode =

    /// The insertion or replace strings is taken as it is. If the
    /// value is multi line the lines below the cursor will be
    /// inserted using the indentation defined in the string value.
    /// The client will not apply any kind of adjustments to the
    /// string.
    | AsIs = 1

    /// The editor adjusts leading whitespace of new lines so that
    /// they match the indentation up to the cursor of the line for
    /// which the item is accepted.
    ///
    /// Consider a line like this: &lt;2tabs&gt;&lt;cursor&gt;&lt;3tabs&gt;foo. Accepting a
    /// multi line completion item is indented using 2 tabs and all
    /// following lines inserted will be indented using 2 tabs as well.
    | AdjustIndentation = 2

/// A document highlight kind.
type DocumentHighlightKind =

    /// A textual occurrence.
    | Text = 1

    /// Read-access of a symbol, like reading a variable.
    | Read = 2

    /// Write-access of a symbol, like writing to a variable.
    | Write = 3

/// A set of predefined code action kinds
type CodeActionKind = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module CodeActionKind =

    /// Empty kind.
    [<return: Struct>]
    let (|Empty|_|) (value: CodeActionKind) =
        if value.ValueEquals("") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for quickfix actions: &apos;quickfix&apos;
    [<return: Struct>]
    let (|QuickFix|_|) (value: CodeActionKind) =
        if value.ValueEquals("quickfix") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring actions: &apos;refactor&apos;
    [<return: Struct>]
    let (|Refactor|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring extraction actions: &apos;refactor.extract&apos;
    ///
    /// Example extract actions:
    ///
    /// - Extract method
    /// - Extract function
    /// - Extract variable
    /// - Extract interface from class
    /// - ...
    [<return: Struct>]
    let (|RefactorExtract|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor.extract") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring inline actions: &apos;refactor.inline&apos;
    ///
    /// Example inline actions:
    ///
    /// - Inline function
    /// - Inline variable
    /// - Inline constant
    /// - ...
    [<return: Struct>]
    let (|RefactorInline|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor.inline") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring rewrite actions: &apos;refactor.rewrite&apos;
    ///
    /// Example rewrite actions:
    ///
    /// - Convert JavaScript function to class
    /// - Add or remove parameter
    /// - Encapsulate field
    /// - Make method static
    /// - Move method to base class
    /// - ...
    [<return: Struct>]
    let (|RefactorRewrite|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor.rewrite") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for source actions: `source`
    ///
    /// Source code actions apply to the entire file.
    [<return: Struct>]
    let (|Source|_|) (value: CodeActionKind) =
        if value.ValueEquals("source") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for an organize imports source action: `source.organizeImports`
    [<return: Struct>]
    let (|SourceOrganizeImports|_|) (value: CodeActionKind) =
        if value.ValueEquals("source.organizeImports") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for auto-fix source actions: `source.fixAll`.
    ///
    /// Fix all actions automatically fix errors that have a clear fix that do not require user input.
    /// They should not suppress errors or perform unsafe fixes such as generating new types or classes.
    ///
    /// @since 3.15.0
    [<return: Struct>]
    let (|SourceFixAll|_|) (value: CodeActionKind) =
        if value.ValueEquals("source.fixAll") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TraceValues(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | TraceValues.Off
        | TraceValues.Messages
        | TraceValues.Verbose as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        TraceValues(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (TraceValues(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (TraceValues(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module TraceValues =

    /// Turn tracing off.
    [<return: Struct>]
    let (|Off|_|) (value: TraceValues) =
        if value.ValueEquals("off") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Trace messages only.
    [<return: Struct>]
    let (|Messages|_|) (value: TraceValues) =
        if value.ValueEquals("messages") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Verbose message tracing.
    [<return: Struct>]
    let (|Verbose|_|) (value: TraceValues) =
        if value.ValueEquals("verbose") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Describes the content type that a client supports in various
/// result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
///
/// Please note that `MarkupKinds` must not start with a `$`. This kinds
/// are reserved for internal usage.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkupKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | MarkupKind.PlainText
        | MarkupKind.Markdown as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        MarkupKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (MarkupKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (MarkupKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module MarkupKind =

    /// Plain text is supported as a content format
    [<return: Struct>]
    let (|PlainText|_|) (value: MarkupKind) =
        if value.ValueEquals("plaintext") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Markdown is supported as a content format
    [<return: Struct>]
    let (|Markdown|_|) (value: MarkupKind) =
        if value.ValueEquals("markdown") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
///
/// @since 3.18.0
/// @proposed
type InlineCompletionTriggerKind =

    /// Completion was triggered explicitly by a user gesture.
    | Invoked = 0

    /// Completion was triggered automatically while editing.
    | Automatic = 1

/// A set of predefined position encoding kinds.
///
/// @since 3.17.0
type PositionEncodingKind = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module PositionEncodingKind =

    /// Character offsets count UTF-8 code units (e.g. bytes).
    [<return: Struct>]
    let (|UTF8|_|) (value: PositionEncodingKind) =
        if value.ValueEquals("utf-8") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Character offsets count UTF-16 code units.
    ///
    /// This is the default and must always be supported
    /// by servers
    [<return: Struct>]
    let (|UTF16|_|) (value: PositionEncodingKind) =
        if value.ValueEquals("utf-16") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Character offsets count UTF-32 code units.
    ///
    /// Implementation note: these are the same as Unicode codepoints,
    /// so this `PositionEncodingKind` may also be used for an
    /// encoding-agnostic representation of character offsets.
    [<return: Struct>]
    let (|UTF32|_|) (value: PositionEncodingKind) =
        if value.ValueEquals("utf-32") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// The file event type
type FileChangeType =

    /// The file got created.
    | Created = 1

    /// The file got changed.
    | Changed = 2

    /// The file got deleted.
    | Deleted = 3

type WatchKind = int

module WatchKind =

    /// Interested in create events.
    [<Literal>]
    let Create = 1

    /// Interested in change events
    [<Literal>]
    let Change = 2

    /// Interested in delete events
    [<Literal>]
    let Delete = 4

/// The diagnostic&apos;s severity.
type DiagnosticSeverity =

    /// Reports an error.
    | Error = 1

    /// Reports a warning.
    | Warning = 2

    /// Reports an information.
    | Information = 3

    /// Reports a hint.
    | Hint = 4

/// The diagnostic tags.
///
/// @since 3.15.0
type DiagnosticTag =

    /// Unused or unnecessary code.
    ///
    /// Clients are allowed to render diagnostics with this tag faded out instead of having
    /// an error squiggle.
    | Unnecessary = 1

    /// Deprecated or obsolete code.
    ///
    /// Clients are allowed to rendered diagnostics with this tag strike through.
    | Deprecated = 2

/// How a completion was triggered
type CompletionTriggerKind =

    /// Completion was triggered by typing an identifier (24x7 code
    /// complete), manual invocation (e.g Ctrl+Space) or via API.
    | Invoked = 1

    /// Completion was triggered by a trigger character specified by
    /// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
    | TriggerCharacter = 2

    /// Completion was re-triggered as current completion list is incomplete
    | TriggerForIncompleteCompletions = 3

/// How a signature help was triggered.
///
/// @since 3.15.0
type SignatureHelpTriggerKind =

    /// Signature help was invoked manually by the user or by a command.
    | Invoked = 1

    /// Signature help was triggered by a trigger character.
    | TriggerCharacter = 2

    /// Signature help was triggered by the cursor moving or by the document content changing.
    | ContentChange = 3

/// The reason why code actions were requested.
///
/// @since 3.17.0
type CodeActionTriggerKind =

    /// Code actions were explicitly requested by the user or by an extension.
    | Invoked = 1

    /// Code actions were requested automatically.
    ///
    /// This typically happens when current selection in a file changes, but can
    /// also be triggered when file content changes.
    | Automatic = 2

/// A pattern kind describing if a glob pattern matches a file a folder or
/// both.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationPatternKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | FileOperationPatternKind.File
        | FileOperationPatternKind.Folder as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        FileOperationPatternKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (FileOperationPatternKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (FileOperationPatternKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module FileOperationPatternKind =

    /// The pattern matches a file only.
    [<return: Struct>]
    let (|File|_|) (value: FileOperationPatternKind) =
        if value.ValueEquals("file") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The pattern matches a folder only.
    [<return: Struct>]
    let (|Folder|_|) (value: FileOperationPatternKind) =
        if value.ValueEquals("folder") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// A notebook cell kind.
///
/// @since 3.17.0
type NotebookCellKind =

    /// A markup-cell is formatted source that is used for display.
    | Markup = 1

    /// A code-cell is source code.
    | Code = 2

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ResourceOperationKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | ResourceOperationKind.Create
        | ResourceOperationKind.Rename
        | ResourceOperationKind.Delete as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        ResourceOperationKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (ResourceOperationKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (ResourceOperationKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module ResourceOperationKind =

    /// Supports creating new files and folders.
    [<return: Struct>]
    let (|Create|_|) (value: ResourceOperationKind) =
        if value.ValueEquals("create") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Supports renaming existing files and folders.
    [<return: Struct>]
    let (|Rename|_|) (value: ResourceOperationKind) =
        if value.ValueEquals("rename") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Supports deleting existing files and folders.
    [<return: Struct>]
    let (|Delete|_|) (value: ResourceOperationKind) =
        if value.ValueEquals("delete") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FailureHandlingKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | FailureHandlingKind.Abort
        | FailureHandlingKind.Transactional
        | FailureHandlingKind.TextOnlyTransactional
        | FailureHandlingKind.Undo as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        FailureHandlingKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (FailureHandlingKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (FailureHandlingKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module FailureHandlingKind =

    /// Applying the workspace change is simply aborted if one of the changes provided
    /// fails. All operations executed before the failing operation stay executed.
    [<return: Struct>]
    let (|Abort|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("abort") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// All operations are executed transactional. That means they either all
    /// succeed or no changes at all are applied to the workspace.
    [<return: Struct>]
    let (|Transactional|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("transactional") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// If the workspace edit contains only textual file changes they are executed transactional.
    /// If resource changes (create, rename or delete file) are part of the change the failure
    /// handling strategy is abort.
    [<return: Struct>]
    let (|TextOnlyTransactional|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("textOnlyTransactional") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The client tries to undo the operations already executed. But there is no
    /// guarantee that this is succeeding.
    [<return: Struct>]
    let (|Undo|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("undo") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

type PrepareSupportDefaultBehavior =

    /// The client&apos;s default behavior is to select the identifier
    /// according the to language&apos;s syntax rule.
    | Identifier = 1

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TokenFormat(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | TokenFormat.Relative as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        TokenFormat(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (TokenFormat(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (TokenFormat(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module TokenFormat =

    [<return: Struct>]
    let (|Relative|_|) (value: TokenFormat) =
        if value.ValueEquals("relative") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

[<global.FSharp.Core.AutoOpen>]
module EnumerationExtensions =

    type SymbolKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<SymbolKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<SymbolKind> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<SymbolKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type SymbolTag with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<SymbolTag> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<SymbolTag> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<SymbolTag> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InlayHintKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InlayHintKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InlayHintKind> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InlayHintKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type MessageType with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<MessageType> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<MessageType> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<MessageType> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type TextDocumentSyncKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<TextDocumentSyncKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<TextDocumentSyncKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<TextDocumentSyncKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type TextDocumentSaveReason with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<TextDocumentSaveReason> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<TextDocumentSaveReason> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<TextDocumentSaveReason> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CompletionItemKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CompletionItemKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CompletionItemKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CompletionItemKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CompletionItemTag with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CompletionItemTag> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CompletionItemTag> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CompletionItemTag> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InsertTextFormat with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InsertTextFormat> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InsertTextFormat> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InsertTextFormat> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InsertTextMode with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InsertTextMode> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InsertTextMode> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InsertTextMode> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type DocumentHighlightKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<DocumentHighlightKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<DocumentHighlightKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<DocumentHighlightKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InlineCompletionTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InlineCompletionTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InlineCompletionTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InlineCompletionTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type FileChangeType with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<FileChangeType> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<FileChangeType> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<FileChangeType> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type DiagnosticSeverity with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<DiagnosticSeverity> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<DiagnosticSeverity> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<DiagnosticSeverity> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type DiagnosticTag with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<DiagnosticTag> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<DiagnosticTag> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<DiagnosticTag> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CompletionTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CompletionTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CompletionTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CompletionTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type SignatureHelpTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<SignatureHelpTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<SignatureHelpTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<SignatureHelpTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CodeActionTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CodeActionTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CodeActionTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CodeActionTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type NotebookCellKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<NotebookCellKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<NotebookCellKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<NotebookCellKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type PrepareSupportDefaultBehavior with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<PrepareSupportDefaultBehavior> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<PrepareSupportDefaultBehavior> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<PrepareSupportDefaultBehavior> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

type private IImplementationParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IImplementationParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        ImplementationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IImplementationParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(ImplementationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ILocation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``range``: Range

/// Represents a location inside a resource, such as a line
/// inside a text file.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Location private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILocation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Location(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspDocumentUri, ``range``: Range) =
        Location(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILocation with
                    member _.``uri`` = ``uri``
                    member _.``range`` = ``range``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(Location.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IImplementationRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IImplementationRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        ImplementationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IImplementationRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ImplementationRegistrationOptions.FromElement(element))

type private ITypeDefinitionParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeDefinitionParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        TypeDefinitionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeDefinitionParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeDefinitionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITypeDefinitionRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeDefinitionRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        TypeDefinitionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeDefinitionRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TypeDefinitionRegistrationOptions.FromElement(element))

type private IWorkspaceFolder =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.System.Uri
    abstract ``name``: global.Amongonz.LspTypes.LspString

/// A workspace folder inside a client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFolder private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceFolder>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFolder(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The associated URI for this workspace folder.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    /// The name of the workspace folder. Used to refer to this
    /// workspace folder in the user interface.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``uri``: global.System.Uri, ``name``: global.Amongonz.LspTypes.LspString) =
        WorkspaceFolder(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceFolder with
                    member _.``uri`` = ``uri``
                    member _.``name`` = ``name``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("name")
                        ``name``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "name" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkspaceFolder.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidChangeWorkspaceFoldersParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``event``: WorkspaceFoldersChangeEvent

/// The parameters of a `workspace/didChangeWorkspaceFolders` notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWorkspaceFoldersParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeWorkspaceFoldersParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWorkspaceFoldersParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual workspace folder change event.
    member _.Event =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``event``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("event")
            WorkspaceFoldersChangeEvent.FromElement(prop)

    static member Create(``event``: WorkspaceFoldersChangeEvent) =
        DidChangeWorkspaceFoldersParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeWorkspaceFoldersParams with
                    member _.``event`` = ``event``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("event")
                        ``event``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "event" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceFoldersChangeEvent.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidChangeWorkspaceFoldersParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IConfigurationParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The parameters of a configuration request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ConfigurationParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IConfigurationParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ConfigurationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        ConfigurationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IConfigurationParams with
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ConfigurationParams.FromElement(element))

type private IDocumentColorParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters for a {@link DocumentColorRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentColorParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentColorParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentColorParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentColorParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IColorInformation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``color``: Color

/// Represents a color range from a document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ColorInformation private (backing: global.Amongonz.LspTypes.LspJsonBacking<IColorInformation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ColorInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range in the document where this color appears.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The actual color value for this color range.
    member _.Color =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``color``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("color")
            Color.FromElement(prop)

    static member Create(``range``: Range, ``color``: Color) =
        ColorInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IColorInformation with
                    member _.``range`` = ``range``
                    member _.``color`` = ``color``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("color")
                        ``color``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "color" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Color.Parse(prop)))
        then
            global.FSharp.Core.Ok(ColorInformation.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentColorRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentColorRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        DocumentColorRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentColorRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentColorRegistrationOptions.FromElement(element))

type private IColorPresentationParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``color``: Color
    abstract ``range``: Range
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters for a {@link ColorPresentationRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ColorPresentationParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IColorPresentationParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ColorPresentationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The color to request presentations for.
    member _.Color =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``color``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("color")
            Color.FromElement(prop)

    /// The range where the color would be inserted. Serves as a context.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``color``: Color,
            ``range``: Range,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        ColorPresentationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IColorPresentationParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``color`` = ``color``
                    member _.``range`` = ``range``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("color")
                        ``color``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "color" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Color.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(ColorPresentationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IColorPresentation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``label``: global.Amongonz.LspTypes.LspString
    abstract ``textEdit``: TextEdit option
    abstract ``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ColorPresentation private (backing: global.Amongonz.LspTypes.LspJsonBacking<IColorPresentation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ColorPresentation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this color presentation. It will be shown on the color
    /// picker header. By default this is also the text that is inserted when selecting
    /// this color presentation.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An {@link TextEdit edit} which is applied to a document when selecting
    /// this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}
    /// is used.
    member _.TextEdit =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``textEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextEdit.FromElement(prop))

    /// An optional array of additional {@link TextEdit text edits} that are applied when
    /// selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves.
    member _.AdditionalTextEdits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``additionalTextEdits`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("additionalTextEdits") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``textEdit``: TextEdit,
            ?``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        ColorPresentation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IColorPresentation with
                    member _.``label`` = ``label``
                    member _.``textEdit`` = ``textEdit``
                    member _.``additionalTextEdits`` = ``additionalTextEdits``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("label")
                        ``label``.WriteTo(``json writer``)

                        match ``textEdit`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``textEdit`` ->
                            ``json writer``.WritePropertyName("textEdit")
                            ``textEdit``.WriteTo(``json writer``)

                        match ``additionalTextEdits`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``additionalTextEdits`` ->
                            ``json writer``.WritePropertyName("additionalTextEdits")
                            ``additionalTextEdits``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ColorPresentation.FromElement(element))

type private IWorkDoneProgressOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkDoneProgressOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        WorkDoneProgressOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkDoneProgressOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(WorkDoneProgressOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// General text document registration options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        TextDocumentRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentRegistrationOptions.FromElement(element))

type private IFoldingRangeParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters for a {@link FoldingRangeRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFoldingRangeParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        FoldingRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFoldingRangeParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(FoldingRangeParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFoldingRange =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``startLine``: global.FSharp.Core.int
    abstract ``startCharacter``: global.FSharp.Core.int option
    abstract ``endLine``: global.FSharp.Core.int
    abstract ``endCharacter``: global.FSharp.Core.int option
    abstract ``kind``: FoldingRangeKind option
    abstract ``collapsedText``: global.Amongonz.LspTypes.LspString option

/// Represents a folding range. To be valid, start and end line must be bigger than zero and smaller
/// than the number of lines in the document. Clients are free to ignore invalid ranges.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRange private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFoldingRange>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRange(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The zero-based start line of the range to fold. The folded area starts after the line&apos;s last character.
    /// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
    member _.StartLine =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``startLine``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("startLine")
            prop.GetInt32()

    /// The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
    member _.StartCharacter =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``startCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("startCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// The zero-based end line of the range to fold. The folded area ends with the line&apos;s last character.
    /// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
    member _.EndLine =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``endLine``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("endLine")
            prop.GetInt32()

    /// The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
    member _.EndCharacter =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``endCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("endCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// Describes the kind of the folding range such as `comment&apos; or &apos;region&apos;. The kind
    /// is used to categorize folding ranges and used by commands like &apos;Fold all comments&apos;.
    /// See {@link FoldingRangeKind} for an enumeration of standardized kinds.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FoldingRangeKind.FromElement(prop))

    /// The text that the client should show when the specified range is
    /// collapsed. If not defined or not supported by the client, a default
    /// will be chosen by the client.
    ///
    /// @since 3.17.0
    member _.CollapsedText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``collapsedText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("collapsedText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``startLine``: global.FSharp.Core.int,
            ``endLine``: global.FSharp.Core.int,
            ?``startCharacter``: global.FSharp.Core.int,
            ?``endCharacter``: global.FSharp.Core.int,
            ?``kind``: FoldingRangeKind,
            ?``collapsedText``: global.Amongonz.LspTypes.LspString
        ) =
        FoldingRange(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFoldingRange with
                    member _.``startLine`` = ``startLine``
                    member _.``startCharacter`` = ``startCharacter``
                    member _.``endLine`` = ``endLine``
                    member _.``endCharacter`` = ``endCharacter``
                    member _.``kind`` = ``kind``
                    member _.``collapsedText`` = ``collapsedText``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("startLine", ``startLine``)

                        match ``startCharacter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``startCharacter`` ->
                            ``json writer``.WriteNumber("startCharacter", ``startCharacter``)

                        ``json writer``.WriteNumber("endLine", ``endLine``)

                        match ``endCharacter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``endCharacter`` ->
                            ``json writer``.WriteNumber("endCharacter", ``endCharacter``)

                        match ``kind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``kind`` ->
                            ``json writer``.WritePropertyName("kind")
                            ``kind``.WriteTo(``json writer``)

                        match ``collapsedText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``collapsedText`` ->
                            ``json writer``.WritePropertyName("collapsedText")
                            ``collapsedText``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "startLine" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "startCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "endLine" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "endCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FoldingRangeKind.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "collapsedText" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FoldingRange.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFoldingRangeRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFoldingRangeRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        FoldingRangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFoldingRangeRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FoldingRangeRegistrationOptions.FromElement(element))

type private IDeclarationParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDeclarationParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DeclarationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDeclarationParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DeclarationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDeclarationRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDeclarationRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        DeclarationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDeclarationRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DeclarationRegistrationOptions.FromElement(element))

type private ISelectionRangeParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``positions``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// A parameter literal used in selection range requests.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISelectionRangeParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The positions inside the text document.
    member _.Positions =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``positions``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("positions")
            LspJsonBacking.Element prop

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``positions``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SelectionRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISelectionRangeParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``positions`` = ``positions``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("positions")
                        ``positions``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SelectionRangeParams.FromElement(element))

type private ISelectionRange =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``parent``: SelectionRange option

/// A selection range represents a part of a selection hierarchy. A selection range
/// may have a parent selection range that contains it.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRange private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISelectionRange>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRange(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The {@link Range range} of this selection range.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
    member _.Parent =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``parent`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("parent") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SelectionRange.FromElement(prop))

    static member Create(``range``: Range, ?``parent``: SelectionRange) =
        SelectionRange(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISelectionRange with
                    member _.``range`` = ``range``
                    member _.``parent`` = ``parent``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``parent`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``parent`` ->
                            ``json writer``.WritePropertyName("parent")
                            ``parent``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "parent" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SelectionRange.Parse(prop)))
        then
            global.FSharp.Core.Ok(SelectionRange.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISelectionRangeRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISelectionRangeRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        SelectionRangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISelectionRangeRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SelectionRangeRegistrationOptions.FromElement(element))

type private IWorkDoneProgressCreateParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``token``: ProgressToken

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressCreateParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkDoneProgressCreateParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressCreateParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The token to be used to report progress.
    member _.Token =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``token``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("token")
            ProgressToken.FromElement(prop)

    static member Create(``token``: ProgressToken) =
        WorkDoneProgressCreateParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkDoneProgressCreateParams with
                    member _.``token`` = ``token``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("token")
                        ``token``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "token" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkDoneProgressCreateParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkDoneProgressCancelParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``token``: ProgressToken

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressCancelParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkDoneProgressCancelParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressCancelParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The token to be used to report progress.
    member _.Token =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``token``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("token")
            ProgressToken.FromElement(prop)

    static member Create(``token``: ProgressToken) =
        WorkDoneProgressCancelParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkDoneProgressCancelParams with
                    member _.``token`` = ``token``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("token")
                        ``token``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "token" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkDoneProgressCancelParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICallHierarchyPrepareParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option

/// The parameter of a `textDocument/prepareCallHierarchy` request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyPrepareParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyPrepareParams>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyPrepareParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        CallHierarchyPrepareParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyPrepareParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CallHierarchyPrepareParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICallHierarchyItem =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``name``: global.Amongonz.LspTypes.LspString
    abstract ``kind``: SymbolKind
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``detail``: global.Amongonz.LspTypes.LspString option
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``range``: Range
    abstract ``selectionRange``: Range
    abstract ``data``: LSPAny option

/// Represents programming constructs like functions or constructors in the context
/// of call hierarchy.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyItem private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyItem>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this item.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this item.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this item.
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// More detail for this item, e.g. the signature of a function.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The resource identifier of this item.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
    /// Must be contained by the {@link CallHierarchyItem.range `range`}.
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``selectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("selectionRange")
            Range.FromElement(prop)

    /// A data entry field that is preserved between a call hierarchy prepare and
    /// incoming calls or outgoing calls requests.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``range``: Range,
            ``selectionRange``: Range,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``data``: LSPAny
        ) =
        CallHierarchyItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyItem with
                    member _.``name`` = ``name``
                    member _.``kind`` = ``kind``
                    member _.``tags`` = ``tags``
                    member _.``detail`` = ``detail``
                    member _.``uri`` = ``uri``
                    member _.``range`` = ``range``
                    member _.``selectionRange`` = ``selectionRange``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("name")
                        ``name``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``detail`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``detail`` ->
                            ``json writer``.WritePropertyName("detail")
                            ``detail``.WriteTo(``json writer``)

                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("selectionRange")
                        ``selectionRange``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyItem.FromElement(element))

type private ICallHierarchyRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Call hierarchy options used during static or dynamic registration.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        CallHierarchyRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyRegistrationOptions.FromElement(element))

type private ICallHierarchyIncomingCallsParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``item``: CallHierarchyItem
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameter of a `callHierarchy/incomingCalls` request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyIncomingCallsParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyIncomingCallsParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyIncomingCallsParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            CallHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: CallHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        CallHierarchyIncomingCallsParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyIncomingCallsParams with
                    member _.``item`` = ``item``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("item")
                        ``item``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (CallHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CallHierarchyIncomingCallsParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICallHierarchyIncomingCall =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``from``: CallHierarchyItem
    abstract ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Represents an incoming call, e.g. a caller of a method or constructor.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyIncomingCall private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyIncomingCall>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyIncomingCall(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The item that makes the call.
    member _.From =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``from``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("from")
            CallHierarchyItem.FromElement(prop)

    /// The ranges at which the calls appear. This is relative to the caller
    /// denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
    member _.FromRanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``fromRanges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("fromRanges")
            LspJsonBacking.Element prop

    static member Create
        (``from``: CallHierarchyItem, ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        CallHierarchyIncomingCall(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyIncomingCall with
                    member _.``from`` = ``from``
                    member _.``fromRanges`` = ``fromRanges``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("from")
                        ``from``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("fromRanges")
                        ``fromRanges``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyIncomingCall.FromElement(element))

type private ICallHierarchyOutgoingCallsParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``item``: CallHierarchyItem
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameter of a `callHierarchy/outgoingCalls` request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyOutgoingCallsParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyOutgoingCallsParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyOutgoingCallsParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            CallHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: CallHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        CallHierarchyOutgoingCallsParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyOutgoingCallsParams with
                    member _.``item`` = ``item``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("item")
                        ``item``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (CallHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CallHierarchyOutgoingCallsParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICallHierarchyOutgoingCall =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``to``: CallHierarchyItem
    abstract ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyOutgoingCall private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyOutgoingCall>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyOutgoingCall(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The item that is called.
    member _.To =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``to``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("to")
            CallHierarchyItem.FromElement(prop)

    /// The range at which this item is called. This is the range relative to the caller, e.g the item
    /// passed to {@link CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls `provideCallHierarchyOutgoingCalls`}
    /// and not {@link CallHierarchyOutgoingCall.to `this.to`}.
    member _.FromRanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``fromRanges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("fromRanges")
            LspJsonBacking.Element prop

    static member Create
        (``to``: CallHierarchyItem, ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        CallHierarchyOutgoingCall(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyOutgoingCall with
                    member _.``to`` = ``to``
                    member _.``fromRanges`` = ``fromRanges``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("to")
                        ``to``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("fromRanges")
                        ``fromRanges``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyOutgoingCall.FromElement(element))

type private ISemanticTokensParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SemanticTokensParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SemanticTokensParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISemanticTokens =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resultId``: global.Amongonz.LspTypes.LspString option
    abstract ``data``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokens private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokens>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokens(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional result id. If provided and clients support delta updating
    /// the client will include the result id in the next semantic token request.
    /// A server can then instead of computing all semantic tokens again simply
    /// send a delta.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual tokens.
    member _.Data =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``data``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("data")
            LspJsonBacking.Element prop

    static member Create
        (
            ``data``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        SemanticTokens(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokens with
                    member _.``resultId`` = ``resultId``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resultId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resultId`` ->
                            ``json writer``.WritePropertyName("resultId")
                            ``resultId``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("data")
                        ``data``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokens.FromElement(element))

type private ISemanticTokensPartialResult =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``data``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensPartialResult
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensPartialResult>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Data =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``data``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("data")
            LspJsonBacking.Element prop

    static member Create(``data``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        SemanticTokensPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensPartialResult with
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("data")
                        ``data``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensPartialResult.FromElement(element))

type private ISemanticTokensRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``legend``: SemanticTokensLegend
    abstract ``range``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``full``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The legend used by the server
    member _.Legend =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``legend``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("legend")
            SemanticTokensLegend.FromElement(prop)

    /// Server supports providing semantic tokens for a specific range
    /// of a document.
    member _.Range =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Server supports providing semantic tokens for a full document.
    member _.Full =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``full`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("full") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``legend``: SemanticTokensLegend,
            ?``range``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``full``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        SemanticTokensRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``legend`` = ``legend``
                    member _.``range`` = ``range``
                    member _.``full`` = ``full``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("legend")
                        ``legend``.WriteTo(``json writer``)

                        match ``range`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``range`` ->
                            ``json writer``.WritePropertyName("range")
                            ``range``.WriteTo(``json writer``)

                        match ``full`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``full`` ->
                            ``json writer``.WritePropertyName("full")
                            ``full``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensRegistrationOptions.FromElement(element))

type private ISemanticTokensDeltaParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``previousResultId``: global.Amongonz.LspTypes.LspString
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensDeltaParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensDeltaParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensDeltaParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The result id of a previous response. The result Id can either point to a full response
    /// or a delta response depending on what was received last.
    member _.PreviousResultId =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``previousResultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("previousResultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``previousResultId``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SemanticTokensDeltaParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensDeltaParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``previousResultId`` = ``previousResultId``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("previousResultId")
                        ``previousResultId``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "previousResultId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SemanticTokensDeltaParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISemanticTokensDelta =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resultId``: global.Amongonz.LspTypes.LspString option
    abstract ``edits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensDelta private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensDelta>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensDelta(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The semantic token edits to transform a previous result into a new result.
    member _.Edits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``edits``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edits")
            LspJsonBacking.Element prop

    static member Create
        (
            ``edits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        SemanticTokensDelta(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensDelta with
                    member _.``resultId`` = ``resultId``
                    member _.``edits`` = ``edits``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resultId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resultId`` ->
                            ``json writer``.WritePropertyName("resultId")
                            ``resultId``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("edits")
                        ``edits``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensDelta.FromElement(element))

type private ISemanticTokensDeltaPartialResult =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``edits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensDeltaPartialResult
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensDeltaPartialResult>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensDeltaPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Edits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``edits``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edits")
            LspJsonBacking.Element prop

    static member Create(``edits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        SemanticTokensDeltaPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensDeltaPartialResult with
                    member _.``edits`` = ``edits``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("edits")
                        ``edits``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensDeltaPartialResult.FromElement(element))

type private ISemanticTokensRangeParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``range``: Range
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensRangeParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensRangeParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The range the semantic tokens are requested for.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SemanticTokensRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensRangeParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``range`` = ``range``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SemanticTokensRangeParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IShowDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.System.Uri
    abstract ``external``: global.FSharp.Core.bool option
    abstract ``takeFocus``: global.FSharp.Core.bool option
    abstract ``selection``: Range option

/// Params to show a resource in the UI.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowDocumentParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IShowDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The uri to show.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    /// Indicates to show the resource in an external program.
    /// To show, for example, `https://code.visualstudio.com/`
    /// in the default WEB browser set `external` to `true`.
    member _.External =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``external`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("external") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// An optional property to indicate whether the editor
    /// showing the document should take focus or not.
    /// Clients might ignore this property if an external
    /// program is started.
    member _.TakeFocus =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``takeFocus`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("takeFocus") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// An optional selection range if the document is a text
    /// document. Clients might ignore the property if an
    /// external program is started or the file is not a text
    /// file.
    member _.Selection =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``selection`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selection") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    static member Create
        (
            ``uri``: global.System.Uri,
            ?``external``: global.FSharp.Core.bool,
            ?``takeFocus``: global.FSharp.Core.bool,
            ?``selection``: Range
        ) =
        ShowDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IShowDocumentParams with
                    member _.``uri`` = ``uri``
                    member _.``external`` = ``external``
                    member _.``takeFocus`` = ``takeFocus``
                    member _.``selection`` = ``selection``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)

                        match ``external`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``external`` -> ``json writer``.WriteBoolean("external", ``external``)

                        match ``takeFocus`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``takeFocus`` ->
                            ``json writer``.WriteBoolean("takeFocus", ``takeFocus``)

                        match ``selection`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``selection`` ->
                            ``json writer``.WritePropertyName("selection")
                            ``selection``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "external" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "takeFocus" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "selection" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(ShowDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IShowDocumentResult =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``success``: global.FSharp.Core.bool

/// The result of a showDocument request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowDocumentResult private (backing: global.Amongonz.LspTypes.LspJsonBacking<IShowDocumentResult>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowDocumentResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A boolean indicating if the show was successful.
    member _.Success =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``success``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("success")
            prop.GetBoolean()

    static member Create(``success``: global.FSharp.Core.bool) =
        ShowDocumentResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IShowDocumentResult with
                    member _.``success`` = ``success``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteBoolean("success", ``success``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "success" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ShowDocumentResult.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ILinkedEditingRangeParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILinkedEditingRangeParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        LinkedEditingRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILinkedEditingRangeParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(LinkedEditingRangeParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ILinkedEditingRanges =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``ranges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``wordPattern``: global.Amongonz.LspTypes.LspString option

/// The result of a linked editing range request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRanges private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILinkedEditingRanges>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRanges(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A list of ranges that can be edited together. The ranges must have
    /// identical length and contain identical text content. The ranges cannot overlap.
    member _.Ranges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``ranges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("ranges")
            LspJsonBacking.Element prop

    /// An optional word pattern (regular expression) that describes valid contents for
    /// the given ranges. If no pattern is provided, the client configuration&apos;s word
    /// pattern will be used.
    member _.WordPattern =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``wordPattern`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("wordPattern") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``ranges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``wordPattern``: global.Amongonz.LspTypes.LspString
        ) =
        LinkedEditingRanges(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILinkedEditingRanges with
                    member _.``ranges`` = ``ranges``
                    member _.``wordPattern`` = ``wordPattern``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("ranges")
                        ``ranges``.WriteTo(``json writer``)

                        match ``wordPattern`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``wordPattern`` ->
                            ``json writer``.WritePropertyName("wordPattern")
                            ``wordPattern``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(LinkedEditingRanges.FromElement(element))

type private ILinkedEditingRangeRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILinkedEditingRangeRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        LinkedEditingRangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILinkedEditingRangeRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(LinkedEditingRangeRegistrationOptions.FromElement(element))

type private ICreateFilesParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``files``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The parameters sent in notifications/requests for user-initiated creation of
/// files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CreateFilesParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICreateFilesParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CreateFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of all files/folders created in this operation.
    member _.Files =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``files``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("files")
            LspJsonBacking.Element prop

    static member Create(``files``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        CreateFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICreateFilesParams with
                    member _.``files`` = ``files``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("files")
                        ``files``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CreateFilesParams.FromElement(element))

type private IWorkspaceEdit =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``changes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``documentChanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``changeAnnotations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// A workspace edit represents changes to many resources managed in the workspace. The edit
/// should either provide `changes` or `documentChanges`. If documentChanges are present
/// they are preferred over `changes` if the client can handle versioned document edits.
///
/// Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
/// operations are present clients need to execute the operations in the order in which they
/// are provided. So a workspace edit for example can consist of the following two changes:
/// (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
///
/// An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
/// cause failure of the operation. How the client recovers from the failure is described by
/// the client capability: `workspace.workspaceEdit.failureHandling`
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceEdit private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceEdit>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Holds changes to existing resources.
    member _.Changes =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``changes`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changes") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
    /// are either an array of `TextDocumentEdit`s to express changes to n different text documents
    /// where each text document edit addresses a specific version of a text document. Or it can contain
    /// above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
    ///
    /// Whether a client supports versioned document edits is expressed via
    /// `workspace.workspaceEdit.documentChanges` client capability.
    ///
    /// If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
    /// only plain `TextEdit`s using the `changes` property are supported.
    member _.DocumentChanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentChanges`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentChanges") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
    /// delete file / folder operations.
    ///
    /// Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
    ///
    /// @since 3.16.0
    member _.ChangeAnnotations =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``changeAnnotations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changeAnnotations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``changes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``documentChanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``changeAnnotations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        WorkspaceEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceEdit with
                    member _.``changes`` = ``changes``
                    member _.``documentChanges`` = ``documentChanges``
                    member _.``changeAnnotations`` = ``changeAnnotations``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``changes`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``changes`` ->
                            ``json writer``.WritePropertyName("changes")
                            ``changes``.WriteTo(``json writer``)

                        match ``documentChanges`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentChanges`` ->
                            ``json writer``.WritePropertyName("documentChanges")
                            ``documentChanges``.WriteTo(``json writer``)

                        match ``changeAnnotations`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``changeAnnotations`` ->
                            ``json writer``.WritePropertyName("changeAnnotations")
                            ``changeAnnotations``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceEdit.FromElement(element))

type private IFileOperationRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``filters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The options to register for file operations.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileOperationRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual filters.
    member _.Filters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``filters``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("filters")
            LspJsonBacking.Element prop

    static member Create(``filters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        FileOperationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileOperationRegistrationOptions with
                    member _.``filters`` = ``filters``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("filters")
                        ``filters``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FileOperationRegistrationOptions.FromElement(element))

type private IRenameFilesParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``files``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The parameters sent in notifications/requests for user-initiated renames of
/// files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameFilesParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRenameFilesParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of all files/folders renamed in this operation. When a folder is renamed, only
    /// the folder will be included, and not its children.
    member _.Files =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``files``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("files")
            LspJsonBacking.Element prop

    static member Create(``files``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        RenameFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRenameFilesParams with
                    member _.``files`` = ``files``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("files")
                        ``files``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RenameFilesParams.FromElement(element))

type private IDeleteFilesParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``files``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The parameters sent in notifications/requests for user-initiated deletes of
/// files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeleteFilesParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDeleteFilesParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeleteFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of all files/folders deleted in this operation.
    member _.Files =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``files``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("files")
            LspJsonBacking.Element prop

    static member Create(``files``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DeleteFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDeleteFilesParams with
                    member _.``files`` = ``files``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("files")
                        ``files``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DeleteFilesParams.FromElement(element))

type private IMonikerParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMonikerParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        MonikerParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMonikerParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(MonikerParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IMoniker =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``scheme``: global.Amongonz.LspTypes.LspString
    abstract ``identifier``: global.Amongonz.LspTypes.LspString
    abstract ``unique``: UniquenessLevel
    abstract ``kind``: MonikerKind option

/// Moniker definition to match LSIF 0.5 moniker definition.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Moniker private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMoniker>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Moniker(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The scheme of the moniker. For example tsc or .Net
    member _.Scheme =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``scheme``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("scheme")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The identifier of the moniker. The value is opaque in LSIF however
    /// schema owners are allowed to define the structure if they want.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``identifier``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("identifier")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The scope in which the moniker is unique
    member _.Unique =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``unique``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("unique")
            UniquenessLevel.FromElement(prop)

    /// The moniker kind if known.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(MonikerKind.FromElement(prop))

    static member Create
        (
            ``scheme``: global.Amongonz.LspTypes.LspString,
            ``identifier``: global.Amongonz.LspTypes.LspString,
            ``unique``: UniquenessLevel,
            ?``kind``: MonikerKind
        ) =
        Moniker(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMoniker with
                    member _.``scheme`` = ``scheme``
                    member _.``identifier`` = ``identifier``
                    member _.``unique`` = ``unique``
                    member _.``kind`` = ``kind``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("scheme")
                        ``scheme``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("identifier")
                        ``identifier``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("unique")
                        ``unique``.WriteTo(``json writer``)

                        match ``kind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``kind`` ->
                            ``json writer``.WritePropertyName("kind")
                            ``kind``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "scheme" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "identifier" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "unique" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (UniquenessLevel.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (MonikerKind.Parse(prop)))
        then
            global.FSharp.Core.Ok(Moniker.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IMonikerRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerRegistrationOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMonikerRegistrationOptions>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        MonikerRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMonikerRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(MonikerRegistrationOptions.FromElement(element))

type private ITypeHierarchyPrepareParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option

/// The parameter of a `textDocument/prepareTypeHierarchy` request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyPrepareParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeHierarchyPrepareParams>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyPrepareParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        TypeHierarchyPrepareParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeHierarchyPrepareParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeHierarchyPrepareParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITypeHierarchyItem =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``name``: global.Amongonz.LspTypes.LspString
    abstract ``kind``: SymbolKind
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``detail``: global.Amongonz.LspTypes.LspString option
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``range``: Range
    abstract ``selectionRange``: Range
    abstract ``data``: LSPAny option

/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyItem private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeHierarchyItem>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this item.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this item.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this item.
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// More detail for this item, e.g. the signature of a function.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The resource identifier of this item.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The range enclosing this symbol not including leading/trailing whitespace
    /// but everything else, e.g. comments and code.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this symbol is being
    /// picked, e.g. the name of a function. Must be contained by the
    /// {@link TypeHierarchyItem.range `range`}.
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``selectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("selectionRange")
            Range.FromElement(prop)

    /// A data entry field that is preserved between a type hierarchy prepare and
    /// supertypes or subtypes requests. It could also be used to identify the
    /// type hierarchy in the server, helping improve the performance on
    /// resolving supertypes and subtypes.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``range``: Range,
            ``selectionRange``: Range,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``data``: LSPAny
        ) =
        TypeHierarchyItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeHierarchyItem with
                    member _.``name`` = ``name``
                    member _.``kind`` = ``kind``
                    member _.``tags`` = ``tags``
                    member _.``detail`` = ``detail``
                    member _.``uri`` = ``uri``
                    member _.``range`` = ``range``
                    member _.``selectionRange`` = ``selectionRange``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("name")
                        ``name``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``detail`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``detail`` ->
                            ``json writer``.WritePropertyName("detail")
                            ``detail``.WriteTo(``json writer``)

                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("selectionRange")
                        ``selectionRange``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TypeHierarchyItem.FromElement(element))

type private ITypeHierarchyRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Type hierarchy options used during static or dynamic registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeHierarchyRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        TypeHierarchyRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeHierarchyRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TypeHierarchyRegistrationOptions.FromElement(element))

type private ITypeHierarchySupertypesParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``item``: TypeHierarchyItem
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameter of a `typeHierarchy/supertypes` request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchySupertypesParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeHierarchySupertypesParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchySupertypesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            TypeHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: TypeHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        TypeHierarchySupertypesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeHierarchySupertypesParams with
                    member _.``item`` = ``item``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("item")
                        ``item``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeHierarchySupertypesParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITypeHierarchySubtypesParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``item``: TypeHierarchyItem
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameter of a `typeHierarchy/subtypes` request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchySubtypesParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeHierarchySubtypesParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchySubtypesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            TypeHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: TypeHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        TypeHierarchySubtypesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeHierarchySubtypesParams with
                    member _.``item`` = ``item``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("item")
                        ``item``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeHierarchySubtypesParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``range``: Range
    abstract ``context``: InlineValueContext
    abstract ``workDoneToken``: ProgressToken option

/// A parameter literal used in inline value requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The document range for which inline values should be computed.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// Additional information about the context in which inline values were
    /// requested.
    member _.Context =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            InlineValueContext.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ``context``: InlineValueContext,
            ?``workDoneToken``: ProgressToken
        ) =
        InlineValueParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``range`` = ``range``
                    member _.``context`` = ``context``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("context")
                        ``context``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineValueContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Inline value options used during static or dynamic registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        InlineValueRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineValueRegistrationOptions.FromElement(element))

type private IInlayHintParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``range``: Range
    abstract ``workDoneToken``: ProgressToken option

/// A parameter literal used in inlay hint requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlayHintParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The document range for which inlay hints should be computed.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``range``: Range, ?``workDoneToken``: ProgressToken)
        =
        InlayHintParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlayHintParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``range`` = ``range``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlayHintParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlayHint =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``position``: Position
    abstract ``label``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``kind``: InlayHintKind option
    abstract ``textEdits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``paddingLeft``: global.FSharp.Core.bool option
    abstract ``paddingRight``: global.FSharp.Core.bool option
    abstract ``data``: LSPAny option

/// Inlay hint information.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHint private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlayHint>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHint(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The position of this hint.
    ///
    /// If multiple hints have the same position, they will be shown in the order
    /// they appear in the response.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// The label of this hint. A human readable string or an array of
    /// InlayHintLabelPart label parts.
    ///
    /// *Note* that neither the string nor the label part can be empty.
    member _.Label =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            LspJsonBacking.Element prop

    /// The kind of this hint. Can be omitted in which case the client
    /// should fall back to a reasonable default.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlayHintKind.FromElement(prop))

    /// Optional text edits that are performed when accepting this inlay hint.
    ///
    /// *Note* that edits are expected to change the document so that the inlay
    /// hint (or its nearest variant) is now part of the document and the inlay
    /// hint itself is now obsolete.
    member _.TextEdits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``textEdits`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEdits") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The tooltip text when you hover over this item.
    member _.Tooltip =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tooltip`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltip") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Render padding before the hint.
    ///
    /// Note: Padding should use the editor&apos;s background color, not the
    /// background color of the hint itself. That means padding can be used
    /// to visually align/separate an inlay hint.
    member _.PaddingLeft =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``paddingLeft`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("paddingLeft") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Render padding after the hint.
    ///
    /// Note: Padding should use the editor&apos;s background color, not the
    /// background color of the hint itself. That means padding can be used
    /// to visually align/separate an inlay hint.
    member _.PaddingRight =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``paddingRight`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("paddingRight") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A data entry field that is preserved on an inlay hint between
    /// a `textDocument/inlayHint` and a `inlayHint/resolve` request.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``position``: Position,
            ``label``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``kind``: InlayHintKind,
            ?``textEdits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``paddingLeft``: global.FSharp.Core.bool,
            ?``paddingRight``: global.FSharp.Core.bool,
            ?``data``: LSPAny
        ) =
        InlayHint(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlayHint with
                    member _.``position`` = ``position``
                    member _.``label`` = ``label``
                    member _.``kind`` = ``kind``
                    member _.``textEdits`` = ``textEdits``
                    member _.``tooltip`` = ``tooltip``
                    member _.``paddingLeft`` = ``paddingLeft``
                    member _.``paddingRight`` = ``paddingRight``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("label")
                        ``label``.WriteTo(``json writer``)

                        match ``kind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``kind`` -> ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``textEdits`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``textEdits`` ->
                            ``json writer``.WritePropertyName("textEdits")
                            ``textEdits``.WriteTo(``json writer``)

                        match ``tooltip`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tooltip`` ->
                            ``json writer``.WritePropertyName("tooltip")
                            ``tooltip``.WriteTo(``json writer``)

                        match ``paddingLeft`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``paddingLeft`` ->
                            ``json writer``.WriteBoolean("paddingLeft", ``paddingLeft``)

                        match ``paddingRight`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``paddingRight`` ->
                            ``json writer``.WriteBoolean("paddingRight", ``paddingRight``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHint.FromElement(element))

type private IInlayHintRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Inlay hint options used during static or dynamic registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlayHintRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for an inlay hint item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        InlayHintRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlayHintRegistrationOptions with
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHintRegistrationOptions.FromElement(element))

type private IDocumentDiagnosticParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``identifier``: global.Amongonz.LspTypes.LspString option
    abstract ``previousResultId``: global.Amongonz.LspTypes.LspString option
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters of the document diagnostic request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentDiagnosticParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentDiagnosticParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The additional identifier  provided during registration.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The result id of a previous response if provided.
    member _.PreviousResultId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``previousResultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("previousResultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``previousResultId``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentDiagnosticParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentDiagnosticParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``identifier`` = ``identifier``
                    member _.``previousResultId`` = ``previousResultId``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``identifier`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``identifier`` ->
                            ``json writer``.WritePropertyName("identifier")
                            ``identifier``.WriteTo(``json writer``)

                        match ``previousResultId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``previousResultId`` ->
                            ``json writer``.WritePropertyName("previousResultId")
                            ``previousResultId``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "identifier" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "previousResultId" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentDiagnosticParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentDiagnosticReportPartialResult =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// A partial result for a document diagnostic report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticReportPartialResult
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentDiagnosticReportPartialResult>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentDiagnosticReportPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.RelatedDocuments =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``relatedDocuments``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("relatedDocuments")
            LspJsonBacking.Element prop

    static member Create(``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DocumentDiagnosticReportPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentDiagnosticReportPartialResult with
                    member _.``relatedDocuments`` = ``relatedDocuments``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("relatedDocuments")
                        ``relatedDocuments``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentDiagnosticReportPartialResult.FromElement(element))

type private IDiagnosticServerCancellationData =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``retriggerRequest``: global.FSharp.Core.bool

/// Cancellation data returned from a diagnostic request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticServerCancellationData
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDiagnosticServerCancellationData>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticServerCancellationData(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.RetriggerRequest =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``retriggerRequest``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("retriggerRequest")
            prop.GetBoolean()

    static member Create(``retriggerRequest``: global.FSharp.Core.bool) =
        DiagnosticServerCancellationData(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDiagnosticServerCancellationData with
                    member _.``retriggerRequest`` = ``retriggerRequest``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteBoolean("retriggerRequest", ``retriggerRequest``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "retriggerRequest" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticServerCancellationData.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDiagnosticRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``identifier``: global.Amongonz.LspTypes.LspString option
    abstract ``interFileDependencies``: global.FSharp.Core.bool
    abstract ``workspaceDiagnostics``: global.FSharp.Core.bool
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Diagnostic registration options.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDiagnosticRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// An optional identifier under which the diagnostics are
    /// managed by the client.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Whether the language has inter file dependencies meaning that
    /// editing code in one file can result in a different diagnostic
    /// set in another file. Inter file dependencies are common for
    /// most programming languages and typically uncommon for linters.
    member _.InterFileDependencies =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``interFileDependencies``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("interFileDependencies")
            prop.GetBoolean()

    /// The server provides support for workspace diagnostics as well.
    member _.WorkspaceDiagnostics =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``workspaceDiagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("workspaceDiagnostics")
            prop.GetBoolean()

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``interFileDependencies``: global.FSharp.Core.bool,
            ``workspaceDiagnostics``: global.FSharp.Core.bool,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        DiagnosticRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDiagnosticRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``identifier`` = ``identifier``
                    member _.``interFileDependencies`` = ``interFileDependencies``
                    member _.``workspaceDiagnostics`` = ``workspaceDiagnostics``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``identifier`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``identifier`` ->
                            ``json writer``.WritePropertyName("identifier")
                            ``identifier``.WriteTo(``json writer``)

                        ``json writer``.WriteBoolean("interFileDependencies", ``interFileDependencies``)
                        ``json writer``.WriteBoolean("workspaceDiagnostics", ``workspaceDiagnostics``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DiagnosticRegistrationOptions.FromElement(element))

type private IWorkspaceDiagnosticParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``identifier``: global.Amongonz.LspTypes.LspString option
    abstract ``previousResultIds``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters of the workspace diagnostic request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDiagnosticParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceDiagnosticParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDiagnosticParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The additional identifier provided during registration.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The currently known diagnostic reports with their
    /// previous result ids.
    member _.PreviousResultIds =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``previousResultIds``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("previousResultIds")
            LspJsonBacking.Element prop

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``previousResultIds``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        WorkspaceDiagnosticParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceDiagnosticParams with
                    member _.``identifier`` = ``identifier``
                    member _.``previousResultIds`` = ``previousResultIds``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``identifier`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``identifier`` ->
                            ``json writer``.WritePropertyName("identifier")
                            ``identifier``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("previousResultIds")
                        ``previousResultIds``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceDiagnosticParams.FromElement(element))

type private IWorkspaceDiagnosticReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// A workspace diagnostic report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDiagnosticReport private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceDiagnosticReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        WorkspaceDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceDiagnosticReport with
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceDiagnosticReport.FromElement(element))

type private IWorkspaceDiagnosticReportPartialResult =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// A partial result for a workspace diagnostic report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDiagnosticReportPartialResult
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceDiagnosticReportPartialResult>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDiagnosticReportPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        WorkspaceDiagnosticReportPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceDiagnosticReportPartialResult with
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceDiagnosticReportPartialResult.FromElement(element))

type private IDidOpenNotebookDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``notebookDocument``: NotebookDocument
    abstract ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The params sent in an open notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidOpenNotebookDocumentParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidOpenNotebookDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidOpenNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that got opened.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            NotebookDocument.FromElement(prop)

    /// The text documents that represent the content
    /// of a notebook cell.
    member _.CellTextDocuments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``cellTextDocuments``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("cellTextDocuments")
            LspJsonBacking.Element prop

    static member Create
        (
            ``notebookDocument``: NotebookDocument,
            ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        DidOpenNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidOpenNotebookDocumentParams with
                    member _.``notebookDocument`` = ``notebookDocument``
                    member _.``cellTextDocuments`` = ``cellTextDocuments``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("notebookDocument")
                        ``notebookDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("cellTextDocuments")
                        ``cellTextDocuments``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidOpenNotebookDocumentParams.FromElement(element))

type private IDidChangeNotebookDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``notebookDocument``: VersionedNotebookDocumentIdentifier
    abstract ``change``: NotebookDocumentChangeEvent

/// The params sent in a change notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeNotebookDocumentParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeNotebookDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that did change. The version number points
    /// to the version after all provided changes have been applied. If
    /// only the text document content of a cell changes the notebook version
    /// doesn&apos;t necessarily have to change.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            VersionedNotebookDocumentIdentifier.FromElement(prop)

    /// The actual changes to the notebook document.
    ///
    /// The changes describe single state changes to the notebook document.
    /// So if there are two changes c1 (at array index 0) and c2 (at array
    /// index 1) for a notebook in state S then c1 moves the notebook from
    /// S to S&apos; and c2 from S&apos; to S&apos;&apos;. So c1 is computed on the state S and
    /// c2 is computed on the state S&apos;.
    ///
    /// To mirror the content of a notebook using change events use the following approach:
    /// - start with the same initial content
    /// - apply the &apos;notebookDocument/didChange&apos; notifications in the order you receive them.
    /// - apply the `NotebookChangeEvent`s in a single notification in the order
    ///   you receive them.
    member _.Change =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``change``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("change")
            NotebookDocumentChangeEvent.FromElement(prop)

    static member Create
        (``notebookDocument``: VersionedNotebookDocumentIdentifier, ``change``: NotebookDocumentChangeEvent)
        =
        DidChangeNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeNotebookDocumentParams with
                    member _.``notebookDocument`` = ``notebookDocument``
                    member _.``change`` = ``change``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("notebookDocument")
                        ``notebookDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("change")
                        ``change``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "notebookDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (VersionedNotebookDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "change" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentChangeEvent.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidChangeNotebookDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidSaveNotebookDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``notebookDocument``: NotebookDocumentIdentifier

/// The params sent in a save notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidSaveNotebookDocumentParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidSaveNotebookDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidSaveNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that got saved.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            NotebookDocumentIdentifier.FromElement(prop)

    static member Create(``notebookDocument``: NotebookDocumentIdentifier) =
        DidSaveNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidSaveNotebookDocumentParams with
                    member _.``notebookDocument`` = ``notebookDocument``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("notebookDocument")
                        ``notebookDocument``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "notebookDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentIdentifier.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidSaveNotebookDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidCloseNotebookDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``notebookDocument``: NotebookDocumentIdentifier
    abstract ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The params sent in a close notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidCloseNotebookDocumentParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidCloseNotebookDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidCloseNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that got closed.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            NotebookDocumentIdentifier.FromElement(prop)

    /// The text documents that represent the content
    /// of a notebook cell that got closed.
    member _.CellTextDocuments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``cellTextDocuments``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("cellTextDocuments")
            LspJsonBacking.Element prop

    static member Create
        (
            ``notebookDocument``: NotebookDocumentIdentifier,
            ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        DidCloseNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidCloseNotebookDocumentParams with
                    member _.``notebookDocument`` = ``notebookDocument``
                    member _.``cellTextDocuments`` = ``cellTextDocuments``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("notebookDocument")
                        ``notebookDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("cellTextDocuments")
                        ``cellTextDocuments``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidCloseNotebookDocumentParams.FromElement(element))

type private IInlineCompletionParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``context``: InlineCompletionContext
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option

/// A parameter literal used in inline completion requests.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineCompletionParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Additional information about the context in which inline completions were
    /// requested.
    member _.Context =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            InlineCompletionContext.FromElement(prop)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``context``: InlineCompletionContext,
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken
        ) =
        InlineCompletionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineCompletionParams with
                    member _.``context`` = ``context``
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("context")
                        ``context``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineCompletionContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineCompletionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineCompletionList =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Represents a collection of {@link InlineCompletionItem inline completion items} to be presented in the editor.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionList private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineCompletionList>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionList(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The inline completion items
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        InlineCompletionList(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineCompletionList with
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineCompletionList.FromElement(element))

type private IInlineCompletionItem =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``insertText``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``filterText``: global.Amongonz.LspTypes.LspString option
    abstract ``range``: Range option
    abstract ``command``: Command option

/// An inline completion item represents a text snippet that is proposed inline to complete text that is being typed.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionItem private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineCompletionItem>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text to replace the range with. Must be set.
    member _.InsertText =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``insertText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("insertText")
            LspJsonBacking.Element prop

    /// A text that is used to decide if this inline completion should be shown. When `falsy` the {@link InlineCompletionItem.insertText} is used.
    member _.FilterText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``filterText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("filterText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The range to replace. Must begin and end on the same line.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    /// An optional {@link Command} that is executed *after* inserting this completion.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    static member Create
        (
            ``insertText``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``filterText``: global.Amongonz.LspTypes.LspString,
            ?``range``: Range,
            ?``command``: Command
        ) =
        InlineCompletionItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineCompletionItem with
                    member _.``insertText`` = ``insertText``
                    member _.``filterText`` = ``filterText``
                    member _.``range`` = ``range``
                    member _.``command`` = ``command``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("insertText")
                        ``insertText``.WriteTo(``json writer``)

                        match ``filterText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``filterText`` ->
                            ``json writer``.WritePropertyName("filterText")
                            ``filterText``.WriteTo(``json writer``)

                        match ``range`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``range`` ->
                            ``json writer``.WritePropertyName("range")
                            ``range``.WriteTo(``json writer``)

                        match ``command`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``command`` ->
                            ``json writer``.WritePropertyName("command")
                            ``command``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineCompletionItem.FromElement(element))

type private IInlineCompletionRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Inline completion options used during static or dynamic registration.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineCompletionRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        InlineCompletionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineCompletionRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineCompletionRegistrationOptions.FromElement(element))

type private IRegistrationParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``registrations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RegistrationParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRegistrationParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RegistrationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Registrations =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``registrations``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("registrations")
            LspJsonBacking.Element prop

    static member Create(``registrations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        RegistrationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRegistrationParams with
                    member _.``registrations`` = ``registrations``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("registrations")
                        ``registrations``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RegistrationParams.FromElement(element))

type private IUnregistrationParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``unregisterations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type UnregistrationParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IUnregistrationParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        UnregistrationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Unregisterations =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``unregisterations``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("unregisterations")
            LspJsonBacking.Element prop

    static member Create(``unregisterations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        UnregistrationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IUnregistrationParams with
                    member _.``unregisterations`` = ``unregisterations``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("unregisterations")
                        ``unregisterations``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(UnregistrationParams.FromElement(element))

type private IInitializeParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``processId``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``locale``: global.Amongonz.LspTypes.LspString option
    abstract ``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``capabilities``: ClientCapabilities
    abstract ``initializationOptions``: LSPAny option
    abstract ``trace``: TraceValues option
    abstract ``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializeParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInitializeParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The process Id of the parent process that started
    /// the server.
    ///
    /// Is `null` if the process has not been started by another process.
    /// If the parent process is not alive then the server should exit.
    member _.ProcessId =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``processId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("processId")
            LspJsonBacking.Element prop

    /// Information about the client
    ///
    /// @since 3.15.0
    member _.ClientInfo =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``clientInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("clientInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The locale the client is currently showing the user interface
    /// in. This must not necessarily be the locale of the operating
    /// system.
    ///
    /// Uses IETF language tags as the value&apos;s syntax
    /// (See https://en.wikipedia.org/wiki/IETF_language_tag)
    ///
    /// @since 3.16.0
    member _.Locale =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``locale`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("locale") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The rootPath of the workspace. Is null
    /// if no folder is open.
    ///
    /// @deprecated in favour of rootUri.
    [<global.System.Obsolete("in favour of rootUri.")>]
    member _.RootPath =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rootPath`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rootPath") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The rootUri of the workspace. Is null if no
    /// folder is open. If both `rootPath` and `rootUri` are set
    /// `rootUri` wins.
    ///
    /// @deprecated in favour of workspaceFolders.
    [<global.System.Obsolete("in favour of workspaceFolders.")>]
    member _.RootUri =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``rootUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("rootUri")
            LspJsonBacking.Element prop

    /// The capabilities provided by the client (editor or tool)
    member _.Capabilities =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``capabilities``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("capabilities")
            ClientCapabilities.FromElement(prop)

    /// User provided initialization options.
    member _.InitializationOptions =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``initializationOptions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("initializationOptions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    /// The initial trace setting. If omitted trace is disabled (&apos;off&apos;).
    member _.Trace =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``trace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TraceValues.FromElement(prop))

    /// The workspace folders configured in the client when the server starts.
    ///
    /// This property is only available if the client supports workspace folders.
    /// It can be `null` if the client supports workspace folders but none are
    /// configured.
    ///
    /// @since 3.6.0
    member _.WorkspaceFolders =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workspaceFolders`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceFolders") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``processId``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``capabilities``: ClientCapabilities,
            ?``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``locale``: global.Amongonz.LspTypes.LspString,
            ?``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``initializationOptions``: LSPAny,
            ?``trace``: TraceValues,
            ?``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        InitializeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInitializeParams with
                    member _.``processId`` = ``processId``
                    member _.``clientInfo`` = ``clientInfo``
                    member _.``locale`` = ``locale``
                    member _.``rootPath`` = ``rootPath``
                    member _.``rootUri`` = ``rootUri``
                    member _.``capabilities`` = ``capabilities``
                    member _.``initializationOptions`` = ``initializationOptions``
                    member _.``trace`` = ``trace``
                    member _.``workspaceFolders`` = ``workspaceFolders``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("processId")
                        ``processId``.WriteTo(``json writer``)

                        match ``clientInfo`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``clientInfo`` ->
                            ``json writer``.WritePropertyName("clientInfo")
                            ``clientInfo``.WriteTo(``json writer``)

                        match ``locale`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``locale`` ->
                            ``json writer``.WritePropertyName("locale")
                            ``locale``.WriteTo(``json writer``)

                        match ``rootPath`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rootPath`` ->
                            ``json writer``.WritePropertyName("rootPath")
                            ``rootPath``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("rootUri")
                        ``rootUri``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("capabilities")
                        ``capabilities``.WriteTo(``json writer``)

                        match ``initializationOptions`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``initializationOptions`` ->
                            ``json writer``.WritePropertyName("initializationOptions")
                            ``initializationOptions``.WriteTo(``json writer``)

                        match ``trace`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``trace`` ->
                            ``json writer``.WritePropertyName("trace")
                            ``trace``.WriteTo(``json writer``)

                        match ``workspaceFolders`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workspaceFolders`` ->
                            ``json writer``.WritePropertyName("workspaceFolders")
                            ``workspaceFolders``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InitializeParams.FromElement(element))

type private IInitializeResult =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``capabilities``: ServerCapabilities
    abstract ``serverInfo``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// The result returned from an initialize request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializeResult private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInitializeResult>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializeResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The capabilities the language server provides.
    member _.Capabilities =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``capabilities``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("capabilities")
            ServerCapabilities.FromElement(prop)

    /// Information about the server.
    ///
    /// @since 3.15.0
    member _.ServerInfo =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``serverInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("serverInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``capabilities``: ServerCapabilities,
            ?``serverInfo``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        InitializeResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInitializeResult with
                    member _.``capabilities`` = ``capabilities``
                    member _.``serverInfo`` = ``serverInfo``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("capabilities")
                        ``capabilities``.WriteTo(``json writer``)

                        match ``serverInfo`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``serverInfo`` ->
                            ``json writer``.WritePropertyName("serverInfo")
                            ``serverInfo``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InitializeResult.FromElement(element))

type private IInitializeError =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``retry``: global.FSharp.Core.bool

/// The data type of the ResponseError if the
/// initialize request fails.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializeError private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInitializeError>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializeError(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Indicates whether the client execute the following retry logic:
    /// (1) show the message provided by the ResponseError to the user
    /// (2) user selects retry or cancel
    /// (3) if user selected retry the initialize method is sent again.
    member _.Retry =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``retry``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("retry")
            prop.GetBoolean()

    static member Create(``retry``: global.FSharp.Core.bool) =
        InitializeError(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInitializeError with
                    member _.``retry`` = ``retry``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteBoolean("retry", ``retry``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "retry" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InitializeError.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializedParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<global.Amongonz.LspTypes.ILspJsonBackingObj>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializedParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Create() =
        InitializedParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new global.Amongonz.LspTypes.ILspJsonBackingObj with

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if true then
            global.FSharp.Core.Ok(InitializedParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidChangeConfigurationParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``settings``: LSPAny

/// The parameters of a change configuration notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeConfigurationParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeConfigurationParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeConfigurationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual changed settings
    member _.Settings =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``settings``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("settings")
            LSPAny.FromElement(prop)

    static member Create(``settings``: LSPAny) =
        DidChangeConfigurationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeConfigurationParams with
                    member _.``settings`` = ``settings``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("settings")
                        ``settings``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "settings" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidChangeConfigurationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidChangeConfigurationRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``section``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeConfigurationRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeConfigurationRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeConfigurationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Section =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``section`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("section") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create(?``section``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DidChangeConfigurationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeConfigurationRegistrationOptions with
                    member _.``section`` = ``section``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``section`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``section`` ->
                            ``json writer``.WritePropertyName("section")
                            ``section``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeConfigurationRegistrationOptions.FromElement(element))

type private IShowMessageParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``type``: MessageType
    abstract ``message``: global.Amongonz.LspTypes.LspString

/// The parameters of a notification message.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowMessageParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IShowMessageParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowMessageParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The message type. See {@link MessageType}
    member _.Type =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            MessageType.FromElement(prop)

    /// The actual message.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``type``: MessageType, ``message``: global.Amongonz.LspTypes.LspString) =
        ShowMessageParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IShowMessageParams with
                    member _.``type`` = ``type``
                    member _.``message`` = ``message``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("type", int ``type``)
                        ``json writer``.WritePropertyName("message")
                        ``message``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "type" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ShowMessageParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IShowMessageRequestParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``type``: MessageType
    abstract ``message``: global.Amongonz.LspTypes.LspString
    abstract ``actions``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowMessageRequestParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IShowMessageRequestParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowMessageRequestParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The message type. See {@link MessageType}
    member _.Type =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            MessageType.FromElement(prop)

    /// The actual message.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The message action items to present.
    member _.Actions =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``actions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("actions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``type``: MessageType,
            ``message``: global.Amongonz.LspTypes.LspString,
            ?``actions``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        ShowMessageRequestParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IShowMessageRequestParams with
                    member _.``type`` = ``type``
                    member _.``message`` = ``message``
                    member _.``actions`` = ``actions``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("type", int ``type``)
                        ``json writer``.WritePropertyName("message")
                        ``message``.WriteTo(``json writer``)

                        match ``actions`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``actions`` ->
                            ``json writer``.WritePropertyName("actions")
                            ``actions``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ShowMessageRequestParams.FromElement(element))

type private IMessageActionItem =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``title``: global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MessageActionItem private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMessageActionItem>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MessageActionItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A short title like &apos;Retry&apos;, &apos;Open Log&apos; etc.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``title``: global.Amongonz.LspTypes.LspString) =
        MessageActionItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMessageActionItem with
                    member _.``title`` = ``title``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("title")
                        ``title``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "title" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(MessageActionItem.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ILogMessageParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``type``: MessageType
    abstract ``message``: global.Amongonz.LspTypes.LspString

/// The log message parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LogMessageParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILogMessageParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LogMessageParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The message type. See {@link MessageType}
    member _.Type =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            MessageType.FromElement(prop)

    /// The actual message.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``type``: MessageType, ``message``: global.Amongonz.LspTypes.LspString) =
        LogMessageParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILogMessageParams with
                    member _.``type`` = ``type``
                    member _.``message`` = ``message``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("type", int ``type``)
                        ``json writer``.WritePropertyName("message")
                        ``message``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "type" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(LogMessageParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidOpenTextDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentItem

/// The parameters sent in an open text document notification
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidOpenTextDocumentParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidOpenTextDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidOpenTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that was opened.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentItem.FromElement(prop)

    static member Create(``textDocument``: TextDocumentItem) =
        DidOpenTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidOpenTextDocumentParams with
                    member _.``textDocument`` = ``textDocument``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentItem.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidOpenTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidChangeTextDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: VersionedTextDocumentIdentifier
    abstract ``contentChanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The change text document notification&apos;s parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeTextDocumentParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeTextDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that did change. The version number points
    /// to the version after all provided content changes have
    /// been applied.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            VersionedTextDocumentIdentifier.FromElement(prop)

    /// The actual content changes. The content changes describe single state changes
    /// to the document. So if there are two content changes c1 (at array index 0) and
    /// c2 (at array index 1) for a document in state S then c1 moves the document from
    /// S to S&apos; and c2 from S&apos; to S&apos;&apos;. So c1 is computed on the state S and c2 is computed
    /// on the state S&apos;.
    ///
    /// To mirror the content of a document using change events use the following approach:
    /// - start with the same initial content
    /// - apply the &apos;textDocument/didChange&apos; notifications in the order you receive them.
    /// - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
    ///   you receive them.
    member _.ContentChanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``contentChanges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("contentChanges")
            LspJsonBacking.Element prop

    static member Create
        (
            ``textDocument``: VersionedTextDocumentIdentifier,
            ``contentChanges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        DidChangeTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeTextDocumentParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``contentChanges`` = ``contentChanges``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("contentChanges")
                        ``contentChanges``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeTextDocumentParams.FromElement(element))

type private ITextDocumentChangeRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``syncKind``: TextDocumentSyncKind
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Describe options to be used when registered for text document change events.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentChangeRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentChangeRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentChangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// How documents are synced to the server.
    member _.SyncKind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``syncKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("syncKind")
            TextDocumentSyncKind.FromElement(prop)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create
        (
            ``syncKind``: TextDocumentSyncKind,
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        TextDocumentChangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentChangeRegistrationOptions with
                    member _.``syncKind`` = ``syncKind``
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("syncKind", int ``syncKind``)
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentChangeRegistrationOptions.FromElement(element))

type private IDidCloseTextDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier

/// The parameters sent in a close text document notification
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidCloseTextDocumentParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidCloseTextDocumentParams>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidCloseTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that was closed.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    static member Create(``textDocument``: TextDocumentIdentifier) =
        DidCloseTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidCloseTextDocumentParams with
                    member _.``textDocument`` = ``textDocument``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidCloseTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidSaveTextDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``text``: global.Amongonz.LspTypes.LspString option

/// The parameters sent in a save text document notification
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidSaveTextDocumentParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidSaveTextDocumentParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidSaveTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that was saved.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// Optional the content when saved. Depends on the includeText value
    /// when the save notification was requested.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``text`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("text") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(``textDocument``: TextDocumentIdentifier, ?``text``: global.Amongonz.LspTypes.LspString) =
        DidSaveTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidSaveTextDocumentParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``text`` = ``text``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``text`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``text`` ->
                            ``json writer``.WritePropertyName("text")
                            ``text``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidSaveTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentSaveRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``includeText``: global.FSharp.Core.bool option

/// Save registration options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentSaveRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentSaveRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentSaveRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The client is supposed to include the content on save.
    member _.IncludeText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``includeText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("includeText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``includeText``: global.FSharp.Core.bool
        ) =
        TextDocumentSaveRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentSaveRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``includeText`` = ``includeText``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``includeText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``includeText`` ->
                            ``json writer``.WriteBoolean("includeText", ``includeText``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentSaveRegistrationOptions.FromElement(element))

type private IWillSaveTextDocumentParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``reason``: TextDocumentSaveReason

/// The parameters sent in a will save text document notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WillSaveTextDocumentParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWillSaveTextDocumentParams>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WillSaveTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that will be saved.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The &apos;TextDocumentSaveReason&apos;.
    member _.Reason =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``reason``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("reason")
            TextDocumentSaveReason.FromElement(prop)

    static member Create(``textDocument``: TextDocumentIdentifier, ``reason``: TextDocumentSaveReason) =
        WillSaveTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWillSaveTextDocumentParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``reason`` = ``reason``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("reason", int ``reason``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "reason" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
        then
            global.FSharp.Core.Ok(WillSaveTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextEdit =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``newText``: global.Amongonz.LspTypes.LspString

/// A text edit applicable to a text document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextEdit private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextEdit>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range of the text document to be manipulated. To insert
    /// text into a document create a range where start === end.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The string to be inserted. For delete operations use an
    /// empty string.
    member _.NewText =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``newText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newText")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``range``: Range, ``newText``: global.Amongonz.LspTypes.LspString) =
        TextEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextEdit with
                    member _.``range`` = ``range``
                    member _.``newText`` = ``newText``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("newText")
                        ``newText``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newText" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextEdit.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidChangeWatchedFilesParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``changes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The watched files change notification&apos;s parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWatchedFilesParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeWatchedFilesParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWatchedFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual file events.
    member _.Changes =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``changes``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("changes")
            LspJsonBacking.Element prop

    static member Create(``changes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DidChangeWatchedFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeWatchedFilesParams with
                    member _.``changes`` = ``changes``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("changes")
                        ``changes``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeWatchedFilesParams.FromElement(element))

type private IDidChangeWatchedFilesRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``watchers``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Describe options to be used when registered for text document change events.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWatchedFilesRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeWatchedFilesRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWatchedFilesRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The watchers to register.
    member _.Watchers =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``watchers``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("watchers")
            LspJsonBacking.Element prop

    static member Create(``watchers``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DidChangeWatchedFilesRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeWatchedFilesRegistrationOptions with
                    member _.``watchers`` = ``watchers``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("watchers")
                        ``watchers``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeWatchedFilesRegistrationOptions.FromElement(element))

type private IPublishDiagnosticsParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``version``: global.FSharp.Core.int option
    abstract ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The publish diagnostic notification&apos;s parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PublishDiagnosticsParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IPublishDiagnosticsParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PublishDiagnosticsParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which diagnostic information is reported.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Optional the version number of the document the diagnostics are published for.
    ///
    /// @since 3.15.0
    member _.Version =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``version`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("version") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// An array of diagnostic information items.
    member _.Diagnostics =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``diagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("diagnostics")
            LspJsonBacking.Element prop

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``version``: global.FSharp.Core.int
        ) =
        PublishDiagnosticsParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IPublishDiagnosticsParams with
                    member _.``uri`` = ``uri``
                    member _.``version`` = ``version``
                    member _.``diagnostics`` = ``diagnostics``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)

                        match ``version`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``version`` -> ``json writer``.WriteNumber("version", ``version``)

                        ``json writer``.WritePropertyName("diagnostics")
                        ``diagnostics``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(PublishDiagnosticsParams.FromElement(element))

type private ICompletionParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``context``: CompletionContext option
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Completion parameters
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The completion context. This is only available it the client specifies
    /// to send this using the client capability `textDocument.completion.contextSupport === true`
    member _.Context =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``context`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("context") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionContext.FromElement(prop))

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``context``: CompletionContext,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        CompletionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionParams with
                    member _.``context`` = ``context``
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``context`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``context`` ->
                            ``json writer``.WritePropertyName("context")
                            ``context``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CompletionContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CompletionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICompletionItem =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``label``: global.Amongonz.LspTypes.LspString
    abstract ``labelDetails``: CompletionItemLabelDetails option
    abstract ``kind``: CompletionItemKind option
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``detail``: global.Amongonz.LspTypes.LspString option
    abstract ``documentation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``deprecated``: global.FSharp.Core.bool option
    abstract ``preselect``: global.FSharp.Core.bool option
    abstract ``sortText``: global.Amongonz.LspTypes.LspString option
    abstract ``filterText``: global.Amongonz.LspTypes.LspString option
    abstract ``insertText``: global.Amongonz.LspTypes.LspString option
    abstract ``insertTextFormat``: InsertTextFormat option
    abstract ``insertTextMode``: InsertTextMode option
    abstract ``textEdit``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``textEditText``: global.Amongonz.LspTypes.LspString option
    abstract ``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``commitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``command``: Command option
    abstract ``data``: LSPAny option

/// A completion item represents a text snippet that is
/// proposed to complete text that is being typed.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionItem private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionItem>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this completion item.
    ///
    /// The label property is also by default the text that
    /// is inserted when selecting this completion.
    ///
    /// If label details are provided the label itself should
    /// be an unqualified name of the completion item.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Additional details for the label
    ///
    /// @since 3.17.0
    member _.LabelDetails =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``labelDetails`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("labelDetails") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionItemLabelDetails.FromElement(prop))

    /// The kind of this completion item. Based of the kind
    /// an icon is chosen by the editor.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionItemKind.FromElement(prop))

    /// Tags for this completion item.
    ///
    /// @since 3.15.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A human-readable string with additional information
    /// about this item, like type or symbol information.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A human-readable string that represents a doc-comment.
    member _.Documentation =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Indicates if this item is deprecated.
    /// @deprecated Use `tags` instead.
    [<global.System.Obsolete("Use `tags` instead.")>]
    member _.Deprecated =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``deprecated`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("deprecated") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Select this item when showing.
    ///
    /// *Note* that only one completion item can be selected and that the
    /// tool / client decides which item that is. The rule is that the *first*
    /// item of those that match best is selected.
    member _.Preselect =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``preselect`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("preselect") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A string that should be used when comparing this item
    /// with other items. When `falsy` the {@link CompletionItem.label label}
    /// is used.
    member _.SortText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``sortText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("sortText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A string that should be used when filtering a set of
    /// completion items. When `falsy` the {@link CompletionItem.label label}
    /// is used.
    member _.FilterText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``filterText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("filterText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A string that should be inserted into a document when selecting
    /// this completion. When `falsy` the {@link CompletionItem.label label}
    /// is used.
    ///
    /// The `insertText` is subject to interpretation by the client side.
    /// Some tools might not take the string literally. For example
    /// VS Code when code complete is requested in this example
    /// `con&lt;cursor position&gt;` and a completion item with an `insertText` of
    /// `console` is provided it will only insert `sole`. Therefore it is
    /// recommended to use `textEdit` instead since it avoids additional client
    /// side interpretation.
    member _.InsertText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``insertText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The format of the insert text. The format applies to both the
    /// `insertText` property and the `newText` property of a provided
    /// `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
    ///
    /// Please note that the insertTextFormat doesn&apos;t apply to
    /// `additionalTextEdits`.
    member _.InsertTextFormat =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``insertTextFormat`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertTextFormat") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InsertTextFormat.FromElement(prop))

    /// How whitespace and indentation is handled during completion
    /// item insertion. If not provided the clients default value depends on
    /// the `textDocument.completion.insertTextMode` client capability.
    ///
    /// @since 3.16.0
    member _.InsertTextMode =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``insertTextMode`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertTextMode") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InsertTextMode.FromElement(prop))

    /// An {@link TextEdit edit} which is applied to a document when selecting
    /// this completion. When an edit is provided the value of
    /// {@link CompletionItem.insertText insertText} is ignored.
    ///
    /// Most editors support two different operations when accepting a completion
    /// item. One is to insert a completion text and the other is to replace an
    /// existing text with a completion text. Since this can usually not be
    /// predetermined by a server it can report both ranges. Clients need to
    /// signal support for `InsertReplaceEdits` via the
    /// `textDocument.completion.insertReplaceSupport` client capability
    /// property.
    ///
    /// *Note 1:* The text edit&apos;s range as well as both ranges from an insert
    /// replace edit must be a [single line] and they must contain the position
    /// at which completion has been requested.
    /// *Note 2:* If an `InsertReplaceEdit` is returned the edit&apos;s insert range
    /// must be a prefix of the edit&apos;s replace range, that means it must be
    /// contained and starting at the same position.
    ///
    /// @since 3.16.0 additional type `InsertReplaceEdit`
    member _.TextEdit =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``textEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The edit text used if the completion item is part of a CompletionList and
    /// CompletionList defines an item default for the text edit range.
    ///
    /// Clients will only honor this property if they opt into completion list
    /// item defaults using the capability `completionList.itemDefaults`.
    ///
    /// If not provided and a list&apos;s default range is provided the label
    /// property is used as a text.
    ///
    /// @since 3.17.0
    member _.TextEditText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``textEditText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEditText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// An optional array of additional {@link TextEdit text edits} that are applied when
    /// selecting this completion. Edits must not overlap (including the same insert position)
    /// with the main {@link CompletionItem.textEdit edit} nor with themselves.
    ///
    /// Additional text edits should be used to change text unrelated to the current cursor position
    /// (for example adding an import statement at the top of the file if the completion item will
    /// insert an unqualified type).
    member _.AdditionalTextEdits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``additionalTextEdits`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("additionalTextEdits") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional set of characters that when pressed while this completion is active will accept it first and
    /// then type that character. *Note* that all commit characters should have `length=1` and that superfluous
    /// characters will be ignored.
    member _.CommitCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``commitCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("commitCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional {@link Command command} that is executed *after* inserting this completion. *Note* that
    /// additional modifications to the current document should be described with the
    /// {@link CompletionItem.additionalTextEdits additionalTextEdits}-property.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    /// A data entry field that is preserved on a completion item between a
    /// {@link CompletionRequest} and a {@link CompletionResolveRequest}.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``labelDetails``: CompletionItemLabelDetails,
            ?``kind``: CompletionItemKind,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``documentation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``deprecated``: global.FSharp.Core.bool,
            ?``preselect``: global.FSharp.Core.bool,
            ?``sortText``: global.Amongonz.LspTypes.LspString,
            ?``filterText``: global.Amongonz.LspTypes.LspString,
            ?``insertText``: global.Amongonz.LspTypes.LspString,
            ?``insertTextFormat``: InsertTextFormat,
            ?``insertTextMode``: InsertTextMode,
            ?``textEdit``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``textEditText``: global.Amongonz.LspTypes.LspString,
            ?``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``commitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``command``: Command,
            ?``data``: LSPAny
        ) =
        CompletionItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionItem with
                    member _.``label`` = ``label``
                    member _.``labelDetails`` = ``labelDetails``
                    member _.``kind`` = ``kind``
                    member _.``tags`` = ``tags``
                    member _.``detail`` = ``detail``
                    member _.``documentation`` = ``documentation``
                    member _.``deprecated`` = ``deprecated``
                    member _.``preselect`` = ``preselect``
                    member _.``sortText`` = ``sortText``
                    member _.``filterText`` = ``filterText``
                    member _.``insertText`` = ``insertText``
                    member _.``insertTextFormat`` = ``insertTextFormat``
                    member _.``insertTextMode`` = ``insertTextMode``
                    member _.``textEdit`` = ``textEdit``
                    member _.``textEditText`` = ``textEditText``
                    member _.``additionalTextEdits`` = ``additionalTextEdits``
                    member _.``commitCharacters`` = ``commitCharacters``
                    member _.``command`` = ``command``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("label")
                        ``label``.WriteTo(``json writer``)

                        match ``labelDetails`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``labelDetails`` ->
                            ``json writer``.WritePropertyName("labelDetails")
                            ``labelDetails``.WriteTo(``json writer``)

                        match ``kind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``kind`` -> ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``detail`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``detail`` ->
                            ``json writer``.WritePropertyName("detail")
                            ``detail``.WriteTo(``json writer``)

                        match ``documentation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentation`` ->
                            ``json writer``.WritePropertyName("documentation")
                            ``documentation``.WriteTo(``json writer``)

                        match ``deprecated`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``deprecated`` ->
                            ``json writer``.WriteBoolean("deprecated", ``deprecated``)

                        match ``preselect`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``preselect`` ->
                            ``json writer``.WriteBoolean("preselect", ``preselect``)

                        match ``sortText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``sortText`` ->
                            ``json writer``.WritePropertyName("sortText")
                            ``sortText``.WriteTo(``json writer``)

                        match ``filterText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``filterText`` ->
                            ``json writer``.WritePropertyName("filterText")
                            ``filterText``.WriteTo(``json writer``)

                        match ``insertText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``insertText`` ->
                            ``json writer``.WritePropertyName("insertText")
                            ``insertText``.WriteTo(``json writer``)

                        match ``insertTextFormat`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``insertTextFormat`` ->
                            ``json writer``.WriteNumber("insertTextFormat", int ``insertTextFormat``)

                        match ``insertTextMode`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``insertTextMode`` ->
                            ``json writer``.WriteNumber("insertTextMode", int ``insertTextMode``)

                        match ``textEdit`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``textEdit`` ->
                            ``json writer``.WritePropertyName("textEdit")
                            ``textEdit``.WriteTo(``json writer``)

                        match ``textEditText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``textEditText`` ->
                            ``json writer``.WritePropertyName("textEditText")
                            ``textEditText``.WriteTo(``json writer``)

                        match ``additionalTextEdits`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``additionalTextEdits`` ->
                            ``json writer``.WritePropertyName("additionalTextEdits")
                            ``additionalTextEdits``.WriteTo(``json writer``)

                        match ``commitCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``commitCharacters`` ->
                            ``json writer``.WritePropertyName("commitCharacters")
                            ``commitCharacters``.WriteTo(``json writer``)

                        match ``command`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``command`` ->
                            ``json writer``.WritePropertyName("command")
                            ``command``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionItem.FromElement(element))

type private ICompletionList =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``isIncomplete``: global.FSharp.Core.bool
    abstract ``itemDefaults``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Represents a collection of {@link CompletionItem completion items} to be presented
/// in the editor.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionList private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionList>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionList(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// This list it not complete. Further typing results in recomputing this list.
    ///
    /// Recomputed lists have all their items replaced (not appended) in the
    /// incomplete completion sessions.
    member _.IsIncomplete =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``isIncomplete``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("isIncomplete")
            prop.GetBoolean()

    /// In many cases the items of an actual completion result share the same
    /// value for properties like `commitCharacters` or the range of a text
    /// edit. A completion list can therefore define item defaults which will
    /// be used if a completion item itself doesn&apos;t specify the value.
    ///
    /// If a completion list specifies a default value and a completion item
    /// also specifies a corresponding value the one from the item is used.
    ///
    /// Servers are only allowed to return default values if the client
    /// signals support for this via the `completionList.itemDefaults`
    /// capability.
    ///
    /// @since 3.17.0
    member _.ItemDefaults =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``itemDefaults`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("itemDefaults") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The completion items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``isIncomplete``: global.FSharp.Core.bool,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``itemDefaults``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        CompletionList(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionList with
                    member _.``isIncomplete`` = ``isIncomplete``
                    member _.``itemDefaults`` = ``itemDefaults``
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteBoolean("isIncomplete", ``isIncomplete``)

                        match ``itemDefaults`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``itemDefaults`` ->
                            ``json writer``.WritePropertyName("itemDefaults")
                            ``itemDefaults``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionList.FromElement(element))

type private ICompletionRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Registration options for a {@link CompletionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Most tools trigger completion request automatically without explicitly requesting
    /// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
    /// starts to type an identifier. For example if the user types `c` in a JavaScript file
    /// code complete will automatically pop up present `console` besides others as a
    /// completion item. Characters that make up identifiers don&apos;t need to be listed here.
    ///
    /// If code complete should automatically be trigger on characters not being valid inside
    /// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The list of all possible characters that commit a completion. This field can be used
    /// if clients don&apos;t support individual commit characters per completion item. See
    /// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
    ///
    /// If a server provides both `allCommitCharacters` and commit characters on an individual
    /// completion item the ones on the completion item win.
    ///
    /// @since 3.2.0
    member _.AllCommitCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``allCommitCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("allCommitCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a completion item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The server supports the following `CompletionItem` specific
    /// capabilities.
    ///
    /// @since 3.17.0
    member _.CompletionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``completionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        CompletionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``triggerCharacters`` = ``triggerCharacters``
                    member _.``allCommitCharacters`` = ``allCommitCharacters``
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``completionItem`` = ``completionItem``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``triggerCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``triggerCharacters`` ->
                            ``json writer``.WritePropertyName("triggerCharacters")
                            ``triggerCharacters``.WriteTo(``json writer``)

                        match ``allCommitCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``allCommitCharacters`` ->
                            ``json writer``.WritePropertyName("allCommitCharacters")
                            ``allCommitCharacters``.WriteTo(``json writer``)

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        match ``completionItem`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``completionItem`` ->
                            ``json writer``.WritePropertyName("completionItem")
                            ``completionItem``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionRegistrationOptions.FromElement(element))

type private IHoverParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option

/// Parameters for a {@link HoverRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IHoverParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        HoverParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IHoverParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(HoverParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IHover =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``contents``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``range``: Range option

/// The result of a hover request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Hover private (backing: global.Amongonz.LspTypes.LspJsonBacking<IHover>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Hover(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The hover&apos;s content
    member _.Contents =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``contents``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("contents")
            LspJsonBacking.Element prop

    /// An optional range inside the text document that is used to
    /// visualize the hover, e.g. by changing the background color.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    static member Create(``contents``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>, ?``range``: Range) =
        Hover(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IHover with
                    member _.``contents`` = ``contents``
                    member _.``range`` = ``range``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("contents")
                        ``contents``.WriteTo(``json writer``)

                        match ``range`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``range`` ->
                            ``json writer``.WritePropertyName("range")
                            ``range``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(Hover.FromElement(element))

type private IHoverRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Registration options for a {@link HoverRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverRegistrationOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IHoverRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        HoverRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IHoverRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(HoverRegistrationOptions.FromElement(element))

type private ISignatureHelpParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``context``: SignatureHelpContext option
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option

/// Parameters for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISignatureHelpParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The signature help context. This is only available if the client specifies
    /// to send this using the client capability `textDocument.signatureHelp.contextSupport === true`
    ///
    /// @since 3.15.0
    member _.Context =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``context`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("context") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelpContext.FromElement(prop))

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``context``: SignatureHelpContext,
            ?``workDoneToken``: ProgressToken
        ) =
        SignatureHelpParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISignatureHelpParams with
                    member _.``context`` = ``context``
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``context`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``context`` ->
                            ``json writer``.WritePropertyName("context")
                            ``context``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SignatureHelpContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SignatureHelpParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISignatureHelp =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``signatures``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``activeSignature``: global.FSharp.Core.int option
    abstract ``activeParameter``: global.FSharp.Core.int option

/// Signature help represents the signature of something
/// callable. There can be multiple signature but only one
/// active and only one active parameter.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelp private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISignatureHelp>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelp(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// One or more signatures.
    member _.Signatures =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``signatures``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("signatures")
            LspJsonBacking.Element prop

    /// The active signature. If omitted or the value lies outside the
    /// range of `signatures` the value defaults to zero or is ignored if
    /// the `SignatureHelp` has no signatures.
    ///
    /// Whenever possible implementors should make an active decision about
    /// the active signature and shouldn&apos;t rely on a default value.
    ///
    /// In future version of the protocol this property might become
    /// mandatory to better express this.
    member _.ActiveSignature =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``activeSignature`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeSignature") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// The active parameter of the active signature. If omitted or the value
    /// lies outside the range of `signatures[activeSignature].parameters`
    /// defaults to 0 if the active signature has parameters. If
    /// the active signature has no parameters it is ignored.
    /// In future version of the protocol this property might become
    /// mandatory to better express the active parameter if the
    /// active signature does have any.
    member _.ActiveParameter =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``activeParameter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeParameter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``signatures``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``activeSignature``: global.FSharp.Core.int,
            ?``activeParameter``: global.FSharp.Core.int
        ) =
        SignatureHelp(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISignatureHelp with
                    member _.``signatures`` = ``signatures``
                    member _.``activeSignature`` = ``activeSignature``
                    member _.``activeParameter`` = ``activeParameter``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("signatures")
                        ``signatures``.WriteTo(``json writer``)

                        match ``activeSignature`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``activeSignature`` ->
                            ``json writer``.WriteNumber("activeSignature", ``activeSignature``)

                        match ``activeParameter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``activeParameter`` ->
                            ``json writer``.WriteNumber("activeParameter", ``activeParameter``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelp.FromElement(element))

type private ISignatureHelpRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Registration options for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISignatureHelpRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// List of characters that trigger signature help automatically.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// List of characters that re-trigger signature help.
    ///
    /// These trigger characters are only active when signature help is already showing. All trigger characters
    /// are also counted as re-trigger characters.
    ///
    /// @since 3.15.0
    member _.RetriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``retriggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("retriggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        SignatureHelpRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISignatureHelpRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``triggerCharacters`` = ``triggerCharacters``
                    member _.``retriggerCharacters`` = ``retriggerCharacters``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``triggerCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``triggerCharacters`` ->
                            ``json writer``.WritePropertyName("triggerCharacters")
                            ``triggerCharacters``.WriteTo(``json writer``)

                        match ``retriggerCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``retriggerCharacters`` ->
                            ``json writer``.WritePropertyName("retriggerCharacters")
                            ``retriggerCharacters``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelpRegistrationOptions.FromElement(element))

type private IDefinitionParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDefinitionParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DefinitionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDefinitionParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DefinitionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDefinitionRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Registration options for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDefinitionRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DefinitionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDefinitionRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DefinitionRegistrationOptions.FromElement(element))

type private IReferenceParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``context``: ReferenceContext
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters for a {@link ReferencesRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IReferenceParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Context =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            ReferenceContext.FromElement(prop)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``context``: ReferenceContext,
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        ReferenceParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IReferenceParams with
                    member _.``context`` = ``context``
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("context")
                        ``context``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ReferenceContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(ReferenceParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IReferenceRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Registration options for a {@link ReferencesRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IReferenceRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        ReferenceRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IReferenceRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ReferenceRegistrationOptions.FromElement(element))

type private IDocumentHighlightParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentHighlightParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentHighlightParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentHighlightParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentHighlightParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentHighlight =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``kind``: DocumentHighlightKind option

/// A document highlight is a range inside a text document which deserves
/// special attention. Usually a document highlight is visualized by changing
/// the background color of its range.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlight private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentHighlight>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlight(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range this highlight applies to.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The highlight kind, default is {@link DocumentHighlightKind.Text text}.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentHighlightKind.FromElement(prop))

    static member Create(``range``: Range, ?``kind``: DocumentHighlightKind) =
        DocumentHighlight(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentHighlight with
                    member _.``range`` = ``range``
                    member _.``kind`` = ``kind``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``kind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``kind`` -> ``json writer``.WriteNumber("kind", int ``kind``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> true)
        then
            global.FSharp.Core.Ok(DocumentHighlight.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentHighlightRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Registration options for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentHighlightRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DocumentHighlightRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentHighlightRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentHighlightRegistrationOptions.FromElement(element))

type private IDocumentSymbolParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// Parameters for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentSymbolParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentSymbolParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentSymbolParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentSymbolParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISymbolInformation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``deprecated``: global.FSharp.Core.bool option
    abstract ``location``: Location
    abstract ``name``: global.Amongonz.LspTypes.LspString
    abstract ``kind``: SymbolKind
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``containerName``: global.Amongonz.LspTypes.LspString option

/// Represents information about programming constructs like variables, classes,
/// interfaces etc.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SymbolInformation private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISymbolInformation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SymbolInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Indicates if this symbol is deprecated.
    ///
    /// @deprecated Use tags instead
    [<global.System.Obsolete("Use tags instead")>]
    member _.Deprecated =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``deprecated`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("deprecated") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The location of this symbol. The location&apos;s range is used by a tool
    /// to reveal the location in the editor. If the symbol is selected in the
    /// tool the range&apos;s start information is used to position the cursor. So
    /// the range usually spans more than the actual symbol&apos;s name and does
    /// normally include things like visibility modifiers.
    ///
    /// The range doesn&apos;t have to denote a node range in the sense of an abstract
    /// syntax tree. It can therefore not be used to re-construct a hierarchy of
    /// the symbols.
    member _.Location =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``location``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("location")
            Location.FromElement(prop)

    /// The name of this symbol.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The name of the symbol containing this symbol. This information is for
    /// user interface purposes (e.g. to render a qualifier in the user interface
    /// if necessary). It can&apos;t be used to re-infer a hierarchy for the document
    /// symbols.
    member _.ContainerName =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``containerName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("containerName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``location``: Location,
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ?``deprecated``: global.FSharp.Core.bool,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``containerName``: global.Amongonz.LspTypes.LspString
        ) =
        SymbolInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISymbolInformation with
                    member _.``deprecated`` = ``deprecated``
                    member _.``location`` = ``location``
                    member _.``name`` = ``name``
                    member _.``kind`` = ``kind``
                    member _.``tags`` = ``tags``
                    member _.``containerName`` = ``containerName``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``deprecated`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``deprecated`` ->
                            ``json writer``.WriteBoolean("deprecated", ``deprecated``)

                        ``json writer``.WritePropertyName("location")
                        ``location``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("name")
                        ``name``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``containerName`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``containerName`` ->
                            ``json writer``.WritePropertyName("containerName")
                            ``containerName``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SymbolInformation.FromElement(element))

type private IDocumentSymbol =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``name``: global.Amongonz.LspTypes.LspString
    abstract ``detail``: global.Amongonz.LspTypes.LspString option
    abstract ``kind``: SymbolKind
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``deprecated``: global.FSharp.Core.bool option
    abstract ``range``: Range
    abstract ``selectionRange``: Range
    abstract ``children``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Represents programming constructs like variables, classes, interfaces etc.
/// that appear in a document. Document symbols can be hierarchical and they
/// have two ranges: one that encloses its definition and one that points to
/// its most interesting range, e.g. the range of an identifier.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbol private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentSymbol>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbol(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this symbol. Will be displayed in the user interface and therefore must not be
    /// an empty string or a string only consisting of white spaces.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// More detail for this symbol, e.g the signature of a function.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this document symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Indicates if this symbol is deprecated.
    ///
    /// @deprecated Use tags instead
    [<global.System.Obsolete("Use tags instead")>]
    member _.Deprecated =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``deprecated`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("deprecated") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The range enclosing this symbol not including leading/trailing whitespace but everything else
    /// like comments. This information is typically used to determine if the clients cursor is
    /// inside the symbol to reveal in the symbol in the UI.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
    /// Must be contained by the `range`.
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``selectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("selectionRange")
            Range.FromElement(prop)

    /// Children of this symbol, e.g. properties of a class.
    member _.Children =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``children`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("children") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ``range``: Range,
            ``selectionRange``: Range,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``deprecated``: global.FSharp.Core.bool,
            ?``children``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        DocumentSymbol(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentSymbol with
                    member _.``name`` = ``name``
                    member _.``detail`` = ``detail``
                    member _.``kind`` = ``kind``
                    member _.``tags`` = ``tags``
                    member _.``deprecated`` = ``deprecated``
                    member _.``range`` = ``range``
                    member _.``selectionRange`` = ``selectionRange``
                    member _.``children`` = ``children``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("name")
                        ``name``.WriteTo(``json writer``)

                        match ``detail`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``detail`` ->
                            ``json writer``.WritePropertyName("detail")
                            ``detail``.WriteTo(``json writer``)

                        ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``deprecated`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``deprecated`` ->
                            ``json writer``.WriteBoolean("deprecated", ``deprecated``)

                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("selectionRange")
                        ``selectionRange``.WriteTo(``json writer``)

                        match ``children`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``children`` ->
                            ``json writer``.WritePropertyName("children")
                            ``children``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentSymbol.FromElement(element))

type private IDocumentSymbolRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``label``: global.Amongonz.LspTypes.LspString option

/// Registration options for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentSymbolRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// A human-readable string that is shown when multiple outlines trees
    /// are shown for the same document.
    ///
    /// @since 3.16.0
    member _.Label =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``label`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("label") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``label``: global.Amongonz.LspTypes.LspString
        ) =
        DocumentSymbolRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentSymbolRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``label`` = ``label``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``label`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``label`` ->
                            ``json writer``.WritePropertyName("label")
                            ``label``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentSymbolRegistrationOptions.FromElement(element))

type private ICodeActionParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``range``: Range
    abstract ``context``: CodeActionContext
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameters of a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeActionParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document in which the command was invoked.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The range for which the command was invoked.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// Context carrying additional information.
    member _.Context =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            CodeActionContext.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ``context``: CodeActionContext,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        CodeActionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeActionParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``range`` = ``range``
                    member _.``context`` = ``context``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("context")
                        ``context``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeActionContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CodeActionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICommand =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``title``: global.Amongonz.LspTypes.LspString
    abstract ``command``: global.Amongonz.LspTypes.LspString
    abstract ``arguments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Represents a reference to a command. Provides a title which
/// will be used to represent a command in the UI and, optionally,
/// an array of arguments which will be passed to the command handler
/// function when invoked.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Command private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICommand>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Command(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Title of the command, like `save`.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The identifier of the actual command handler.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``command``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("command")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Arguments that the command handler should be
    /// invoked with.
    member _.Arguments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``arguments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("arguments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``title``: global.Amongonz.LspTypes.LspString,
            ``command``: global.Amongonz.LspTypes.LspString,
            ?``arguments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        Command(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICommand with
                    member _.``title`` = ``title``
                    member _.``command`` = ``command``
                    member _.``arguments`` = ``arguments``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("title")
                        ``title``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("command")
                        ``command``.WriteTo(``json writer``)

                        match ``arguments`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``arguments`` ->
                            ``json writer``.WritePropertyName("arguments")
                            ``arguments``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(Command.FromElement(element))

type private ICodeAction =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``title``: global.Amongonz.LspTypes.LspString
    abstract ``kind``: CodeActionKind option
    abstract ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``isPreferred``: global.FSharp.Core.bool option
    abstract ``disabled``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``edit``: WorkspaceEdit option
    abstract ``command``: Command option
    abstract ``data``: LSPAny option

/// A code action represents a change that can be performed in code, e.g. to fix a problem or
/// to refactor code.
///
/// A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeAction private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeAction>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeAction(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A short, human-readable, title for this code action.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of the code action.
    ///
    /// Used to filter code actions.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeActionKind.FromElement(prop))

    /// The diagnostics that this code action resolves.
    member _.Diagnostics =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``diagnostics`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnostics") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
    /// by keybindings.
    ///
    /// A quick fix should be marked preferred if it properly addresses the underlying error.
    /// A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
    ///
    /// @since 3.15.0
    member _.IsPreferred =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``isPreferred`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("isPreferred") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Marks that the code action cannot currently be applied.
    ///
    /// Clients should follow the following guidelines regarding disabled code actions:
    ///
    ///   - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
    ///     code action menus.
    ///
    ///   - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
    ///     of code action, such as refactorings.
    ///
    ///   - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
    ///     that auto applies a code action and only disabled code actions are returned, the client should show the user an
    ///     error message with `reason` in the editor.
    ///
    /// @since 3.16.0
    member _.Disabled =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``disabled`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("disabled") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The workspace edit this code action performs.
    member _.Edit =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``edit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("edit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceEdit.FromElement(prop))

    /// A command this code action executes. If a code action
    /// provides an edit and a command, first the edit is
    /// executed and then the command.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    /// A data entry field that is preserved on a code action between
    /// a `textDocument/codeAction` and a `codeAction/resolve` request.
    ///
    /// @since 3.16.0
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``title``: global.Amongonz.LspTypes.LspString,
            ?``kind``: CodeActionKind,
            ?``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``isPreferred``: global.FSharp.Core.bool,
            ?``disabled``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``edit``: WorkspaceEdit,
            ?``command``: Command,
            ?``data``: LSPAny
        ) =
        CodeAction(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeAction with
                    member _.``title`` = ``title``
                    member _.``kind`` = ``kind``
                    member _.``diagnostics`` = ``diagnostics``
                    member _.``isPreferred`` = ``isPreferred``
                    member _.``disabled`` = ``disabled``
                    member _.``edit`` = ``edit``
                    member _.``command`` = ``command``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("title")
                        ``title``.WriteTo(``json writer``)

                        match ``kind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``kind`` ->
                            ``json writer``.WritePropertyName("kind")
                            ``kind``.WriteTo(``json writer``)

                        match ``diagnostics`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``diagnostics`` ->
                            ``json writer``.WritePropertyName("diagnostics")
                            ``diagnostics``.WriteTo(``json writer``)

                        match ``isPreferred`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``isPreferred`` ->
                            ``json writer``.WriteBoolean("isPreferred", ``isPreferred``)

                        match ``disabled`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``disabled`` ->
                            ``json writer``.WritePropertyName("disabled")
                            ``disabled``.WriteTo(``json writer``)

                        match ``edit`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``edit`` ->
                            ``json writer``.WritePropertyName("edit")
                            ``edit``.WriteTo(``json writer``)

                        match ``command`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``command`` ->
                            ``json writer``.WritePropertyName("command")
                            ``command``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeAction.FromElement(element))

type private ICodeActionRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``resolveProvider``: global.FSharp.Core.bool option

/// Registration options for a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeActionRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// CodeActionKinds that this server may return.
    ///
    /// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
    /// may list out every specific kind they provide.
    member _.CodeActionKinds =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeActionKinds`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionKinds") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a code action.
    ///
    /// @since 3.16.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveProvider``: global.FSharp.Core.bool
        ) =
        CodeActionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeActionRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``codeActionKinds`` = ``codeActionKinds``
                    member _.``resolveProvider`` = ``resolveProvider``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``codeActionKinds`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeActionKinds`` ->
                            ``json writer``.WritePropertyName("codeActionKinds")
                            ``codeActionKinds``.WriteTo(``json writer``)

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionRegistrationOptions.FromElement(element))

type private IWorkspaceSymbolParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``query``: global.Amongonz.LspTypes.LspString
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameters of a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceSymbolParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A query string to filter symbols by. Clients may send an empty
    /// string here to request all symbols.
    member _.Query =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``query``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("query")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``query``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        WorkspaceSymbolParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceSymbolParams with
                    member _.``query`` = ``query``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("query")
                        ``query``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "query" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkspaceSymbolParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkspaceSymbol =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``location``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``data``: LSPAny option
    abstract ``name``: global.Amongonz.LspTypes.LspString
    abstract ``kind``: SymbolKind
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``containerName``: global.Amongonz.LspTypes.LspString option

/// A special workspace symbol that supports locations without a range.
///
/// See also SymbolInformation.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbol private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceSymbol>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbol(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The location of the symbol. Whether a server is allowed to
    /// return a location without a range depends on the client
    /// capability `workspace.symbol.resolveSupport`.
    ///
    /// See SymbolInformation#location for more details.
    member _.Location =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``location``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("location")
            LspJsonBacking.Element prop

    /// A data entry field that is preserved on a workspace symbol between a
    /// workspace symbol request and a workspace symbol resolve request.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    /// The name of this symbol.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The name of the symbol containing this symbol. This information is for
    /// user interface purposes (e.g. to render a qualifier in the user interface
    /// if necessary). It can&apos;t be used to re-infer a hierarchy for the document
    /// symbols.
    member _.ContainerName =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``containerName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("containerName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``location``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ?``data``: LSPAny,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``containerName``: global.Amongonz.LspTypes.LspString
        ) =
        WorkspaceSymbol(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceSymbol with
                    member _.``location`` = ``location``
                    member _.``data`` = ``data``
                    member _.``name`` = ``name``
                    member _.``kind`` = ``kind``
                    member _.``tags`` = ``tags``
                    member _.``containerName`` = ``containerName``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("location")
                        ``location``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("name")
                        ``name``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``containerName`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``containerName`` ->
                            ``json writer``.WritePropertyName("containerName")
                            ``containerName``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceSymbol.FromElement(element))

type private IWorkspaceSymbolRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resolveProvider``: global.FSharp.Core.bool option

/// Registration options for a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceSymbolRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for a workspace symbol.
    ///
    /// @since 3.17.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``resolveProvider``: global.FSharp.Core.bool) =
        WorkspaceSymbolRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceSymbolRegistrationOptions with
                    member _.``resolveProvider`` = ``resolveProvider``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(WorkspaceSymbolRegistrationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICodeLensParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameters of a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeLensParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to request code lens for.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        CodeLensParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeLensParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CodeLensParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICodeLens =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``command``: Command option
    abstract ``data``: LSPAny option

/// A code lens represents a {@link Command command} that should be shown along with
/// source text, like the number of references, a way to run tests, etc.
///
/// A code lens is _unresolved_ when no command is associated to it. For performance
/// reasons the creation of a code lens and resolving should be done in two stages.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLens private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeLens>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLens(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range in which this code lens is valid. Should only span a single line.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The command this code lens represents.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    /// A data entry field that is preserved on a code lens item between
    /// a {@link CodeLensRequest} and a {@link CodeLensResolveRequest}
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create(``range``: Range, ?``command``: Command, ?``data``: LSPAny) =
        CodeLens(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeLens with
                    member _.``range`` = ``range``
                    member _.``command`` = ``command``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``command`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``command`` ->
                            ``json writer``.WritePropertyName("command")
                            ``command``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "command" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (Command.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "data" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(CodeLens.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICodeLensRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resolveProvider``: global.FSharp.Core.bool option

/// Registration options for a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeLensRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Code lens has a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveProvider``: global.FSharp.Core.bool
        ) =
        CodeLensRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeLensRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``resolveProvider`` = ``resolveProvider``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeLensRegistrationOptions.FromElement(element))

type private IDocumentLinkParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``workDoneToken``: ProgressToken option
    abstract ``partialResultToken``: ProgressToken option

/// The parameters of a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentLinkParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to provide document links for.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentLinkParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentLinkParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``workDoneToken`` = ``workDoneToken``
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentLinkParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentLink =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``target``: global.System.Uri option
    abstract ``tooltip``: global.Amongonz.LspTypes.LspString option
    abstract ``data``: LSPAny option

/// A document link is a range in a text document that links to an internal or external resource, like another
/// text document or a web site.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLink private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentLink>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLink(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range this link applies to.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The uri this link points to. If missing a resolve request is sent later.
    member _.Target =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``target`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("target") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.System.Uri(prop.GetString()))

    /// The tooltip text when you hover over this link.
    ///
    /// If a tooltip is provided, is will be displayed in a string that includes instructions on how to
    /// trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
    /// user settings, and localization.
    ///
    /// @since 3.15.0
    member _.Tooltip =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tooltip`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltip") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A data entry field that is preserved on a document link between a
    /// DocumentLinkRequest and a DocumentLinkResolveRequest.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``range``: Range,
            ?``target``: global.System.Uri,
            ?``tooltip``: global.Amongonz.LspTypes.LspString,
            ?``data``: LSPAny
        ) =
        DocumentLink(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentLink with
                    member _.``range`` = ``range``
                    member _.``target`` = ``target``
                    member _.``tooltip`` = ``tooltip``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``target`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``target`` ->
                            ``json writer``.WriteString("target", ``target``.OriginalString)

                        match ``tooltip`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tooltip`` ->
                            ``json writer``.WritePropertyName("tooltip")
                            ``tooltip``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "target" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "tooltip" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "data" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentLink.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentLinkRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resolveProvider``: global.FSharp.Core.bool option

/// Registration options for a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentLinkRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Document links have a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveProvider``: global.FSharp.Core.bool
        ) =
        DocumentLinkRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentLinkRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``resolveProvider`` = ``resolveProvider``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentLinkRegistrationOptions.FromElement(element))

type private IDocumentFormattingParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``options``: FormattingOptions
    abstract ``workDoneToken``: ProgressToken option

/// The parameters of a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentFormattingParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The format options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``options``: FormattingOptions, ?``workDoneToken``: ProgressToken) =
        DocumentFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentFormattingParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``options`` = ``options``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("options")
                        ``options``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FormattingOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentFormattingParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentFormattingRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Registration options for a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentFormattingRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        DocumentFormattingRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentFormattingRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentFormattingRegistrationOptions.FromElement(element))

type private IDocumentRangeFormattingParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``range``: Range
    abstract ``options``: FormattingOptions
    abstract ``workDoneToken``: ProgressToken option

/// The parameters of a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentRangeFormattingParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The range to format
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The format options
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ``options``: FormattingOptions,
            ?``workDoneToken``: ProgressToken
        ) =
        DocumentRangeFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentRangeFormattingParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``range`` = ``range``
                    member _.``options`` = ``options``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("options")
                        ``options``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FormattingOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentRangeFormattingParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentRangeFormattingRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``rangesSupport``: global.FSharp.Core.bool option

/// Registration options for a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentRangeFormattingRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Whether the server supports formatting multiple ranges at once.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RangesSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rangesSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangesSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``rangesSupport``: global.FSharp.Core.bool
        ) =
        DocumentRangeFormattingRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentRangeFormattingRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``rangesSupport`` = ``rangesSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``rangesSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rangesSupport`` ->
                            ``json writer``.WriteBoolean("rangesSupport", ``rangesSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentRangeFormattingRegistrationOptions.FromElement(element))

type private IDocumentRangesFormattingParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``ranges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``options``: FormattingOptions
    abstract ``workDoneToken``: ProgressToken option

/// The parameters of a {@link DocumentRangesFormattingRequest}.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangesFormattingParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentRangesFormattingParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangesFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The ranges to format
    member _.Ranges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``ranges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("ranges")
            LspJsonBacking.Element prop

    /// The format options
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``ranges``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``options``: FormattingOptions,
            ?``workDoneToken``: ProgressToken
        ) =
        DocumentRangesFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentRangesFormattingParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``ranges`` = ``ranges``
                    member _.``options`` = ``options``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("ranges")
                        ``ranges``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("options")
                        ``options``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentRangesFormattingParams.FromElement(element))

type private IDocumentOnTypeFormattingParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``ch``: global.Amongonz.LspTypes.LspString
    abstract ``options``: FormattingOptions

/// The parameters of a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentOnTypeFormattingParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position around which the on type formatting should happen.
    /// This is not necessarily the exact position where the character denoted
    /// by the property `ch` got typed.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// The character that has been typed that triggered the formatting
    /// on type request. That is not necessarily the last character that
    /// got inserted into the document since the client could auto insert
    /// characters as well (e.g. like automatic brace completion).
    member _.Ch =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``ch``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("ch")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The formatting options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ``ch``: global.Amongonz.LspTypes.LspString,
            ``options``: FormattingOptions
        ) =
        DocumentOnTypeFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentOnTypeFormattingParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``ch`` = ``ch``
                    member _.``options`` = ``options``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("ch")
                        ``ch``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("options")
                        ``options``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "ch" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FormattingOptions.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentOnTypeFormattingParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentOnTypeFormattingRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString
    abstract ``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Registration options for a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentOnTypeFormattingRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// A character on which formatting should be triggered, like `{`.
    member _.FirstTriggerCharacter =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``firstTriggerCharacter``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("firstTriggerCharacter")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// More trigger characters.
    member _.MoreTriggerCharacter =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``moreTriggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("moreTriggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString,
            ?``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        DocumentOnTypeFormattingRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentOnTypeFormattingRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``firstTriggerCharacter`` = ``firstTriggerCharacter``
                    member _.``moreTriggerCharacter`` = ``moreTriggerCharacter``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("firstTriggerCharacter")
                        ``firstTriggerCharacter``.WriteTo(``json writer``)

                        match ``moreTriggerCharacter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``moreTriggerCharacter`` ->
                            ``json writer``.WritePropertyName("moreTriggerCharacter")
                            ``moreTriggerCharacter``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentOnTypeFormattingRegistrationOptions.FromElement(element))

type private IRenameParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``newName``: global.Amongonz.LspTypes.LspString
    abstract ``workDoneToken``: ProgressToken option

/// The parameters of a {@link RenameRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRenameParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to rename.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position at which this request was sent.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// The new name of the symbol. If the given name is not valid the
    /// request must return a {@link ResponseError} with an
    /// appropriate message set.
    member _.NewName =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``newName``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newName")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ``newName``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken
        ) =
        RenameParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRenameParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``newName`` = ``newName``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("newName")
                        ``newName``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newName" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(RenameParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IRenameRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``prepareProvider``: global.FSharp.Core.bool option

/// Registration options for a {@link RenameRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameRegistrationOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRenameRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Renames should be checked and tested before being executed.
    ///
    /// @since version 3.12.0
    member _.PrepareProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``prepareProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``prepareProvider``: global.FSharp.Core.bool
        ) =
        RenameRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRenameRegistrationOptions with
                    member _.``documentSelector`` = ``documentSelector``
                    member _.``prepareProvider`` = ``prepareProvider``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("documentSelector")
                        ``documentSelector``.WriteTo(``json writer``)

                        match ``prepareProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``prepareProvider`` ->
                            ``json writer``.WriteBoolean("prepareProvider", ``prepareProvider``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RenameRegistrationOptions.FromElement(element))

type private IPrepareRenameParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position
    abstract ``workDoneToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PrepareRenameParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IPrepareRenameParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PrepareRenameParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        PrepareRenameParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IPrepareRenameParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(PrepareRenameParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IExecuteCommandParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``command``: global.Amongonz.LspTypes.LspString
    abstract ``arguments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``workDoneToken``: ProgressToken option

/// The parameters of a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IExecuteCommandParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The identifier of the actual command handler.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``command``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("command")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Arguments that the command should be invoked with.
    member _.Arguments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``arguments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("arguments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``command``: global.Amongonz.LspTypes.LspString,
            ?``arguments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workDoneToken``: ProgressToken
        ) =
        ExecuteCommandParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IExecuteCommandParams with
                    member _.``command`` = ``command``
                    member _.``arguments`` = ``arguments``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("command")
                        ``command``.WriteTo(``json writer``)

                        match ``arguments`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``arguments`` ->
                            ``json writer``.WritePropertyName("arguments")
                            ``arguments``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ExecuteCommandParams.FromElement(element))

type private IExecuteCommandRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``commands``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Registration options for a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IExecuteCommandRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The commands to be executed on the server
    member _.Commands =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``commands``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("commands")
            LspJsonBacking.Element prop

    static member Create(``commands``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        ExecuteCommandRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IExecuteCommandRegistrationOptions with
                    member _.``commands`` = ``commands``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("commands")
                        ``commands``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ExecuteCommandRegistrationOptions.FromElement(element))

type private IApplyWorkspaceEditParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``label``: global.Amongonz.LspTypes.LspString option
    abstract ``edit``: WorkspaceEdit

/// The parameters passed via an apply workspace edit request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ApplyWorkspaceEditParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IApplyWorkspaceEditParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ApplyWorkspaceEditParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional label of the workspace edit. This label is
    /// presented in the user interface for example on an undo
    /// stack to undo the workspace edit.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``label`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("label") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The edits to apply.
    member _.Edit =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``edit``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edit")
            WorkspaceEdit.FromElement(prop)

    static member Create(``edit``: WorkspaceEdit, ?``label``: global.Amongonz.LspTypes.LspString) =
        ApplyWorkspaceEditParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IApplyWorkspaceEditParams with
                    member _.``label`` = ``label``
                    member _.``edit`` = ``edit``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``label`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``label`` ->
                            ``json writer``.WritePropertyName("label")
                            ``label``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("edit")
                        ``edit``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "label" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "edit" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceEdit.Parse(prop)))
        then
            global.FSharp.Core.Ok(ApplyWorkspaceEditParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IApplyWorkspaceEditResult =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``applied``: global.FSharp.Core.bool
    abstract ``failureReason``: global.Amongonz.LspTypes.LspString option
    abstract ``failedChange``: global.FSharp.Core.int option

/// The result returned from the apply workspace edit request.
///
/// @since 3.17 renamed from ApplyWorkspaceEditResponse
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ApplyWorkspaceEditResult private (backing: global.Amongonz.LspTypes.LspJsonBacking<IApplyWorkspaceEditResult>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ApplyWorkspaceEditResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Indicates whether the edit was applied or not.
    member _.Applied =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``applied``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("applied")
            prop.GetBoolean()

    /// An optional textual description for why the edit was not applied.
    /// This may be used by the server for diagnostic logging or to provide
    /// a suitable error for a request that triggered the edit.
    member _.FailureReason =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``failureReason`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("failureReason") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Depending on the client&apos;s failure handling strategy `failedChange` might
    /// contain the index of the change that failed. This property is only available
    /// if the client signals a `failureHandlingStrategy` in its client capabilities.
    member _.FailedChange =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``failedChange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("failedChange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``applied``: global.FSharp.Core.bool,
            ?``failureReason``: global.Amongonz.LspTypes.LspString,
            ?``failedChange``: global.FSharp.Core.int
        ) =
        ApplyWorkspaceEditResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IApplyWorkspaceEditResult with
                    member _.``applied`` = ``applied``
                    member _.``failureReason`` = ``failureReason``
                    member _.``failedChange`` = ``failedChange``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteBoolean("applied", ``applied``)

                        match ``failureReason`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``failureReason`` ->
                            ``json writer``.WritePropertyName("failureReason")
                            ``failureReason``.WriteTo(``json writer``)

                        match ``failedChange`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``failedChange`` ->
                            ``json writer``.WriteNumber("failedChange", ``failedChange``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "applied" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "failureReason" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "failedChange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
        then
            global.FSharp.Core.Ok(ApplyWorkspaceEditResult.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkDoneProgressBegin =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``title``: global.Amongonz.LspTypes.LspString
    abstract ``cancellable``: global.FSharp.Core.bool option
    abstract ``message``: global.Amongonz.LspTypes.LspString option
    abstract ``percentage``: global.FSharp.Core.int option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressBegin private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkDoneProgressBegin>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressBegin(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// Mandatory title of the progress operation. Used to briefly inform about
    /// the kind of operation being performed.
    ///
    /// Examples: &quot;Indexing&quot; or &quot;Linking dependencies&quot;.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Controls if a cancel button should show to allow the user to cancel the
    /// long running operation. Clients that don&apos;t support cancellation are allowed
    /// to ignore the setting.
    member _.Cancellable =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``cancellable`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cancellable") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Optional, more detailed associated progress message. Contains
    /// complementary information to the `title`.
    ///
    /// Examples: &quot;3/25 files&quot;, &quot;project/src/module2&quot;, &quot;node_modules/some_dep&quot;.
    /// If unset, the previous progress message (if any) is still valid.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``message`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("message") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Optional progress percentage to display (value 100 is considered 100%).
    /// If not provided infinite progress is assumed and clients are allowed
    /// to ignore the `percentage` value in subsequent in report notifications.
    ///
    /// The value should be steadily rising. Clients are free to ignore values
    /// that are not following this rule. The value range is [0, 100].
    member _.Percentage =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``percentage`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("percentage") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``title``: global.Amongonz.LspTypes.LspString,
            ?``cancellable``: global.FSharp.Core.bool,
            ?``message``: global.Amongonz.LspTypes.LspString,
            ?``percentage``: global.FSharp.Core.int
        ) =
        WorkDoneProgressBegin(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkDoneProgressBegin with
                    member _.``kind`` = ``kind``
                    member _.``title`` = ``title``
                    member _.``cancellable`` = ``cancellable``
                    member _.``message`` = ``message``
                    member _.``percentage`` = ``percentage``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("title")
                        ``title``.WriteTo(``json writer``)

                        match ``cancellable`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``cancellable`` ->
                            ``json writer``.WriteBoolean("cancellable", ``cancellable``)

                        match ``message`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``message`` ->
                            ``json writer``.WritePropertyName("message")
                            ``message``.WriteTo(``json writer``)

                        match ``percentage`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``percentage`` ->
                            ``json writer``.WriteNumber("percentage", ``percentage``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkDoneProgressBegin.FromElement(element))

type private IWorkDoneProgressReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``cancellable``: global.FSharp.Core.bool option
    abstract ``message``: global.Amongonz.LspTypes.LspString option
    abstract ``percentage``: global.FSharp.Core.int option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressReport private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkDoneProgressReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// Controls enablement state of a cancel button.
    ///
    /// Clients that don&apos;t support cancellation or don&apos;t support controlling the button&apos;s
    /// enablement state are allowed to ignore the property.
    member _.Cancellable =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``cancellable`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cancellable") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Optional, more detailed associated progress message. Contains
    /// complementary information to the `title`.
    ///
    /// Examples: &quot;3/25 files&quot;, &quot;project/src/module2&quot;, &quot;node_modules/some_dep&quot;.
    /// If unset, the previous progress message (if any) is still valid.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``message`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("message") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Optional progress percentage to display (value 100 is considered 100%).
    /// If not provided infinite progress is assumed and clients are allowed
    /// to ignore the `percentage` value in subsequent in report notifications.
    ///
    /// The value should be steadily rising. Clients are free to ignore values
    /// that are not following this rule. The value range is [0, 100]
    member _.Percentage =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``percentage`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("percentage") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``cancellable``: global.FSharp.Core.bool,
            ?``message``: global.Amongonz.LspTypes.LspString,
            ?``percentage``: global.FSharp.Core.int
        ) =
        WorkDoneProgressReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkDoneProgressReport with
                    member _.``kind`` = ``kind``
                    member _.``cancellable`` = ``cancellable``
                    member _.``message`` = ``message``
                    member _.``percentage`` = ``percentage``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)

                        match ``cancellable`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``cancellable`` ->
                            ``json writer``.WriteBoolean("cancellable", ``cancellable``)

                        match ``message`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``message`` ->
                            ``json writer``.WritePropertyName("message")
                            ``message``.WriteTo(``json writer``)

                        match ``percentage`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``percentage`` ->
                            ``json writer``.WriteNumber("percentage", ``percentage``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkDoneProgressReport.FromElement(element))

type private IWorkDoneProgressEnd =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``message``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressEnd private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkDoneProgressEnd>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressEnd(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// Optional, a final message indicating to for example indicate the outcome
    /// of the operation.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``message`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("message") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``message``: global.Amongonz.LspTypes.LspString
        ) =
        WorkDoneProgressEnd(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkDoneProgressEnd with
                    member _.``kind`` = ``kind``
                    member _.``message`` = ``message``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)

                        match ``message`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``message`` ->
                            ``json writer``.WritePropertyName("message")
                            ``message``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkDoneProgressEnd.FromElement(element))

type private ISetTraceParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``value``: TraceValues

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SetTraceParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISetTraceParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SetTraceParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Value =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            TraceValues.FromElement(prop)

    static member Create(``value``: TraceValues) =
        SetTraceParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISetTraceParams with
                    member _.``value`` = ``value``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("value")
                        ``value``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TraceValues.Parse(prop)))
        then
            global.FSharp.Core.Ok(SetTraceParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ILogTraceParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``message``: global.Amongonz.LspTypes.LspString
    abstract ``verbose``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LogTraceParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILogTraceParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LogTraceParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    member _.Verbose =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``verbose`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("verbose") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``message``: global.Amongonz.LspTypes.LspString, ?``verbose``: global.Amongonz.LspTypes.LspString)
        =
        LogTraceParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILogTraceParams with
                    member _.``message`` = ``message``
                    member _.``verbose`` = ``verbose``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("message")
                        ``message``.WriteTo(``json writer``)

                        match ``verbose`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``verbose`` ->
                            ``json writer``.WritePropertyName("verbose")
                            ``verbose``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "verbose" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(LogTraceParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICancelParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``id``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CancelParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICancelParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CancelParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The request id to cancel.
    member _.Id =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``id``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("id")
            LspJsonBacking.Element prop

    static member Create(``id``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        CancelParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICancelParams with
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("id")
                        ``id``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CancelParams.FromElement(element))

type private IProgressParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``token``: ProgressToken
    abstract ``value``: LSPAny

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ProgressParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IProgressParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ProgressParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The progress token provided by the client or server.
    member _.Token =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``token``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("token")
            ProgressToken.FromElement(prop)

    /// The progress data.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            LSPAny.FromElement(prop)

    static member Create(``token``: ProgressToken, ``value``: LSPAny) =
        ProgressParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IProgressParams with
                    member _.``token`` = ``token``
                    member _.``value`` = ``value``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("token")
                        ``token``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("value")
                        ``value``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "token" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(ProgressParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentPositionParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: TextDocumentIdentifier
    abstract ``position``: Position

/// A parameter literal used in requests to pass a text document and a position inside that
/// document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentPositionParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentPositionParams>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentPositionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    static member Create(``textDocument``: TextDocumentIdentifier, ``position``: Position) =
        TextDocumentPositionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentPositionParams with
                    member _.``textDocument`` = ``textDocument``
                    member _.``position`` = ``position``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("position")
                        ``position``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextDocumentPositionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkDoneProgressParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkDoneProgressParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create(?``workDoneToken``: ProgressToken) =
        WorkDoneProgressParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkDoneProgressParams with
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkDoneProgressParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IPartialResultParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``partialResultToken``: ProgressToken option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PartialResultParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<IPartialResultParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PartialResultParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create(?``partialResultToken``: ProgressToken) =
        PartialResultParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IPartialResultParams with
                    member _.``partialResultToken`` = ``partialResultToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``partialResultToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``partialResultToken`` ->
                            ``json writer``.WritePropertyName("partialResultToken")
                            ``partialResultToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(PartialResultParams.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ILocationLink =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``originSelectionRange``: Range option
    abstract ``targetUri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``targetRange``: Range
    abstract ``targetSelectionRange``: Range

/// Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
/// including an origin range.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LocationLink private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILocationLink>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LocationLink(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Span of the origin of this link.
    ///
    /// Used as the underlined span for mouse interaction. Defaults to the word range at
    /// the definition position.
    member _.OriginSelectionRange =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``originSelectionRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("originSelectionRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    /// The target resource identifier of this link.
    member _.TargetUri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``targetUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("targetUri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The full target range of this link. If the target for example is a symbol then target range is the
    /// range enclosing this symbol not including leading/trailing whitespace but everything else
    /// like comments. This information is typically used to highlight the range in the editor.
    member _.TargetRange =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``targetRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("targetRange")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this link is being followed, e.g the name of a function.
    /// Must be contained by the `targetRange`. See also `DocumentSymbol#range`
    member _.TargetSelectionRange =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``targetSelectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("targetSelectionRange")
            Range.FromElement(prop)

    static member Create
        (
            ``targetUri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``targetRange``: Range,
            ``targetSelectionRange``: Range,
            ?``originSelectionRange``: Range
        ) =
        LocationLink(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILocationLink with
                    member _.``originSelectionRange`` = ``originSelectionRange``
                    member _.``targetUri`` = ``targetUri``
                    member _.``targetRange`` = ``targetRange``
                    member _.``targetSelectionRange`` = ``targetSelectionRange``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``originSelectionRange`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``originSelectionRange`` ->
                            ``json writer``.WritePropertyName("originSelectionRange")
                            ``originSelectionRange``.WriteTo(``json writer``)

                        ``json writer``.WriteString("targetUri", ``targetUri``.OriginalString)
                        ``json writer``.WritePropertyName("targetRange")
                        ``targetRange``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("targetSelectionRange")
                        ``targetSelectionRange``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "originSelectionRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "targetUri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "targetRange" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "targetSelectionRange" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(LocationLink.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IRange =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``start``: Position
    abstract ``end``: Position

/// A range in a text document expressed as (zero-based) start and end positions.
///
/// If you want to specify a range that contains a line including the line ending
/// character(s) then use an end position denoting the start of the next line.
/// For example:
/// ```ts
/// {
///     start: { line: 5, character: 23 }
///     end : { line 6, character : 0 }
/// }
/// ```
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Range private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRange>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Range(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range&apos;s start position.
    member _.Start =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``start``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("start")
            Position.FromElement(prop)

    /// The range&apos;s end position.
    member _.End =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``end``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("end")
            Position.FromElement(prop)

    static member Create(``start``: Position, ``end``: Position) =
        Range(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRange with
                    member _.``start`` = ``start``
                    member _.``end`` = ``end``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("start")
                        ``start``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("end")
                        ``end``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "start" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "end" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
        then
            global.FSharp.Core.Ok(Range.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IImplementationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IImplementationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        ImplementationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IImplementationOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ImplementationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IStaticRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Static registration options to be returned in the initialize
/// request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type StaticRegistrationOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IStaticRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        StaticRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(?``id``: global.Amongonz.LspTypes.LspString) =
        StaticRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IStaticRegistrationOptions with
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "id" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(StaticRegistrationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITypeDefinitionOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeDefinitionOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        TypeDefinitionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeDefinitionOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeDefinitionOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkspaceFoldersChangeEvent =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``added``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``removed``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// The workspace folder change event.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFoldersChangeEvent
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceFoldersChangeEvent>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFoldersChangeEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The array of added workspace folders
    member _.Added =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``added``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("added")
            LspJsonBacking.Element prop

    /// The array of the removed workspace folders
    member _.Removed =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``removed``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("removed")
            LspJsonBacking.Element prop

    static member Create
        (
            ``added``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``removed``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        WorkspaceFoldersChangeEvent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceFoldersChangeEvent with
                    member _.``added`` = ``added``
                    member _.``removed`` = ``removed``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("added")
                        ``added``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("removed")
                        ``removed``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFoldersChangeEvent.FromElement(element))

type private IConfigurationItem =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``scopeUri``: global.System.Uri option
    abstract ``section``: global.Amongonz.LspTypes.LspString option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ConfigurationItem private (backing: global.Amongonz.LspTypes.LspJsonBacking<IConfigurationItem>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ConfigurationItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The scope to get the configuration section for.
    member _.ScopeUri =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``scopeUri`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("scopeUri") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.System.Uri(prop.GetString()))

    /// The configuration section asked for.
    member _.Section =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``section`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("section") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(?``scopeUri``: global.System.Uri, ?``section``: global.Amongonz.LspTypes.LspString) =
        ConfigurationItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IConfigurationItem with
                    member _.``scopeUri`` = ``scopeUri``
                    member _.``section`` = ``section``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``scopeUri`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``scopeUri`` ->
                            ``json writer``.WriteString("scopeUri", ``scopeUri``.OriginalString)

                        match ``section`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``section`` ->
                            ``json writer``.WritePropertyName("section")
                            ``section``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "scopeUri" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "section" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ConfigurationItem.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentIdentifier =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri

/// A literal to identify a text document in the client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentIdentifier private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentIdentifier>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    static member Create(``uri``: global.Amongonz.LspTypes.LspDocumentUri) =
        TextDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentIdentifier with
                    member _.``uri`` = ``uri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(TextDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IColor =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``red``: global.FSharp.Core.double
    abstract ``green``: global.FSharp.Core.double
    abstract ``blue``: global.FSharp.Core.double
    abstract ``alpha``: global.FSharp.Core.double

/// Represents a color in RGBA space.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Color private (backing: global.Amongonz.LspTypes.LspJsonBacking<IColor>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Color(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The red component of this color in the range [0-1].
    member _.Red =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``red``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("red")
            prop.GetDouble()

    /// The green component of this color in the range [0-1].
    member _.Green =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``green``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("green")
            prop.GetDouble()

    /// The blue component of this color in the range [0-1].
    member _.Blue =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``blue``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("blue")
            prop.GetDouble()

    /// The alpha component of this color in the range [0-1].
    member _.Alpha =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``alpha``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("alpha")
            prop.GetDouble()

    static member Create
        (
            ``red``: global.FSharp.Core.double,
            ``green``: global.FSharp.Core.double,
            ``blue``: global.FSharp.Core.double,
            ``alpha``: global.FSharp.Core.double
        ) =
        Color(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IColor with
                    member _.``red`` = ``red``
                    member _.``green`` = ``green``
                    member _.``blue`` = ``blue``
                    member _.``alpha`` = ``alpha``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("red", ``red``)
                        ``json writer``.WriteNumber("green", ``green``)
                        ``json writer``.WriteNumber("blue", ``blue``)
                        ``json writer``.WriteNumber("alpha", ``alpha``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "red" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "green" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "blue" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "alpha" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
        then
            global.FSharp.Core.Ok(Color.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentColorOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentColorOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentColorOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentColorOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentColorOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFoldingRangeOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFoldingRangeOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        FoldingRangeOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFoldingRangeOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FoldingRangeOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDeclarationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDeclarationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DeclarationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDeclarationOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DeclarationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IPosition =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``line``: global.FSharp.Core.int
    abstract ``character``: global.FSharp.Core.int

/// Position in a text document expressed as zero-based line and character
/// offset. Prior to 3.17 the offsets were always based on a UTF-16 string
/// representation. So a string of the form `a𐐀b` the character offset of the
/// character `a` is 0, the character offset of `𐐀` is 1 and the character
/// offset of b is 3 since `𐐀` is represented using two code units in UTF-16.
/// Since 3.17 clients and servers can agree on a different string encoding
/// representation (e.g. UTF-8). The client announces it&apos;s supported encoding
/// via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
/// The value is an array of position encodings the client supports, with
/// decreasing preference (e.g. the encoding at index `0` is the most preferred
/// one). To stay backwards compatible the only mandatory encoding is UTF-16
/// represented via the string `utf-16`. The server can pick one of the
/// encodings offered by the client and signals that encoding back to the
/// client via the initialize result&apos;s property
/// [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
/// `utf-16` is missing from the client&apos;s capability `general.positionEncodings`
/// servers can safely assume that the client supports UTF-16. If the server
/// omits the position encoding in its initialize result the encoding defaults
/// to the string value `utf-16`. Implementation considerations: since the
/// conversion from one encoding into another requires the content of the
/// file / line the conversion is best done where the file is read which is
/// usually on the server side.
///
/// Positions are line end character agnostic. So you can not specify a position
/// that denotes `\r|\n` or `\n|` where `|` represents the character offset.
///
/// @since 3.17.0 - support for negotiated position encoding.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Position private (backing: global.Amongonz.LspTypes.LspJsonBacking<IPosition>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Position(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Line position in a document (zero-based).
    ///
    /// If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
    /// If a line number is negative, it defaults to 0.
    member _.Line =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``line``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("line")
            prop.GetInt32()

    /// Character offset on a line in a document (zero-based).
    ///
    /// The meaning of this offset is determined by the negotiated
    /// `PositionEncodingKind`.
    ///
    /// If the character value is greater than the line length it defaults back to the
    /// line length.
    member _.Character =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``character``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("character")
            prop.GetInt32()

    static member Create(``line``: global.FSharp.Core.int, ``character``: global.FSharp.Core.int) =
        Position(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IPosition with
                    member _.``line`` = ``line``
                    member _.``character`` = ``character``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("line", ``line``)
                        ``json writer``.WriteNumber("character", ``character``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "line" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "character" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
        then
            global.FSharp.Core.Ok(Position.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISelectionRangeOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISelectionRangeOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        SelectionRangeOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISelectionRangeOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SelectionRangeOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICallHierarchyOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Call hierarchy options used during static registration.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        CallHierarchyOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CallHierarchyOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISemanticTokensOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``legend``: SemanticTokensLegend
    abstract ``range``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``full``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The legend used by the server
    member _.Legend =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``legend``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("legend")
            SemanticTokensLegend.FromElement(prop)

    /// Server supports providing semantic tokens for a specific range
    /// of a document.
    member _.Range =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Server supports providing semantic tokens for a full document.
    member _.Full =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``full`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("full") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``legend``: SemanticTokensLegend,
            ?``range``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``full``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        SemanticTokensOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensOptions with
                    member _.``legend`` = ``legend``
                    member _.``range`` = ``range``
                    member _.``full`` = ``full``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("legend")
                        ``legend``.WriteTo(``json writer``)

                        match ``range`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``range`` ->
                            ``json writer``.WritePropertyName("range")
                            ``range``.WriteTo(``json writer``)

                        match ``full`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``full`` ->
                            ``json writer``.WritePropertyName("full")
                            ``full``.WriteTo(``json writer``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensOptions.FromElement(element))

type private ISemanticTokensEdit =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``start``: global.FSharp.Core.int
    abstract ``deleteCount``: global.FSharp.Core.int
    abstract ``data``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensEdit private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensEdit>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The start offset of the edit.
    member _.Start =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``start``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("start")
            prop.GetInt32()

    /// The count of elements to remove.
    member _.DeleteCount =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``deleteCount``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("deleteCount")
            prop.GetInt32()

    /// The elements to insert.
    member _.Data =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``start``: global.FSharp.Core.int,
            ``deleteCount``: global.FSharp.Core.int,
            ?``data``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        SemanticTokensEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensEdit with
                    member _.``start`` = ``start``
                    member _.``deleteCount`` = ``deleteCount``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("start", ``start``)
                        ``json writer``.WriteNumber("deleteCount", ``deleteCount``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensEdit.FromElement(element))

type private ILinkedEditingRangeOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILinkedEditingRangeOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        LinkedEditingRangeOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILinkedEditingRangeOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(LinkedEditingRangeOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileCreate =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspString

/// Represents information on a file/folder create.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileCreate private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileCreate>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileCreate(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A file:// URI for the location of the file/folder being created.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspString) =
        FileCreate(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileCreate with
                    member _.``uri`` = ``uri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("uri")
                        ``uri``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileCreate.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentEdit =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``textDocument``: OptionalVersionedTextDocumentIdentifier
    abstract ``edits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// Describes textual changes on a text document. A TextDocumentEdit describes all changes
/// on a document version Si and after they are applied move the document to version Si+1.
/// So the creator of a TextDocumentEdit doesn&apos;t need to sort the array of edits or do any
/// kind of ordering. However the edits must be non overlapping.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentEdit private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentEdit>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document to change.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            OptionalVersionedTextDocumentIdentifier.FromElement(prop)

    /// The edits to be applied.
    ///
    /// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
    /// client capability.
    member _.Edits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``edits``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edits")
            LspJsonBacking.Element prop

    static member Create
        (
            ``textDocument``: OptionalVersionedTextDocumentIdentifier,
            ``edits``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        TextDocumentEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentEdit with
                    member _.``textDocument`` = ``textDocument``
                    member _.``edits`` = ``edits``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("textDocument")
                        ``textDocument``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("edits")
                        ``edits``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentEdit.FromElement(element))

type private ICreateFile =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``options``: CreateFileOptions option
    abstract ``annotationId``: ChangeAnnotationIdentifier option

/// Create file operation.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CreateFile private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICreateFile>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CreateFile(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A create
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The resource to create.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Additional options
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CreateFileOptions.FromElement(prop))

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``options``: CreateFileOptions,
            ?``annotationId``: ChangeAnnotationIdentifier
        ) =
        CreateFile(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICreateFile with
                    member _.``kind`` = ``kind``
                    member _.``uri`` = ``uri``
                    member _.``options`` = ``options``
                    member _.``annotationId`` = ``annotationId``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)

                        match ``options`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``options`` ->
                            ``json writer``.WritePropertyName("options")
                            ``options``.WriteTo(``json writer``)

                        match ``annotationId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``annotationId`` ->
                            ``json writer``.WritePropertyName("annotationId")
                            ``annotationId``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CreateFile.FromElement(element))

type private IRenameFile =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``oldUri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``newUri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``options``: RenameFileOptions option
    abstract ``annotationId``: ChangeAnnotationIdentifier option

/// Rename file operation
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameFile private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRenameFile>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameFile(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A rename
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The old (existing) location.
    member _.OldUri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``oldUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("oldUri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The new location.
    member _.NewUri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``newUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newUri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Rename options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(RenameFileOptions.FromElement(prop))

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``oldUri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``newUri``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``options``: RenameFileOptions,
            ?``annotationId``: ChangeAnnotationIdentifier
        ) =
        RenameFile(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRenameFile with
                    member _.``kind`` = ``kind``
                    member _.``oldUri`` = ``oldUri``
                    member _.``newUri`` = ``newUri``
                    member _.``options`` = ``options``
                    member _.``annotationId`` = ``annotationId``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WriteString("oldUri", ``oldUri``.OriginalString)
                        ``json writer``.WriteString("newUri", ``newUri``.OriginalString)

                        match ``options`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``options`` ->
                            ``json writer``.WritePropertyName("options")
                            ``options``.WriteTo(``json writer``)

                        match ``annotationId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``annotationId`` ->
                            ``json writer``.WritePropertyName("annotationId")
                            ``annotationId``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RenameFile.FromElement(element))

type private IDeleteFile =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``options``: DeleteFileOptions option
    abstract ``annotationId``: ChangeAnnotationIdentifier option

/// Delete file operation
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeleteFile private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDeleteFile>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeleteFile(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A delete
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The file to delete.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Delete options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DeleteFileOptions.FromElement(prop))

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``options``: DeleteFileOptions,
            ?``annotationId``: ChangeAnnotationIdentifier
        ) =
        DeleteFile(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDeleteFile with
                    member _.``kind`` = ``kind``
                    member _.``uri`` = ``uri``
                    member _.``options`` = ``options``
                    member _.``annotationId`` = ``annotationId``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)

                        match ``options`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``options`` ->
                            ``json writer``.WritePropertyName("options")
                            ``options``.WriteTo(``json writer``)

                        match ``annotationId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``annotationId`` ->
                            ``json writer``.WritePropertyName("annotationId")
                            ``annotationId``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DeleteFile.FromElement(element))

type private IChangeAnnotation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``label``: global.Amongonz.LspTypes.LspString
    abstract ``needsConfirmation``: global.FSharp.Core.bool option
    abstract ``description``: global.Amongonz.LspTypes.LspString option

/// Additional information that describes document changes.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ChangeAnnotation private (backing: global.Amongonz.LspTypes.LspJsonBacking<IChangeAnnotation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ChangeAnnotation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A human-readable string describing the actual change. The string
    /// is rendered prominent in the user interface.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// A flag which indicates that user confirmation is needed
    /// before applying the change.
    member _.NeedsConfirmation =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``needsConfirmation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("needsConfirmation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A human-readable string which is rendered less prominent in
    /// the user interface.
    member _.Description =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``description`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("description") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``needsConfirmation``: global.FSharp.Core.bool,
            ?``description``: global.Amongonz.LspTypes.LspString
        ) =
        ChangeAnnotation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IChangeAnnotation with
                    member _.``label`` = ``label``
                    member _.``needsConfirmation`` = ``needsConfirmation``
                    member _.``description`` = ``description``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("label")
                        ``label``.WriteTo(``json writer``)

                        match ``needsConfirmation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``needsConfirmation`` ->
                            ``json writer``.WriteBoolean("needsConfirmation", ``needsConfirmation``)

                        match ``description`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``description`` ->
                            ``json writer``.WritePropertyName("description")
                            ``description``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "label" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "needsConfirmation" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "description" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ChangeAnnotation.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileOperationFilter =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``scheme``: global.Amongonz.LspTypes.LspString option
    abstract ``pattern``: FileOperationPattern

/// A filter to describe in which file operation requests or notifications
/// the server is interested in receiving.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationFilter private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileOperationFilter>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A Uri scheme like `file` or `untitled`.
    member _.Scheme =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``scheme`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("scheme") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual file operation pattern.
    member _.Pattern =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``pattern``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("pattern")
            FileOperationPattern.FromElement(prop)

    static member Create(``pattern``: FileOperationPattern, ?``scheme``: global.Amongonz.LspTypes.LspString) =
        FileOperationFilter(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileOperationFilter with
                    member _.``scheme`` = ``scheme``
                    member _.``pattern`` = ``pattern``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``scheme`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``scheme`` ->
                            ``json writer``.WritePropertyName("scheme")
                            ``scheme``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("pattern")
                        ``pattern``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "scheme" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "pattern" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationPattern.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileOperationFilter.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileRename =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``oldUri``: global.Amongonz.LspTypes.LspString
    abstract ``newUri``: global.Amongonz.LspTypes.LspString

/// Represents information on a file/folder rename.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileRename private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileRename>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileRename(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A file:// URI for the original location of the file/folder being renamed.
    member _.OldUri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``oldUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("oldUri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// A file:// URI for the new location of the file/folder being renamed.
    member _.NewUri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``newUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newUri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``oldUri``: global.Amongonz.LspTypes.LspString, ``newUri``: global.Amongonz.LspTypes.LspString)
        =
        FileRename(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileRename with
                    member _.``oldUri`` = ``oldUri``
                    member _.``newUri`` = ``newUri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("oldUri")
                        ``oldUri``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("newUri")
                        ``newUri``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "oldUri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newUri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileRename.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileDelete =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspString

/// Represents information on a file/folder delete.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileDelete private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileDelete>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileDelete(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A file:// URI for the location of the file/folder being deleted.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspString) =
        FileDelete(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileDelete with
                    member _.``uri`` = ``uri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("uri")
                        ``uri``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileDelete.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IMonikerOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMonikerOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        MonikerOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMonikerOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(MonikerOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITypeHierarchyOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Type hierarchy options used during static registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeHierarchyOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        TypeHierarchyOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeHierarchyOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeHierarchyOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueContext =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``frameId``: global.FSharp.Core.int
    abstract ``stoppedLocation``: Range

/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueContext private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueContext>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The stack frame (as a DAP Id) where the execution has stopped.
    member _.FrameId =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``frameId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("frameId")
            prop.GetInt32()

    /// The document range where execution has stopped.
    /// Typically the end position of the range denotes the line where the inline values are shown.
    member _.StoppedLocation =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``stoppedLocation``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("stoppedLocation")
            Range.FromElement(prop)

    static member Create(``frameId``: global.FSharp.Core.int, ``stoppedLocation``: Range) =
        InlineValueContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueContext with
                    member _.``frameId`` = ``frameId``
                    member _.``stoppedLocation`` = ``stoppedLocation``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("frameId", ``frameId``)
                        ``json writer``.WritePropertyName("stoppedLocation")
                        ``stoppedLocation``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "frameId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "stoppedLocation" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueContext.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueText =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``text``: global.Amongonz.LspTypes.LspString

/// Provide inline value as text.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueText private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueText>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueText(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document range for which the inline value applies.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The text of the inline value.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``text``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("text")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``range``: Range, ``text``: global.Amongonz.LspTypes.LspString) =
        InlineValueText(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueText with
                    member _.``range`` = ``range``
                    member _.``text`` = ``text``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("text")
                        ``text``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueText.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueVariableLookup =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``variableName``: global.Amongonz.LspTypes.LspString option
    abstract ``caseSensitiveLookup``: global.FSharp.Core.bool

/// Provide inline value through a variable lookup.
/// If only a range is specified, the variable name will be extracted from the underlying document.
/// An optional variable name can be used to override the extracted name.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueVariableLookup private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueVariableLookup>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueVariableLookup(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document range for which the inline value applies.
    /// The range is used to extract the variable name from the underlying document.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// If specified the name of the variable to look up.
    member _.VariableName =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``variableName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("variableName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// How to perform the lookup.
    member _.CaseSensitiveLookup =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``caseSensitiveLookup``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("caseSensitiveLookup")
            prop.GetBoolean()

    static member Create
        (
            ``range``: Range,
            ``caseSensitiveLookup``: global.FSharp.Core.bool,
            ?``variableName``: global.Amongonz.LspTypes.LspString
        ) =
        InlineValueVariableLookup(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueVariableLookup with
                    member _.``range`` = ``range``
                    member _.``variableName`` = ``variableName``
                    member _.``caseSensitiveLookup`` = ``caseSensitiveLookup``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``variableName`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``variableName`` ->
                            ``json writer``.WritePropertyName("variableName")
                            ``variableName``.WriteTo(``json writer``)

                        ``json writer``.WriteBoolean("caseSensitiveLookup", ``caseSensitiveLookup``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "variableName" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "caseSensitiveLookup" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueVariableLookup.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueEvaluatableExpression =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``expression``: global.Amongonz.LspTypes.LspString option

/// Provide an inline value through an expression evaluation.
/// If only a range is specified, the expression will be extracted from the underlying document.
/// An optional expression can be used to override the extracted expression.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueEvaluatableExpression
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueEvaluatableExpression>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueEvaluatableExpression(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document range for which the inline value applies.
    /// The range is used to extract the evaluatable expression from the underlying document.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// If specified the expression overrides the extracted expression.
    member _.Expression =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``expression`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("expression") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(``range``: Range, ?``expression``: global.Amongonz.LspTypes.LspString) =
        InlineValueEvaluatableExpression(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueEvaluatableExpression with
                    member _.``range`` = ``range``
                    member _.``expression`` = ``expression``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``expression`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``expression`` ->
                            ``json writer``.WritePropertyName("expression")
                            ``expression``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "expression" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueEvaluatableExpression.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Inline value options used during static registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        InlineValueOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlayHintLabelPart =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``value``: global.Amongonz.LspTypes.LspString
    abstract ``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``location``: Location option
    abstract ``command``: Command option

/// An inlay hint label part allows for interactive and composite labels
/// of inlay hints.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintLabelPart private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlayHintLabelPart>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintLabelPart(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The value of this label part.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The tooltip text when you hover over this label part. Depending on
    /// the client capability `inlayHint.resolveSupport` clients might resolve
    /// this property late using the resolve request.
    member _.Tooltip =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tooltip`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltip") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional source code location that represents this
    /// label part.
    ///
    /// The editor will use this location for the hover and for code navigation
    /// features: This part will become a clickable link that resolves to the
    /// definition of the symbol at the given location (not necessarily the
    /// location itself), it shows the hover that shows at the given location,
    /// and it shows a context menu with further code navigation commands.
    ///
    /// Depending on the client capability `inlayHint.resolveSupport` clients
    /// might resolve this property late using the resolve request.
    member _.Location =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``location`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("location") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Location.FromElement(prop))

    /// An optional command for this label part.
    ///
    /// Depending on the client capability `inlayHint.resolveSupport` clients
    /// might resolve this property late using the resolve request.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    static member Create
        (
            ``value``: global.Amongonz.LspTypes.LspString,
            ?``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``location``: Location,
            ?``command``: Command
        ) =
        InlayHintLabelPart(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlayHintLabelPart with
                    member _.``value`` = ``value``
                    member _.``tooltip`` = ``tooltip``
                    member _.``location`` = ``location``
                    member _.``command`` = ``command``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("value")
                        ``value``.WriteTo(``json writer``)

                        match ``tooltip`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tooltip`` ->
                            ``json writer``.WritePropertyName("tooltip")
                            ``tooltip``.WriteTo(``json writer``)

                        match ``location`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``location`` ->
                            ``json writer``.WritePropertyName("location")
                            ``location``.WriteTo(``json writer``)

                        match ``command`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``command`` ->
                            ``json writer``.WritePropertyName("command")
                            ``command``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHintLabelPart.FromElement(element))

type private IMarkupContent =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: MarkupKind
    abstract ``value``: global.Amongonz.LspTypes.LspString

/// A `MarkupContent` literal represents a string value which content is interpreted base on its
/// kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.
///
/// If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
/// See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
///
/// Here is an example how such a string can be constructed using JavaScript / TypeScript:
/// ```ts
/// let markdown: MarkdownContent = {
///  kind: MarkupKind.Markdown,
///  value: [
///    &apos;# Header&apos;,
///    &apos;Some text&apos;,
///    &apos;```typescript&apos;,
///    &apos;someCode();&apos;,
///    &apos;```&apos;
///  ].join(&apos;\n&apos;)
/// };
/// ```
///
/// *Please Note* that clients might sanitize the return markdown. A client could decide to
/// remove HTML from the markdown to avoid script execution.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkupContent private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMarkupContent>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MarkupContent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The type of the Markup
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            MarkupKind.FromElement(prop)

    /// The content itself
    member _.Value =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``kind``: MarkupKind, ``value``: global.Amongonz.LspTypes.LspString) =
        MarkupContent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMarkupContent with
                    member _.``kind`` = ``kind``
                    member _.``value`` = ``value``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("value")
                        ``value``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (MarkupKind.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(MarkupContent.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlayHintOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Inlay hint options used during static registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlayHintOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for an inlay hint item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        InlayHintOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlayHintOptions with
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlayHintOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IRelatedFullDocumentDiagnosticReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resultId``: global.Amongonz.LspTypes.LspString option
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// A full diagnostic report with a set of related documents.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RelatedFullDocumentDiagnosticReport
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRelatedFullDocumentDiagnosticReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RelatedFullDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Diagnostics of related documents. This information is useful
    /// in programming languages where code in a file A can generate
    /// diagnostics in a file B which A depends on. An example of
    /// such a language is C/C++ where marco definitions in a file
    /// a.cpp and result in errors in a header file b.hpp.
    ///
    /// @since 3.17.0
    member _.RelatedDocuments =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``relatedDocuments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedDocuments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A full document diagnostic report.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// An optional result id. If provided it will
    /// be sent on the next diagnostic request for the
    /// same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        RelatedFullDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRelatedFullDocumentDiagnosticReport with
                    member _.``relatedDocuments`` = ``relatedDocuments``
                    member _.``kind`` = ``kind``
                    member _.``resultId`` = ``resultId``
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``relatedDocuments`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``relatedDocuments`` ->
                            ``json writer``.WritePropertyName("relatedDocuments")
                            ``relatedDocuments``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)

                        match ``resultId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resultId`` ->
                            ``json writer``.WritePropertyName("resultId")
                            ``resultId``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RelatedFullDocumentDiagnosticReport.FromElement(element))

type private IRelatedUnchangedDocumentDiagnosticReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resultId``: global.Amongonz.LspTypes.LspString

/// An unchanged diagnostic report with a set of related documents.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RelatedUnchangedDocumentDiagnosticReport
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRelatedUnchangedDocumentDiagnosticReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RelatedUnchangedDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Diagnostics of related documents. This information is useful
    /// in programming languages where code in a file A can generate
    /// diagnostics in a file B which A depends on. An example of
    /// such a language is C/C++ where marco definitions in a file
    /// a.cpp and result in errors in a header file b.hpp.
    ///
    /// @since 3.17.0
    member _.RelatedDocuments =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``relatedDocuments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedDocuments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A document diagnostic report indicating
    /// no changes to the last result. A server can
    /// only return `unchanged` if result ids are
    /// provided.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// A result id which will be sent on the next
    /// diagnostic request for the same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``resultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("resultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``resultId``: global.Amongonz.LspTypes.LspString,
            ?``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        RelatedUnchangedDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRelatedUnchangedDocumentDiagnosticReport with
                    member _.``relatedDocuments`` = ``relatedDocuments``
                    member _.``kind`` = ``kind``
                    member _.``resultId`` = ``resultId``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``relatedDocuments`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``relatedDocuments`` ->
                            ``json writer``.WritePropertyName("relatedDocuments")
                            ``relatedDocuments``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("resultId")
                        ``resultId``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RelatedUnchangedDocumentDiagnosticReport.FromElement(element))

type private IFullDocumentDiagnosticReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resultId``: global.Amongonz.LspTypes.LspString option
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// A diagnostic report with a full set of problems.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FullDocumentDiagnosticReport
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFullDocumentDiagnosticReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FullDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A full document diagnostic report.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// An optional result id. If provided it will
    /// be sent on the next diagnostic request for the
    /// same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        FullDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFullDocumentDiagnosticReport with
                    member _.``kind`` = ``kind``
                    member _.``resultId`` = ``resultId``
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)

                        match ``resultId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resultId`` ->
                            ``json writer``.WritePropertyName("resultId")
                            ``resultId``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FullDocumentDiagnosticReport.FromElement(element))

type private IUnchangedDocumentDiagnosticReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resultId``: global.Amongonz.LspTypes.LspString

/// A diagnostic report indicating that the last returned
/// report is still accurate.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type UnchangedDocumentDiagnosticReport
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IUnchangedDocumentDiagnosticReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        UnchangedDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document diagnostic report indicating
    /// no changes to the last result. A server can
    /// only return `unchanged` if result ids are
    /// provided.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// A result id which will be sent on the next
    /// diagnostic request for the same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``resultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("resultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        UnchangedDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IUnchangedDocumentDiagnosticReport with
                    member _.``kind`` = ``kind``
                    member _.``resultId`` = ``resultId``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("resultId")
                        ``resultId``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(UnchangedDocumentDiagnosticReport.FromElement(element))

type private IDiagnosticOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``identifier``: global.Amongonz.LspTypes.LspString option
    abstract ``interFileDependencies``: global.FSharp.Core.bool
    abstract ``workspaceDiagnostics``: global.FSharp.Core.bool
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Diagnostic options.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDiagnosticOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional identifier under which the diagnostics are
    /// managed by the client.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Whether the language has inter file dependencies meaning that
    /// editing code in one file can result in a different diagnostic
    /// set in another file. Inter file dependencies are common for
    /// most programming languages and typically uncommon for linters.
    member _.InterFileDependencies =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``interFileDependencies``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("interFileDependencies")
            prop.GetBoolean()

    /// The server provides support for workspace diagnostics as well.
    member _.WorkspaceDiagnostics =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``workspaceDiagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("workspaceDiagnostics")
            prop.GetBoolean()

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``interFileDependencies``: global.FSharp.Core.bool,
            ``workspaceDiagnostics``: global.FSharp.Core.bool,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        DiagnosticOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDiagnosticOptions with
                    member _.``identifier`` = ``identifier``
                    member _.``interFileDependencies`` = ``interFileDependencies``
                    member _.``workspaceDiagnostics`` = ``workspaceDiagnostics``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``identifier`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``identifier`` ->
                            ``json writer``.WritePropertyName("identifier")
                            ``identifier``.WriteTo(``json writer``)

                        ``json writer``.WriteBoolean("interFileDependencies", ``interFileDependencies``)
                        ``json writer``.WriteBoolean("workspaceDiagnostics", ``workspaceDiagnostics``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "identifier" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "interFileDependencies" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspaceDiagnostics" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IPreviousResultId =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``value``: global.Amongonz.LspTypes.LspString

/// A previous result id in a workspace pull request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PreviousResultId private (backing: global.Amongonz.LspTypes.LspJsonBacking<IPreviousResultId>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PreviousResultId(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which the client knowns a
    /// result id.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The value of the previous result id.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``uri``: global.Amongonz.LspTypes.LspDocumentUri, ``value``: global.Amongonz.LspTypes.LspString)
        =
        PreviousResultId(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IPreviousResultId with
                    member _.``uri`` = ``uri``
                    member _.``value`` = ``value``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("value")
                        ``value``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(PreviousResultId.FromElement(element))
        else
            global.FSharp.Core.Error()

type private INotebookDocument =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.System.Uri
    abstract ``notebookType``: global.Amongonz.LspTypes.LspString
    abstract ``version``: global.FSharp.Core.int
    abstract ``metadata``: LSPObject option
    abstract ``cells``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// A notebook document.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocument private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookDocument>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocument(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    /// The type of the notebook.
    member _.NotebookType =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebookType``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookType")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The version number of this document (it will increase after each
    /// change, including undo/redo).
    member _.Version =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// Additional metadata stored with the notebook
    /// document.
    ///
    /// Note: should always be an object literal (e.g. LSPObject)
    member _.Metadata =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``metadata`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("metadata") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPObject.FromElement(prop))

    /// The cells of a notebook.
    member _.Cells =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``cells``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("cells")
            LspJsonBacking.Element prop

    static member Create
        (
            ``uri``: global.System.Uri,
            ``notebookType``: global.Amongonz.LspTypes.LspString,
            ``version``: global.FSharp.Core.int,
            ``cells``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``metadata``: LSPObject
        ) =
        NotebookDocument(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookDocument with
                    member _.``uri`` = ``uri``
                    member _.``notebookType`` = ``notebookType``
                    member _.``version`` = ``version``
                    member _.``metadata`` = ``metadata``
                    member _.``cells`` = ``cells``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("notebookType")
                        ``notebookType``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("version", ``version``)

                        match ``metadata`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``metadata`` ->
                            ``json writer``.WritePropertyName("metadata")
                            ``metadata``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("cells")
                        ``cells``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocument.FromElement(element))

type private ITextDocumentItem =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``languageId``: global.Amongonz.LspTypes.LspString
    abstract ``version``: global.FSharp.Core.int
    abstract ``text``: global.Amongonz.LspTypes.LspString

/// An item to transfer a text document from the client to the
/// server.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentItem private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentItem>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The text document&apos;s language identifier.
    member _.LanguageId =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``languageId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("languageId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The version number of this document (it will increase after each
    /// change, including undo/redo).
    member _.Version =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// The content of the opened text document.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``text``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("text")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``languageId``: global.Amongonz.LspTypes.LspString,
            ``version``: global.FSharp.Core.int,
            ``text``: global.Amongonz.LspTypes.LspString
        ) =
        TextDocumentItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentItem with
                    member _.``uri`` = ``uri``
                    member _.``languageId`` = ``languageId``
                    member _.``version`` = ``version``
                    member _.``text`` = ``text``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("languageId")
                        ``languageId``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("version", ``version``)
                        ``json writer``.WritePropertyName("text")
                        ``text``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "languageId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextDocumentItem.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IVersionedNotebookDocumentIdentifier =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``version``: global.FSharp.Core.int
    abstract ``uri``: global.System.Uri

/// A versioned notebook document identifier.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type VersionedNotebookDocumentIdentifier
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IVersionedNotebookDocumentIdentifier>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        VersionedNotebookDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The version number of this notebook document.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// The notebook document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    static member Create(``version``: global.FSharp.Core.int, ``uri``: global.System.Uri) =
        VersionedNotebookDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IVersionedNotebookDocumentIdentifier with
                    member _.``version`` = ``version``
                    member _.``uri`` = ``uri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("version", ``version``)
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(VersionedNotebookDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

type private INotebookDocumentChangeEvent =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``metadata``: LSPObject option
    abstract ``cells``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// A change event for a notebook document.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentChangeEvent
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookDocumentChangeEvent>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentChangeEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The changed meta data if any.
    ///
    /// Note: should always be an object literal (e.g. LSPObject)
    member _.Metadata =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``metadata`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("metadata") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPObject.FromElement(prop))

    /// Changes to cells
    member _.Cells =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``cells`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cells") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (?``metadata``: LSPObject, ?``cells``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>)
        =
        NotebookDocumentChangeEvent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookDocumentChangeEvent with
                    member _.``metadata`` = ``metadata``
                    member _.``cells`` = ``cells``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``metadata`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``metadata`` ->
                            ``json writer``.WritePropertyName("metadata")
                            ``metadata``.WriteTo(``json writer``)

                        match ``cells`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``cells`` ->
                            ``json writer``.WritePropertyName("cells")
                            ``cells``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocumentChangeEvent.FromElement(element))

type private INotebookDocumentIdentifier =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.System.Uri

/// A literal to identify a notebook document in the client.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentIdentifier private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookDocumentIdentifier>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    static member Create(``uri``: global.System.Uri) =
        NotebookDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookDocumentIdentifier with
                    member _.``uri`` = ``uri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(NotebookDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineCompletionContext =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``triggerKind``: InlineCompletionTriggerKind
    abstract ``selectedCompletionInfo``: SelectedCompletionInfo option

/// Provides information about the context in which an inline completion was requested.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionContext private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineCompletionContext>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Describes how the inline completion was triggered.
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``triggerKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("triggerKind")
            InlineCompletionTriggerKind.FromElement(prop)

    /// Provides information about the currently selected item in the autocomplete widget if it is visible.
    member _.SelectedCompletionInfo =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``selectedCompletionInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selectedCompletionInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SelectedCompletionInfo.FromElement(prop))

    static member Create
        (``triggerKind``: InlineCompletionTriggerKind, ?``selectedCompletionInfo``: SelectedCompletionInfo)
        =
        InlineCompletionContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineCompletionContext with
                    member _.``triggerKind`` = ``triggerKind``
                    member _.``selectedCompletionInfo`` = ``selectedCompletionInfo``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("triggerKind", int ``triggerKind``)

                        match ``selectedCompletionInfo`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``selectedCompletionInfo`` ->
                            ``json writer``.WritePropertyName("selectedCompletionInfo")
                            ``selectedCompletionInfo``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerKind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "selectedCompletionInfo" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SelectedCompletionInfo.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineCompletionContext.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IStringValue =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``value``: global.Amongonz.LspTypes.LspString

/// A string value used as a snippet is a template which allows to insert text
/// and to control the editor cursor when insertion happens.
///
/// A snippet can define tab stops and placeholders with `$1`, `$2`
/// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
/// the end of the snippet. Variables are defined with `$name` and
/// `${name:default value}`.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type StringValue private (backing: global.Amongonz.LspTypes.LspJsonBacking<IStringValue>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        StringValue(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The kind of string value.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The snippet string.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``value``: global.Amongonz.LspTypes.LspString
        ) =
        StringValue(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IStringValue with
                    member _.``kind`` = ``kind``
                    member _.``value`` = ``value``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("value")
                        ``value``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(StringValue.FromElement(element))

type private IInlineCompletionOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Inline completion options used during static registration.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineCompletionOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        InlineCompletionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineCompletionOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineCompletionOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IRegistration =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``id``: global.Amongonz.LspTypes.LspString
    abstract ``method``: global.Amongonz.LspTypes.LspString
    abstract ``registerOptions``: LSPAny option

/// General parameters to register for a notification or to register a provider.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Registration private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRegistration>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Registration(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The id used to register the request. The id can be used to deregister
    /// the request again.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``id``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("id")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The method / capability to register for.
    member _.Method =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``method``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("method")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Options necessary for the registration.
    member _.RegisterOptions =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``registerOptions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("registerOptions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``id``: global.Amongonz.LspTypes.LspString,
            ``method``: global.Amongonz.LspTypes.LspString,
            ?``registerOptions``: LSPAny
        ) =
        Registration(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRegistration with
                    member _.``id`` = ``id``
                    member _.``method`` = ``method``
                    member _.``registerOptions`` = ``registerOptions``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("id")
                        ``id``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("method")
                        ``method``.WriteTo(``json writer``)

                        match ``registerOptions`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``registerOptions`` ->
                            ``json writer``.WritePropertyName("registerOptions")
                            ``registerOptions``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "id" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "method" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "registerOptions" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(Registration.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IUnregistration =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``id``: global.Amongonz.LspTypes.LspString
    abstract ``method``: global.Amongonz.LspTypes.LspString

/// General parameters to unregister a request or notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Unregistration private (backing: global.Amongonz.LspTypes.LspJsonBacking<IUnregistration>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Unregistration(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The id used to unregister the request or notification. Usually an id
    /// provided during the register request.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``id``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("id")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The method to unregister for.
    member _.Method =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``method``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("method")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``id``: global.Amongonz.LspTypes.LspString, ``method``: global.Amongonz.LspTypes.LspString) =
        Unregistration(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IUnregistration with
                    member _.``id`` = ``id``
                    member _.``method`` = ``method``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("id")
                        ``id``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("method")
                        ``method``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "id" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "method" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(Unregistration.FromElement(element))
        else
            global.FSharp.Core.Error()

type private I_InitializeParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``processId``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``locale``: global.Amongonz.LspTypes.LspString option
    abstract ``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``capabilities``: ClientCapabilities
    abstract ``initializationOptions``: LSPAny option
    abstract ``trace``: TraceValues option
    abstract ``workDoneToken``: ProgressToken option

/// The initialize parameters
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type _InitializeParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<I_InitializeParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        _InitializeParams (global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The process Id of the parent process that started
    /// the server.
    ///
    /// Is `null` if the process has not been started by another process.
    /// If the parent process is not alive then the server should exit.
    member _.ProcessId =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``processId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("processId")
            LspJsonBacking.Element prop

    /// Information about the client
    ///
    /// @since 3.15.0
    member _.ClientInfo =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``clientInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("clientInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The locale the client is currently showing the user interface
    /// in. This must not necessarily be the locale of the operating
    /// system.
    ///
    /// Uses IETF language tags as the value&apos;s syntax
    /// (See https://en.wikipedia.org/wiki/IETF_language_tag)
    ///
    /// @since 3.16.0
    member _.Locale =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``locale`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("locale") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The rootPath of the workspace. Is null
    /// if no folder is open.
    ///
    /// @deprecated in favour of rootUri.
    [<global.System.Obsolete("in favour of rootUri.")>]
    member _.RootPath =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rootPath`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rootPath") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The rootUri of the workspace. Is null if no
    /// folder is open. If both `rootPath` and `rootUri` are set
    /// `rootUri` wins.
    ///
    /// @deprecated in favour of workspaceFolders.
    [<global.System.Obsolete("in favour of workspaceFolders.")>]
    member _.RootUri =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``rootUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("rootUri")
            LspJsonBacking.Element prop

    /// The capabilities provided by the client (editor or tool)
    member _.Capabilities =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``capabilities``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("capabilities")
            ClientCapabilities.FromElement(prop)

    /// User provided initialization options.
    member _.InitializationOptions =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``initializationOptions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("initializationOptions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    /// The initial trace setting. If omitted trace is disabled (&apos;off&apos;).
    member _.Trace =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``trace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TraceValues.FromElement(prop))

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``processId``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``capabilities``: ClientCapabilities,
            ?``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``locale``: global.Amongonz.LspTypes.LspString,
            ?``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``initializationOptions``: LSPAny,
            ?``trace``: TraceValues,
            ?``workDoneToken``: ProgressToken
        ) =
        _InitializeParams (
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new I_InitializeParams with
                    member _.``processId`` = ``processId``
                    member _.``clientInfo`` = ``clientInfo``
                    member _.``locale`` = ``locale``
                    member _.``rootPath`` = ``rootPath``
                    member _.``rootUri`` = ``rootUri``
                    member _.``capabilities`` = ``capabilities``
                    member _.``initializationOptions`` = ``initializationOptions``
                    member _.``trace`` = ``trace``
                    member _.``workDoneToken`` = ``workDoneToken``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("processId")
                        ``processId``.WriteTo(``json writer``)

                        match ``clientInfo`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``clientInfo`` ->
                            ``json writer``.WritePropertyName("clientInfo")
                            ``clientInfo``.WriteTo(``json writer``)

                        match ``locale`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``locale`` ->
                            ``json writer``.WritePropertyName("locale")
                            ``locale``.WriteTo(``json writer``)

                        match ``rootPath`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rootPath`` ->
                            ``json writer``.WritePropertyName("rootPath")
                            ``rootPath``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("rootUri")
                        ``rootUri``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("capabilities")
                        ``capabilities``.WriteTo(``json writer``)

                        match ``initializationOptions`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``initializationOptions`` ->
                            ``json writer``.WritePropertyName("initializationOptions")
                            ``initializationOptions``.WriteTo(``json writer``)

                        match ``trace`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``trace`` ->
                            ``json writer``.WritePropertyName("trace")
                            ``trace``.WriteTo(``json writer``)

                        match ``workDoneToken`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneToken`` ->
                            ``json writer``.WritePropertyName("workDoneToken")
                            ``workDoneToken``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(_InitializeParams.FromElement(element))

type private IWorkspaceFoldersInitializeParams =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFoldersInitializeParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceFoldersInitializeParams>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFoldersInitializeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The workspace folders configured in the client when the server starts.
    ///
    /// This property is only available if the client supports workspace folders.
    /// It can be `null` if the client supports workspace folders but none are
    /// configured.
    ///
    /// @since 3.6.0
    member _.WorkspaceFolders =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workspaceFolders`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceFolders") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create(?``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        WorkspaceFoldersInitializeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceFoldersInitializeParams with
                    member _.``workspaceFolders`` = ``workspaceFolders``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workspaceFolders`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workspaceFolders`` ->
                            ``json writer``.WritePropertyName("workspaceFolders")
                            ``workspaceFolders``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFoldersInitializeParams.FromElement(element))

type private IServerCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``positionEncoding``: PositionEncodingKind option
    abstract ``textDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``notebookDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``completionProvider``: CompletionOptions option
    abstract ``hoverProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``signatureHelpProvider``: SignatureHelpOptions option
    abstract ``declarationProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``definitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``typeDefinitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``implementationProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``referencesProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``documentHighlightProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``documentSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``codeActionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``codeLensProvider``: CodeLensOptions option
    abstract ``documentLinkProvider``: DocumentLinkOptions option
    abstract ``colorProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``workspaceSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``documentFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``documentRangeFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``documentOnTypeFormattingProvider``: DocumentOnTypeFormattingOptions option
    abstract ``renameProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``foldingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``selectionRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``executeCommandProvider``: ExecuteCommandOptions option
    abstract ``callHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``linkedEditingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``semanticTokensProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``monikerProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``typeHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``inlineValueProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``inlayHintProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``diagnosticProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``inlineCompletionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``workspace``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``experimental``: LSPAny option

/// Defines the capabilities provided by a language
/// server.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ServerCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IServerCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ServerCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The position encoding the server picked from the encodings offered
    /// by the client via the client capability `general.positionEncodings`.
    ///
    /// If the client didn&apos;t provide any position encodings the only valid
    /// value that a server can return is &apos;utf-16&apos;.
    ///
    /// If omitted it defaults to &apos;utf-16&apos;.
    ///
    /// @since 3.17.0
    member _.PositionEncoding =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``positionEncoding`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("positionEncoding") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(PositionEncodingKind.FromElement(prop))

    /// Defines how text documents are synced. Is either a detailed structure
    /// defining each notification or for backwards compatibility the
    /// TextDocumentSyncKind number.
    member _.TextDocumentSync =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``textDocumentSync`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textDocumentSync") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Defines how notebook documents are synced.
    ///
    /// @since 3.17.0
    member _.NotebookDocumentSync =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``notebookDocumentSync`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("notebookDocumentSync") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides completion support.
    member _.CompletionProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``completionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionOptions.FromElement(prop))

    /// The server provides hover support.
    member _.HoverProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``hoverProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("hoverProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides signature help support.
    member _.SignatureHelpProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``signatureHelpProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("signatureHelpProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelpOptions.FromElement(prop))

    /// The server provides Goto Declaration support.
    member _.DeclarationProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``declarationProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("declarationProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides goto definition support.
    member _.DefinitionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``definitionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("definitionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides Goto Type Definition support.
    member _.TypeDefinitionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``typeDefinitionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeDefinitionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides Goto Implementation support.
    member _.ImplementationProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``implementationProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("implementationProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides find references support.
    member _.ReferencesProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``referencesProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("referencesProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document highlight support.
    member _.DocumentHighlightProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentHighlightProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentHighlightProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document symbol support.
    member _.DocumentSymbolProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentSymbolProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentSymbolProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides code actions. CodeActionOptions may only be
    /// specified if the client states that it supports
    /// `codeActionLiteralSupport` in its initial `initialize` request.
    member _.CodeActionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeActionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides code lens.
    member _.CodeLensProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeLensProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeLensProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeLensOptions.FromElement(prop))

    /// The server provides document link support.
    member _.DocumentLinkProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentLinkProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentLinkProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentLinkOptions.FromElement(prop))

    /// The server provides color provider support.
    member _.ColorProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``colorProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("colorProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides workspace symbol support.
    member _.WorkspaceSymbolProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workspaceSymbolProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceSymbolProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document formatting.
    member _.DocumentFormattingProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentFormattingProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentFormattingProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document range formatting.
    member _.DocumentRangeFormattingProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentRangeFormattingProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentRangeFormattingProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document formatting on typing.
    member _.DocumentOnTypeFormattingProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentOnTypeFormattingProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentOnTypeFormattingProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentOnTypeFormattingOptions.FromElement(prop))

    /// The server provides rename support. RenameOptions may only be
    /// specified if the client states that it supports
    /// `prepareSupport` in its initial `initialize` request.
    member _.RenameProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``renameProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("renameProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides folding provider support.
    member _.FoldingRangeProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``foldingRangeProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRangeProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides selection range support.
    member _.SelectionRangeProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``selectionRangeProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selectionRangeProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides execute command support.
    member _.ExecuteCommandProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``executeCommandProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executeCommandProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ExecuteCommandOptions.FromElement(prop))

    /// The server provides call hierarchy support.
    ///
    /// @since 3.16.0
    member _.CallHierarchyProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``callHierarchyProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("callHierarchyProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides linked editing range support.
    ///
    /// @since 3.16.0
    member _.LinkedEditingRangeProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``linkedEditingRangeProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkedEditingRangeProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides semantic tokens support.
    ///
    /// @since 3.16.0
    member _.SemanticTokensProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``semanticTokensProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("semanticTokensProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides moniker support.
    ///
    /// @since 3.16.0
    member _.MonikerProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``monikerProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("monikerProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides type hierarchy support.
    ///
    /// @since 3.17.0
    member _.TypeHierarchyProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``typeHierarchyProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeHierarchyProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides inline values.
    ///
    /// @since 3.17.0
    member _.InlineValueProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlineValueProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineValueProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides inlay hints.
    ///
    /// @since 3.17.0
    member _.InlayHintProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlayHintProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlayHintProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server has support for pull model diagnostics.
    ///
    /// @since 3.17.0
    member _.DiagnosticProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``diagnosticProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnosticProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Inline completion options used during static registration.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.InlineCompletionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlineCompletionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineCompletionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Workspace specific server capabilities.
    member _.Workspace =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workspace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Experimental server capabilities.
    member _.Experimental =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``experimental`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("experimental") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ?``positionEncoding``: PositionEncodingKind,
            ?``textDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``notebookDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``completionProvider``: CompletionOptions,
            ?``hoverProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``signatureHelpProvider``: SignatureHelpOptions,
            ?``declarationProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``definitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``typeDefinitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``implementationProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``referencesProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``documentHighlightProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``documentSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``codeActionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``codeLensProvider``: CodeLensOptions,
            ?``documentLinkProvider``: DocumentLinkOptions,
            ?``colorProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workspaceSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``documentFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``documentRangeFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``documentOnTypeFormattingProvider``: DocumentOnTypeFormattingOptions,
            ?``renameProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``foldingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``selectionRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``executeCommandProvider``: ExecuteCommandOptions,
            ?``callHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``linkedEditingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``semanticTokensProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``monikerProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``typeHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``inlineValueProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``inlayHintProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``diagnosticProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``inlineCompletionProvider``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workspace``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``experimental``: LSPAny
        ) =
        ServerCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IServerCapabilities with
                    member _.``positionEncoding`` = ``positionEncoding``
                    member _.``textDocumentSync`` = ``textDocumentSync``
                    member _.``notebookDocumentSync`` = ``notebookDocumentSync``
                    member _.``completionProvider`` = ``completionProvider``
                    member _.``hoverProvider`` = ``hoverProvider``
                    member _.``signatureHelpProvider`` = ``signatureHelpProvider``
                    member _.``declarationProvider`` = ``declarationProvider``
                    member _.``definitionProvider`` = ``definitionProvider``
                    member _.``typeDefinitionProvider`` = ``typeDefinitionProvider``
                    member _.``implementationProvider`` = ``implementationProvider``
                    member _.``referencesProvider`` = ``referencesProvider``
                    member _.``documentHighlightProvider`` = ``documentHighlightProvider``
                    member _.``documentSymbolProvider`` = ``documentSymbolProvider``
                    member _.``codeActionProvider`` = ``codeActionProvider``
                    member _.``codeLensProvider`` = ``codeLensProvider``
                    member _.``documentLinkProvider`` = ``documentLinkProvider``
                    member _.``colorProvider`` = ``colorProvider``
                    member _.``workspaceSymbolProvider`` = ``workspaceSymbolProvider``
                    member _.``documentFormattingProvider`` = ``documentFormattingProvider``
                    member _.``documentRangeFormattingProvider`` = ``documentRangeFormattingProvider``
                    member _.``documentOnTypeFormattingProvider`` = ``documentOnTypeFormattingProvider``
                    member _.``renameProvider`` = ``renameProvider``
                    member _.``foldingRangeProvider`` = ``foldingRangeProvider``
                    member _.``selectionRangeProvider`` = ``selectionRangeProvider``
                    member _.``executeCommandProvider`` = ``executeCommandProvider``
                    member _.``callHierarchyProvider`` = ``callHierarchyProvider``
                    member _.``linkedEditingRangeProvider`` = ``linkedEditingRangeProvider``
                    member _.``semanticTokensProvider`` = ``semanticTokensProvider``
                    member _.``monikerProvider`` = ``monikerProvider``
                    member _.``typeHierarchyProvider`` = ``typeHierarchyProvider``
                    member _.``inlineValueProvider`` = ``inlineValueProvider``
                    member _.``inlayHintProvider`` = ``inlayHintProvider``
                    member _.``diagnosticProvider`` = ``diagnosticProvider``
                    member _.``inlineCompletionProvider`` = ``inlineCompletionProvider``
                    member _.``workspace`` = ``workspace``
                    member _.``experimental`` = ``experimental``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``positionEncoding`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``positionEncoding`` ->
                            ``json writer``.WritePropertyName("positionEncoding")
                            ``positionEncoding``.WriteTo(``json writer``)

                        match ``textDocumentSync`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``textDocumentSync`` ->
                            ``json writer``.WritePropertyName("textDocumentSync")
                            ``textDocumentSync``.WriteTo(``json writer``)

                        match ``notebookDocumentSync`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``notebookDocumentSync`` ->
                            ``json writer``.WritePropertyName("notebookDocumentSync")
                            ``notebookDocumentSync``.WriteTo(``json writer``)

                        match ``completionProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``completionProvider`` ->
                            ``json writer``.WritePropertyName("completionProvider")
                            ``completionProvider``.WriteTo(``json writer``)

                        match ``hoverProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``hoverProvider`` ->
                            ``json writer``.WritePropertyName("hoverProvider")
                            ``hoverProvider``.WriteTo(``json writer``)

                        match ``signatureHelpProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``signatureHelpProvider`` ->
                            ``json writer``.WritePropertyName("signatureHelpProvider")
                            ``signatureHelpProvider``.WriteTo(``json writer``)

                        match ``declarationProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``declarationProvider`` ->
                            ``json writer``.WritePropertyName("declarationProvider")
                            ``declarationProvider``.WriteTo(``json writer``)

                        match ``definitionProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``definitionProvider`` ->
                            ``json writer``.WritePropertyName("definitionProvider")
                            ``definitionProvider``.WriteTo(``json writer``)

                        match ``typeDefinitionProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``typeDefinitionProvider`` ->
                            ``json writer``.WritePropertyName("typeDefinitionProvider")
                            ``typeDefinitionProvider``.WriteTo(``json writer``)

                        match ``implementationProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``implementationProvider`` ->
                            ``json writer``.WritePropertyName("implementationProvider")
                            ``implementationProvider``.WriteTo(``json writer``)

                        match ``referencesProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``referencesProvider`` ->
                            ``json writer``.WritePropertyName("referencesProvider")
                            ``referencesProvider``.WriteTo(``json writer``)

                        match ``documentHighlightProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentHighlightProvider`` ->
                            ``json writer``.WritePropertyName("documentHighlightProvider")
                            ``documentHighlightProvider``.WriteTo(``json writer``)

                        match ``documentSymbolProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentSymbolProvider`` ->
                            ``json writer``.WritePropertyName("documentSymbolProvider")
                            ``documentSymbolProvider``.WriteTo(``json writer``)

                        match ``codeActionProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeActionProvider`` ->
                            ``json writer``.WritePropertyName("codeActionProvider")
                            ``codeActionProvider``.WriteTo(``json writer``)

                        match ``codeLensProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeLensProvider`` ->
                            ``json writer``.WritePropertyName("codeLensProvider")
                            ``codeLensProvider``.WriteTo(``json writer``)

                        match ``documentLinkProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentLinkProvider`` ->
                            ``json writer``.WritePropertyName("documentLinkProvider")
                            ``documentLinkProvider``.WriteTo(``json writer``)

                        match ``colorProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``colorProvider`` ->
                            ``json writer``.WritePropertyName("colorProvider")
                            ``colorProvider``.WriteTo(``json writer``)

                        match ``workspaceSymbolProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workspaceSymbolProvider`` ->
                            ``json writer``.WritePropertyName("workspaceSymbolProvider")
                            ``workspaceSymbolProvider``.WriteTo(``json writer``)

                        match ``documentFormattingProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentFormattingProvider`` ->
                            ``json writer``.WritePropertyName("documentFormattingProvider")
                            ``documentFormattingProvider``.WriteTo(``json writer``)

                        match ``documentRangeFormattingProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentRangeFormattingProvider`` ->
                            ``json writer``.WritePropertyName("documentRangeFormattingProvider")
                            ``documentRangeFormattingProvider``.WriteTo(``json writer``)

                        match ``documentOnTypeFormattingProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentOnTypeFormattingProvider`` ->
                            ``json writer``.WritePropertyName("documentOnTypeFormattingProvider")
                            ``documentOnTypeFormattingProvider``.WriteTo(``json writer``)

                        match ``renameProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``renameProvider`` ->
                            ``json writer``.WritePropertyName("renameProvider")
                            ``renameProvider``.WriteTo(``json writer``)

                        match ``foldingRangeProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``foldingRangeProvider`` ->
                            ``json writer``.WritePropertyName("foldingRangeProvider")
                            ``foldingRangeProvider``.WriteTo(``json writer``)

                        match ``selectionRangeProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``selectionRangeProvider`` ->
                            ``json writer``.WritePropertyName("selectionRangeProvider")
                            ``selectionRangeProvider``.WriteTo(``json writer``)

                        match ``executeCommandProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``executeCommandProvider`` ->
                            ``json writer``.WritePropertyName("executeCommandProvider")
                            ``executeCommandProvider``.WriteTo(``json writer``)

                        match ``callHierarchyProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``callHierarchyProvider`` ->
                            ``json writer``.WritePropertyName("callHierarchyProvider")
                            ``callHierarchyProvider``.WriteTo(``json writer``)

                        match ``linkedEditingRangeProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``linkedEditingRangeProvider`` ->
                            ``json writer``.WritePropertyName("linkedEditingRangeProvider")
                            ``linkedEditingRangeProvider``.WriteTo(``json writer``)

                        match ``semanticTokensProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``semanticTokensProvider`` ->
                            ``json writer``.WritePropertyName("semanticTokensProvider")
                            ``semanticTokensProvider``.WriteTo(``json writer``)

                        match ``monikerProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``monikerProvider`` ->
                            ``json writer``.WritePropertyName("monikerProvider")
                            ``monikerProvider``.WriteTo(``json writer``)

                        match ``typeHierarchyProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``typeHierarchyProvider`` ->
                            ``json writer``.WritePropertyName("typeHierarchyProvider")
                            ``typeHierarchyProvider``.WriteTo(``json writer``)

                        match ``inlineValueProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlineValueProvider`` ->
                            ``json writer``.WritePropertyName("inlineValueProvider")
                            ``inlineValueProvider``.WriteTo(``json writer``)

                        match ``inlayHintProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlayHintProvider`` ->
                            ``json writer``.WritePropertyName("inlayHintProvider")
                            ``inlayHintProvider``.WriteTo(``json writer``)

                        match ``diagnosticProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``diagnosticProvider`` ->
                            ``json writer``.WritePropertyName("diagnosticProvider")
                            ``diagnosticProvider``.WriteTo(``json writer``)

                        match ``inlineCompletionProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlineCompletionProvider`` ->
                            ``json writer``.WritePropertyName("inlineCompletionProvider")
                            ``inlineCompletionProvider``.WriteTo(``json writer``)

                        match ``workspace`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workspace`` ->
                            ``json writer``.WritePropertyName("workspace")
                            ``workspace``.WriteTo(``json writer``)

                        match ``experimental`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``experimental`` ->
                            ``json writer``.WritePropertyName("experimental")
                            ``experimental``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ServerCapabilities.FromElement(element))

type private IVersionedTextDocumentIdentifier =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``version``: global.FSharp.Core.int
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri

/// A text document identifier to denote a specific version of a text document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type VersionedTextDocumentIdentifier
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IVersionedTextDocumentIdentifier>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        VersionedTextDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The version number of this document.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    static member Create(``version``: global.FSharp.Core.int, ``uri``: global.Amongonz.LspTypes.LspDocumentUri) =
        VersionedTextDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IVersionedTextDocumentIdentifier with
                    member _.``version`` = ``version``
                    member _.``uri`` = ``uri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("version", ``version``)
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(VersionedTextDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISaveOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``includeText``: global.FSharp.Core.bool option

/// Save options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SaveOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISaveOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SaveOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client is supposed to include the content on save.
    member _.IncludeText =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``includeText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("includeText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``includeText``: global.FSharp.Core.bool) =
        SaveOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISaveOptions with
                    member _.``includeText`` = ``includeText``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``includeText`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``includeText`` ->
                            ``json writer``.WriteBoolean("includeText", ``includeText``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "includeText" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SaveOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileEvent =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``type``: FileChangeType

/// An event describing a file change.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileEvent private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileEvent>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The file&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The change type.
    member _.Type =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            FileChangeType.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspDocumentUri, ``type``: FileChangeType) =
        FileEvent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileEvent with
                    member _.``uri`` = ``uri``
                    member _.``type`` = ``type``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WriteNumber("type", int ``type``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "type" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
        then
            global.FSharp.Core.Ok(FileEvent.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileSystemWatcher =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``globPattern``: GlobPattern
    abstract ``kind``: WatchKind option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileSystemWatcher private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileSystemWatcher>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileSystemWatcher(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The glob pattern to watch. See {@link GlobPattern glob pattern} for more detail.
    ///
    /// @since 3.17.0 support for relative patterns.
    member _.GlobPattern =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``globPattern``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("globPattern")
            GlobPattern.FromElement(prop)

    /// The kind of events of interest. If omitted it defaults
    /// to WatchKind.Create | WatchKind.Change | WatchKind.Delete
    /// which is 7.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome((prop.GetInt32(): WatchKind))

    static member Create(``globPattern``: GlobPattern, ?``kind``: WatchKind) =
        FileSystemWatcher(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileSystemWatcher with
                    member _.``globPattern`` = ``globPattern``
                    member _.``kind`` = ``kind``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("globPattern")
                        ``globPattern``.WriteTo(``json writer``)

                        match ``kind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``kind`` -> ``json writer``.WriteNumber("kind", int ``kind``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "globPattern" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (GlobPattern.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> true)
        then
            global.FSharp.Core.Ok(FileSystemWatcher.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDiagnostic =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``severity``: DiagnosticSeverity option
    abstract ``code``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``codeDescription``: CodeDescription option
    abstract ``source``: global.Amongonz.LspTypes.LspString option
    abstract ``message``: global.Amongonz.LspTypes.LspString
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``relatedInformation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``data``: LSPAny option

/// Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
/// are only valid in the scope of a resource.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Diagnostic private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDiagnostic>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Diagnostic(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range at which the message applies
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The diagnostic&apos;s severity. Can be omitted. If omitted it is up to the
    /// client to interpret diagnostics as error, warning, info or hint.
    member _.Severity =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``severity`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("severity") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DiagnosticSeverity.FromElement(prop))

    /// The diagnostic&apos;s code, which usually appear in the user interface.
    member _.Code =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``code`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("code") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional property to describe the error code.
    /// Requires the code field (above) to be present/not null.
    ///
    /// @since 3.16.0
    member _.CodeDescription =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeDescription`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeDescription") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeDescription.FromElement(prop))

    /// A human-readable string describing the source of this
    /// diagnostic, e.g. &apos;typescript&apos; or &apos;super lint&apos;. It usually
    /// appears in the user interface.
    member _.Source =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``source`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("source") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The diagnostic&apos;s message. It usually appears in the user interface
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Additional metadata about the diagnostic.
    ///
    /// @since 3.15.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An array of related diagnostic information, e.g. when symbol-names within
    /// a scope collide all definitions can be marked via this property.
    member _.RelatedInformation =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``relatedInformation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedInformation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A data entry field that is preserved between a `textDocument/publishDiagnostics`
    /// notification and `textDocument/codeAction` request.
    ///
    /// @since 3.16.0
    member _.Data =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``range``: Range,
            ``message``: global.Amongonz.LspTypes.LspString,
            ?``severity``: DiagnosticSeverity,
            ?``code``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``codeDescription``: CodeDescription,
            ?``source``: global.Amongonz.LspTypes.LspString,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``relatedInformation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``data``: LSPAny
        ) =
        Diagnostic(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDiagnostic with
                    member _.``range`` = ``range``
                    member _.``severity`` = ``severity``
                    member _.``code`` = ``code``
                    member _.``codeDescription`` = ``codeDescription``
                    member _.``source`` = ``source``
                    member _.``message`` = ``message``
                    member _.``tags`` = ``tags``
                    member _.``relatedInformation`` = ``relatedInformation``
                    member _.``data`` = ``data``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)

                        match ``severity`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``severity`` ->
                            ``json writer``.WriteNumber("severity", int ``severity``)

                        match ``code`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``code`` ->
                            ``json writer``.WritePropertyName("code")
                            ``code``.WriteTo(``json writer``)

                        match ``codeDescription`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeDescription`` ->
                            ``json writer``.WritePropertyName("codeDescription")
                            ``codeDescription``.WriteTo(``json writer``)

                        match ``source`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``source`` ->
                            ``json writer``.WritePropertyName("source")
                            ``source``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("message")
                        ``message``.WriteTo(``json writer``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``relatedInformation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``relatedInformation`` ->
                            ``json writer``.WritePropertyName("relatedInformation")
                            ``relatedInformation``.WriteTo(``json writer``)

                        match ``data`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``data`` ->
                            ``json writer``.WritePropertyName("data")
                            ``data``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(Diagnostic.FromElement(element))

type private ICompletionContext =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``triggerKind``: CompletionTriggerKind
    abstract ``triggerCharacter``: global.Amongonz.LspTypes.LspString option

/// Contains additional information about the context in which a completion request is triggered.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionContext private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionContext>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// How the completion was triggered.
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``triggerKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("triggerKind")
            CompletionTriggerKind.FromElement(prop)

    /// The trigger character (a single character) that has trigger code complete.
    /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
    member _.TriggerCharacter =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``triggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``triggerKind``: CompletionTriggerKind, ?``triggerCharacter``: global.Amongonz.LspTypes.LspString)
        =
        CompletionContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionContext with
                    member _.``triggerKind`` = ``triggerKind``
                    member _.``triggerCharacter`` = ``triggerCharacter``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("triggerKind", int ``triggerKind``)

                        match ``triggerCharacter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``triggerCharacter`` ->
                            ``json writer``.WritePropertyName("triggerCharacter")
                            ``triggerCharacter``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerKind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(CompletionContext.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICompletionItemLabelDetails =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``detail``: global.Amongonz.LspTypes.LspString option
    abstract ``description``: global.Amongonz.LspTypes.LspString option

/// Additional details for a completion item label.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionItemLabelDetails private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionItemLabelDetails>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionItemLabelDetails(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
    /// without any spacing. Should be used for function signatures and type annotations.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
    /// for fully qualified names and file paths.
    member _.Description =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``description`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("description") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (?``detail``: global.Amongonz.LspTypes.LspString, ?``description``: global.Amongonz.LspTypes.LspString) =
        CompletionItemLabelDetails(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionItemLabelDetails with
                    member _.``detail`` = ``detail``
                    member _.``description`` = ``description``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``detail`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``detail`` ->
                            ``json writer``.WritePropertyName("detail")
                            ``detail``.WriteTo(``json writer``)

                        match ``description`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``description`` ->
                            ``json writer``.WritePropertyName("description")
                            ``description``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "detail" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "description" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(CompletionItemLabelDetails.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInsertReplaceEdit =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``newText``: global.Amongonz.LspTypes.LspString
    abstract ``insert``: Range
    abstract ``replace``: Range

/// A special text edit to provide an insert and a replace operation.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InsertReplaceEdit private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInsertReplaceEdit>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InsertReplaceEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The string to be inserted.
    member _.NewText =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``newText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newText")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The range if the insert is requested
    member _.Insert =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``insert``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("insert")
            Range.FromElement(prop)

    /// The range if the replace is requested.
    member _.Replace =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``replace``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("replace")
            Range.FromElement(prop)

    static member Create(``newText``: global.Amongonz.LspTypes.LspString, ``insert``: Range, ``replace``: Range) =
        InsertReplaceEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInsertReplaceEdit with
                    member _.``newText`` = ``newText``
                    member _.``insert`` = ``insert``
                    member _.``replace`` = ``replace``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("newText")
                        ``newText``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("insert")
                        ``insert``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("replace")
                        ``replace``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "newText" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "insert" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "replace" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(InsertReplaceEdit.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICompletionOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Completion options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Most tools trigger completion request automatically without explicitly requesting
    /// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
    /// starts to type an identifier. For example if the user types `c` in a JavaScript file
    /// code complete will automatically pop up present `console` besides others as a
    /// completion item. Characters that make up identifiers don&apos;t need to be listed here.
    ///
    /// If code complete should automatically be trigger on characters not being valid inside
    /// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The list of all possible characters that commit a completion. This field can be used
    /// if clients don&apos;t support individual commit characters per completion item. See
    /// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
    ///
    /// If a server provides both `allCommitCharacters` and commit characters on an individual
    /// completion item the ones on the completion item win.
    ///
    /// @since 3.2.0
    member _.AllCommitCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``allCommitCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("allCommitCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a completion item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The server supports the following `CompletionItem` specific
    /// capabilities.
    ///
    /// @since 3.17.0
    member _.CompletionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``completionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        CompletionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionOptions with
                    member _.``triggerCharacters`` = ``triggerCharacters``
                    member _.``allCommitCharacters`` = ``allCommitCharacters``
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``completionItem`` = ``completionItem``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``triggerCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``triggerCharacters`` ->
                            ``json writer``.WritePropertyName("triggerCharacters")
                            ``triggerCharacters``.WriteTo(``json writer``)

                        match ``allCommitCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``allCommitCharacters`` ->
                            ``json writer``.WritePropertyName("allCommitCharacters")
                            ``allCommitCharacters``.WriteTo(``json writer``)

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        match ``completionItem`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``completionItem`` ->
                            ``json writer``.WritePropertyName("completionItem")
                            ``completionItem``.WriteTo(``json writer``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionOptions.FromElement(element))

type private IHoverOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Hover options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IHoverOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        HoverOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IHoverOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(HoverOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISignatureHelpContext =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``triggerKind``: SignatureHelpTriggerKind
    abstract ``triggerCharacter``: global.Amongonz.LspTypes.LspString option
    abstract ``isRetrigger``: global.FSharp.Core.bool
    abstract ``activeSignatureHelp``: SignatureHelp option

/// Additional information about the context in which a signature help request was triggered.
///
/// @since 3.15.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpContext private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISignatureHelpContext>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Action that caused signature help to be triggered.
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``triggerKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("triggerKind")
            SignatureHelpTriggerKind.FromElement(prop)

    /// Character that caused signature help to be triggered.
    ///
    /// This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
    member _.TriggerCharacter =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``triggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// `true` if signature help was already showing when it was triggered.
    ///
    /// Retriggers occurs when the signature help is already active and can be caused by actions such as
    /// typing a trigger character, a cursor move, or document content changes.
    member _.IsRetrigger =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``isRetrigger``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("isRetrigger")
            prop.GetBoolean()

    /// The currently active `SignatureHelp`.
    ///
    /// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
    /// the user navigating through available signatures.
    member _.ActiveSignatureHelp =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``activeSignatureHelp`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeSignatureHelp") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelp.FromElement(prop))

    static member Create
        (
            ``triggerKind``: SignatureHelpTriggerKind,
            ``isRetrigger``: global.FSharp.Core.bool,
            ?``triggerCharacter``: global.Amongonz.LspTypes.LspString,
            ?``activeSignatureHelp``: SignatureHelp
        ) =
        SignatureHelpContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISignatureHelpContext with
                    member _.``triggerKind`` = ``triggerKind``
                    member _.``triggerCharacter`` = ``triggerCharacter``
                    member _.``isRetrigger`` = ``isRetrigger``
                    member _.``activeSignatureHelp`` = ``activeSignatureHelp``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("triggerKind", int ``triggerKind``)

                        match ``triggerCharacter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``triggerCharacter`` ->
                            ``json writer``.WritePropertyName("triggerCharacter")
                            ``triggerCharacter``.WriteTo(``json writer``)

                        ``json writer``.WriteBoolean("isRetrigger", ``isRetrigger``)

                        match ``activeSignatureHelp`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``activeSignatureHelp`` ->
                            ``json writer``.WritePropertyName("activeSignatureHelp")
                            ``activeSignatureHelp``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerKind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "isRetrigger" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "activeSignatureHelp" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SignatureHelp.Parse(prop)))
        then
            global.FSharp.Core.Ok(SignatureHelpContext.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISignatureInformation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``label``: global.Amongonz.LspTypes.LspString
    abstract ``documentation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``parameters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``activeParameter``: global.FSharp.Core.int option

/// Represents the signature of something callable. A signature
/// can have a label, like a function-name, a doc-comment, and
/// a set of parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureInformation private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISignatureInformation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this signature. Will be shown in
    /// the UI.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The human-readable doc-comment of this signature. Will be shown
    /// in the UI but can be omitted.
    member _.Documentation =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The parameters of this signature.
    member _.Parameters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``parameters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("parameters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The index of the active parameter.
    ///
    /// If provided, this is used in place of `SignatureHelp.activeParameter`.
    ///
    /// @since 3.16.0
    member _.ActiveParameter =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``activeParameter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeParameter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``documentation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``parameters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``activeParameter``: global.FSharp.Core.int
        ) =
        SignatureInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISignatureInformation with
                    member _.``label`` = ``label``
                    member _.``documentation`` = ``documentation``
                    member _.``parameters`` = ``parameters``
                    member _.``activeParameter`` = ``activeParameter``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("label")
                        ``label``.WriteTo(``json writer``)

                        match ``documentation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentation`` ->
                            ``json writer``.WritePropertyName("documentation")
                            ``documentation``.WriteTo(``json writer``)

                        match ``parameters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``parameters`` ->
                            ``json writer``.WritePropertyName("parameters")
                            ``parameters``.WriteTo(``json writer``)

                        match ``activeParameter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``activeParameter`` ->
                            ``json writer``.WriteNumber("activeParameter", ``activeParameter``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureInformation.FromElement(element))

type private ISignatureHelpOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Server Capabilities for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISignatureHelpOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// List of characters that trigger signature help automatically.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// List of characters that re-trigger signature help.
    ///
    /// These trigger characters are only active when signature help is already showing. All trigger characters
    /// are also counted as re-trigger characters.
    ///
    /// @since 3.15.0
    member _.RetriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``retriggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("retriggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        SignatureHelpOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISignatureHelpOptions with
                    member _.``triggerCharacters`` = ``triggerCharacters``
                    member _.``retriggerCharacters`` = ``retriggerCharacters``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``triggerCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``triggerCharacters`` ->
                            ``json writer``.WritePropertyName("triggerCharacters")
                            ``triggerCharacters``.WriteTo(``json writer``)

                        match ``retriggerCharacters`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``retriggerCharacters`` ->
                            ``json writer``.WritePropertyName("retriggerCharacters")
                            ``retriggerCharacters``.WriteTo(``json writer``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelpOptions.FromElement(element))

type private IDefinitionOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Server Capabilities for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDefinitionOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DefinitionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDefinitionOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DefinitionOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IReferenceContext =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``includeDeclaration``: global.FSharp.Core.bool

/// Value-object that contains additional information when
/// requesting references.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceContext private (backing: global.Amongonz.LspTypes.LspJsonBacking<IReferenceContext>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Include the declaration of the current symbol.
    member _.IncludeDeclaration =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``includeDeclaration``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("includeDeclaration")
            prop.GetBoolean()

    static member Create(``includeDeclaration``: global.FSharp.Core.bool) =
        ReferenceContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IReferenceContext with
                    member _.``includeDeclaration`` = ``includeDeclaration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteBoolean("includeDeclaration", ``includeDeclaration``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "includeDeclaration" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ReferenceContext.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IReferenceOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Reference options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IReferenceOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        ReferenceOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IReferenceOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ReferenceOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentHighlightOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Provider options for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentHighlightOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentHighlightOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentHighlightOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentHighlightOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IBaseSymbolInformation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``name``: global.Amongonz.LspTypes.LspString
    abstract ``kind``: SymbolKind
    abstract ``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``containerName``: global.Amongonz.LspTypes.LspString option

/// A base for all symbol information.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type BaseSymbolInformation private (backing: global.Amongonz.LspTypes.LspJsonBacking<IBaseSymbolInformation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        BaseSymbolInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this symbol.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The name of the symbol containing this symbol. This information is for
    /// user interface purposes (e.g. to render a qualifier in the user interface
    /// if necessary). It can&apos;t be used to re-infer a hierarchy for the document
    /// symbols.
    member _.ContainerName =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``containerName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("containerName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``containerName``: global.Amongonz.LspTypes.LspString
        ) =
        BaseSymbolInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IBaseSymbolInformation with
                    member _.``name`` = ``name``
                    member _.``kind`` = ``kind``
                    member _.``tags`` = ``tags``
                    member _.``containerName`` = ``containerName``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("name")
                        ``name``.WriteTo(``json writer``)
                        ``json writer``.WriteNumber("kind", int ``kind``)

                        match ``tags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tags`` ->
                            ``json writer``.WritePropertyName("tags")
                            ``tags``.WriteTo(``json writer``)

                        match ``containerName`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``containerName`` ->
                            ``json writer``.WritePropertyName("containerName")
                            ``containerName``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(BaseSymbolInformation.FromElement(element))

type private IDocumentSymbolOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``label``: global.Amongonz.LspTypes.LspString option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Provider options for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentSymbolOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A human-readable string that is shown when multiple outlines trees
    /// are shown for the same document.
    ///
    /// @since 3.16.0
    member _.Label =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``label`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("label") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``label``: global.Amongonz.LspTypes.LspString, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        DocumentSymbolOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentSymbolOptions with
                    member _.``label`` = ``label``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``label`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``label`` ->
                            ``json writer``.WritePropertyName("label")
                            ``label``.WriteTo(``json writer``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "label" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentSymbolOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICodeActionContext =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``only``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``triggerKind``: CodeActionTriggerKind option

/// Contains additional diagnostic information about the context in which
/// a {@link CodeActionProvider.provideCodeActions code action} is run.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionContext private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeActionContext>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of diagnostics known on the client side overlapping the range provided to the
    /// `textDocument/codeAction` request. They are provided so that the server knows which
    /// errors are currently presented to the user for the given range. There is no guarantee
    /// that these accurately reflect the error state of the resource. The primary parameter
    /// to compute code actions is the provided range.
    member _.Diagnostics =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``diagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("diagnostics")
            LspJsonBacking.Element prop

    /// Requested kind of actions to return.
    ///
    /// Actions not of this kind are filtered out by the client before being shown. So servers
    /// can omit computing them.
    member _.Only =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``only`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("only") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The reason why code actions were requested.
    ///
    /// @since 3.17.0
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``triggerKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeActionTriggerKind.FromElement(prop))

    static member Create
        (
            ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``only``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``triggerKind``: CodeActionTriggerKind
        ) =
        CodeActionContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeActionContext with
                    member _.``diagnostics`` = ``diagnostics``
                    member _.``only`` = ``only``
                    member _.``triggerKind`` = ``triggerKind``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("diagnostics")
                        ``diagnostics``.WriteTo(``json writer``)

                        match ``only`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``only`` ->
                            ``json writer``.WritePropertyName("only")
                            ``only``.WriteTo(``json writer``)

                        match ``triggerKind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``triggerKind`` ->
                            ``json writer``.WriteNumber("triggerKind", int ``triggerKind``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionContext.FromElement(element))

type private ICodeActionOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Provider options for a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeActionOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// CodeActionKinds that this server may return.
    ///
    /// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
    /// may list out every specific kind they provide.
    member _.CodeActionKinds =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeActionKinds`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionKinds") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a code action.
    ///
    /// @since 3.16.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        CodeActionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeActionOptions with
                    member _.``codeActionKinds`` = ``codeActionKinds``
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``codeActionKinds`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeActionKinds`` ->
                            ``json writer``.WritePropertyName("codeActionKinds")
                            ``codeActionKinds``.WriteTo(``json writer``)

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionOptions.FromElement(element))

type private IWorkspaceSymbolOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Server capabilities for a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceSymbolOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for a workspace symbol.
    ///
    /// @since 3.17.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        WorkspaceSymbolOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceSymbolOptions with
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(WorkspaceSymbolOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICodeLensOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Code Lens provider options of a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeLensOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Code lens has a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        CodeLensOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeLensOptions with
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CodeLensOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentLinkOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``resolveProvider``: global.FSharp.Core.bool option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Provider options for a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentLinkOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Document links have a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        DocumentLinkOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentLinkOptions with
                    member _.``resolveProvider`` = ``resolveProvider``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``resolveProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveProvider`` ->
                            ``json writer``.WriteBoolean("resolveProvider", ``resolveProvider``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentLinkOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFormattingOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``tabSize``: global.FSharp.Core.int
    abstract ``insertSpaces``: global.FSharp.Core.bool
    abstract ``trimTrailingWhitespace``: global.FSharp.Core.bool option
    abstract ``insertFinalNewline``: global.FSharp.Core.bool option
    abstract ``trimFinalNewlines``: global.FSharp.Core.bool option

/// Value-object describing what options formatting should use.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FormattingOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFormattingOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Size of a tab in spaces.
    member _.TabSize =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``tabSize``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tabSize")
            prop.GetInt32()

    /// Prefer spaces over tabs.
    member _.InsertSpaces =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``insertSpaces``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("insertSpaces")
            prop.GetBoolean()

    /// Trim trailing whitespace on a line.
    ///
    /// @since 3.15.0
    member _.TrimTrailingWhitespace =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``trimTrailingWhitespace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trimTrailingWhitespace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Insert a newline character at the end of the file if one does not exist.
    ///
    /// @since 3.15.0
    member _.InsertFinalNewline =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``insertFinalNewline`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertFinalNewline") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Trim all newlines after the final newline at the end of the file.
    ///
    /// @since 3.15.0
    member _.TrimFinalNewlines =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``trimFinalNewlines`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trimFinalNewlines") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``tabSize``: global.FSharp.Core.int,
            ``insertSpaces``: global.FSharp.Core.bool,
            ?``trimTrailingWhitespace``: global.FSharp.Core.bool,
            ?``insertFinalNewline``: global.FSharp.Core.bool,
            ?``trimFinalNewlines``: global.FSharp.Core.bool
        ) =
        FormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFormattingOptions with
                    member _.``tabSize`` = ``tabSize``
                    member _.``insertSpaces`` = ``insertSpaces``
                    member _.``trimTrailingWhitespace`` = ``trimTrailingWhitespace``
                    member _.``insertFinalNewline`` = ``insertFinalNewline``
                    member _.``trimFinalNewlines`` = ``trimFinalNewlines``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("tabSize", ``tabSize``)
                        ``json writer``.WriteBoolean("insertSpaces", ``insertSpaces``)

                        match ``trimTrailingWhitespace`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``trimTrailingWhitespace`` ->
                            ``json writer``.WriteBoolean("trimTrailingWhitespace", ``trimTrailingWhitespace``)

                        match ``insertFinalNewline`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``insertFinalNewline`` ->
                            ``json writer``.WriteBoolean("insertFinalNewline", ``insertFinalNewline``)

                        match ``trimFinalNewlines`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``trimFinalNewlines`` ->
                            ``json writer``.WriteBoolean("trimFinalNewlines", ``trimFinalNewlines``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "tabSize" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "insertSpaces" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "trimTrailingWhitespace" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "insertFinalNewline" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "trimFinalNewlines" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FormattingOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentFormattingOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Provider options for a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentFormattingOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentFormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentFormattingOptions with
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentFormattingOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentRangeFormattingOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``rangesSupport``: global.FSharp.Core.bool option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Provider options for a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentRangeFormattingOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the server supports formatting multiple ranges at once.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RangesSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rangesSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangesSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``rangesSupport``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentRangeFormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentRangeFormattingOptions with
                    member _.``rangesSupport`` = ``rangesSupport``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``rangesSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rangesSupport`` ->
                            ``json writer``.WriteBoolean("rangesSupport", ``rangesSupport``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "rangesSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentRangeFormattingOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentOnTypeFormattingOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString
    abstract ``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Provider options for a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentOnTypeFormattingOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A character on which formatting should be triggered, like `{`.
    member _.FirstTriggerCharacter =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``firstTriggerCharacter``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("firstTriggerCharacter")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// More trigger characters.
    member _.MoreTriggerCharacter =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``moreTriggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("moreTriggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString,
            ?``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        DocumentOnTypeFormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentOnTypeFormattingOptions with
                    member _.``firstTriggerCharacter`` = ``firstTriggerCharacter``
                    member _.``moreTriggerCharacter`` = ``moreTriggerCharacter``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("firstTriggerCharacter")
                        ``firstTriggerCharacter``.WriteTo(``json writer``)

                        match ``moreTriggerCharacter`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``moreTriggerCharacter`` ->
                            ``json writer``.WritePropertyName("moreTriggerCharacter")
                            ``moreTriggerCharacter``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentOnTypeFormattingOptions.FromElement(element))

type private IRenameOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``prepareProvider``: global.FSharp.Core.bool option
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// Provider options for a {@link RenameRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRenameOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Renames should be checked and tested before being executed.
    ///
    /// @since version 3.12.0
    member _.PrepareProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``prepareProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``prepareProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        RenameOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRenameOptions with
                    member _.``prepareProvider`` = ``prepareProvider``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``prepareProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``prepareProvider`` ->
                            ``json writer``.WriteBoolean("prepareProvider", ``prepareProvider``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "prepareProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(RenameOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IExecuteCommandOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``commands``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``workDoneProgress``: global.FSharp.Core.bool option

/// The server capabilities of a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IExecuteCommandOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The commands to be executed on the server
    member _.Commands =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``commands``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("commands")
            LspJsonBacking.Element prop

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``commands``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        ExecuteCommandOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IExecuteCommandOptions with
                    member _.``commands`` = ``commands``
                    member _.``workDoneProgress`` = ``workDoneProgress``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("commands")
                        ``commands``.WriteTo(``json writer``)

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ExecuteCommandOptions.FromElement(element))

type private ISemanticTokensLegend =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensLegend private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensLegend>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensLegend(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The token types a server uses.
    member _.TokenTypes =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``tokenTypes``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenTypes")
            LspJsonBacking.Element prop

    /// The token modifiers a server uses.
    member _.TokenModifiers =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``tokenModifiers``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenModifiers")
            LspJsonBacking.Element prop

    static member Create
        (
            ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        SemanticTokensLegend(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensLegend with
                    member _.``tokenTypes`` = ``tokenTypes``
                    member _.``tokenModifiers`` = ``tokenModifiers``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("tokenTypes")
                        ``tokenTypes``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("tokenModifiers")
                        ``tokenModifiers``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensLegend.FromElement(element))

type private IOptionalVersionedTextDocumentIdentifier =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``version``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri

/// A text document identifier to optionally denote a specific version of a text document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type OptionalVersionedTextDocumentIdentifier
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IOptionalVersionedTextDocumentIdentifier>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        OptionalVersionedTextDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The version number of this document. If a versioned text document identifier
    /// is sent from the server to the client and the file is not open in the editor
    /// (the server has not received an open notification before) the server can send
    /// `null` to indicate that the version is unknown and the content on disk is the
    /// truth (as specified with document content ownership).
    member _.Version =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            LspJsonBacking.Element prop

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    static member Create
        (
            ``version``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri
        ) =
        OptionalVersionedTextDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IOptionalVersionedTextDocumentIdentifier with
                    member _.``version`` = ``version``
                    member _.``uri`` = ``uri``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("version")
                        ``version``.WriteTo(``json writer``)
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(OptionalVersionedTextDocumentIdentifier.FromElement(element))

type private IAnnotatedTextEdit =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``annotationId``: ChangeAnnotationIdentifier
    abstract ``range``: Range
    abstract ``newText``: global.Amongonz.LspTypes.LspString

/// A special text edit with an additional change annotation.
///
/// @since 3.16.0.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type AnnotatedTextEdit private (backing: global.Amongonz.LspTypes.LspJsonBacking<IAnnotatedTextEdit>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        AnnotatedTextEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual identifier of the change annotation
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``annotationId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("annotationId")
            (global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier)

    /// The range of the text document to be manipulated. To insert
    /// text into a document create a range where start === end.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The string to be inserted. For delete operations use an
    /// empty string.
    member _.NewText =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``newText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newText")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``annotationId``: ChangeAnnotationIdentifier, ``range``: Range, ``newText``: global.Amongonz.LspTypes.LspString) =
        AnnotatedTextEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IAnnotatedTextEdit with
                    member _.``annotationId`` = ``annotationId``
                    member _.``range`` = ``range``
                    member _.``newText`` = ``newText``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("annotationId")
                        ``annotationId``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("newText")
                        ``newText``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "annotationId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newText" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(AnnotatedTextEdit.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IResourceOperation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: global.Amongonz.LspTypes.LspString
    abstract ``annotationId``: ChangeAnnotationIdentifier option

/// A generic resource operation.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ResourceOperation private (backing: global.Amongonz.LspTypes.LspJsonBacking<IResourceOperation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ResourceOperation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The resource operation kind.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create(``kind``: global.Amongonz.LspTypes.LspString, ?``annotationId``: ChangeAnnotationIdentifier) =
        ResourceOperation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IResourceOperation with
                    member _.``kind`` = ``kind``
                    member _.``annotationId`` = ``annotationId``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)

                        match ``annotationId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``annotationId`` ->
                            ``json writer``.WritePropertyName("annotationId")
                            ``annotationId``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "annotationId" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ResourceOperation.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICreateFileOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``overwrite``: global.FSharp.Core.bool option
    abstract ``ignoreIfExists``: global.FSharp.Core.bool option

/// Options to create a file.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CreateFileOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICreateFileOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CreateFileOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Overwrite existing file. Overwrite wins over `ignoreIfExists`
    member _.Overwrite =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``overwrite`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("overwrite") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Ignore if exists.
    member _.IgnoreIfExists =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``ignoreIfExists`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreIfExists") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``overwrite``: global.FSharp.Core.bool, ?``ignoreIfExists``: global.FSharp.Core.bool) =
        CreateFileOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICreateFileOptions with
                    member _.``overwrite`` = ``overwrite``
                    member _.``ignoreIfExists`` = ``ignoreIfExists``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``overwrite`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``overwrite`` ->
                            ``json writer``.WriteBoolean("overwrite", ``overwrite``)

                        match ``ignoreIfExists`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``ignoreIfExists`` ->
                            ``json writer``.WriteBoolean("ignoreIfExists", ``ignoreIfExists``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "overwrite" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreIfExists" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CreateFileOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IRenameFileOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``overwrite``: global.FSharp.Core.bool option
    abstract ``ignoreIfExists``: global.FSharp.Core.bool option

/// Rename file options
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameFileOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRenameFileOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameFileOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
    member _.Overwrite =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``overwrite`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("overwrite") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Ignores if target exists.
    member _.IgnoreIfExists =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``ignoreIfExists`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreIfExists") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``overwrite``: global.FSharp.Core.bool, ?``ignoreIfExists``: global.FSharp.Core.bool) =
        RenameFileOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRenameFileOptions with
                    member _.``overwrite`` = ``overwrite``
                    member _.``ignoreIfExists`` = ``ignoreIfExists``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``overwrite`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``overwrite`` ->
                            ``json writer``.WriteBoolean("overwrite", ``overwrite``)

                        match ``ignoreIfExists`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``ignoreIfExists`` ->
                            ``json writer``.WriteBoolean("ignoreIfExists", ``ignoreIfExists``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "overwrite" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreIfExists" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(RenameFileOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDeleteFileOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``recursive``: global.FSharp.Core.bool option
    abstract ``ignoreIfNotExists``: global.FSharp.Core.bool option

/// Delete file options
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeleteFileOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDeleteFileOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeleteFileOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Delete the content recursively if a folder is denoted.
    member _.Recursive =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``recursive`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("recursive") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Ignore the operation if the file doesn&apos;t exist.
    member _.IgnoreIfNotExists =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``ignoreIfNotExists`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreIfNotExists") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``recursive``: global.FSharp.Core.bool, ?``ignoreIfNotExists``: global.FSharp.Core.bool) =
        DeleteFileOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDeleteFileOptions with
                    member _.``recursive`` = ``recursive``
                    member _.``ignoreIfNotExists`` = ``ignoreIfNotExists``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``recursive`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``recursive`` ->
                            ``json writer``.WriteBoolean("recursive", ``recursive``)

                        match ``ignoreIfNotExists`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``ignoreIfNotExists`` ->
                            ``json writer``.WriteBoolean("ignoreIfNotExists", ``ignoreIfNotExists``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "recursive" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreIfNotExists" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DeleteFileOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileOperationPattern =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``glob``: global.Amongonz.LspTypes.LspString
    abstract ``matches``: FileOperationPatternKind option
    abstract ``options``: FileOperationPatternOptions option

/// A pattern to describe in which file operation requests or notifications
/// the server is interested in receiving.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationPattern private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileOperationPattern>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationPattern(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The glob pattern to match. Glob patterns can have the following syntax:
    /// - `*` to match one or more characters in a path segment
    /// - `?` to match on one character in a path segment
    /// - `**` to match any number of path segments, including none
    /// - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
    /// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
    /// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
    member _.Glob =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``glob``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("glob")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Whether to match files or folders with this pattern.
    ///
    /// Matches both if undefined.
    member _.Matches =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``matches`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("matches") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationPatternKind.FromElement(prop))

    /// Additional options used during matching.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationPatternOptions.FromElement(prop))

    static member Create
        (
            ``glob``: global.Amongonz.LspTypes.LspString,
            ?``matches``: FileOperationPatternKind,
            ?``options``: FileOperationPatternOptions
        ) =
        FileOperationPattern(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileOperationPattern with
                    member _.``glob`` = ``glob``
                    member _.``matches`` = ``matches``
                    member _.``options`` = ``options``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("glob")
                        ``glob``.WriteTo(``json writer``)

                        match ``matches`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``matches`` ->
                            ``json writer``.WritePropertyName("matches")
                            ``matches``.WriteTo(``json writer``)

                        match ``options`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``options`` ->
                            ``json writer``.WritePropertyName("options")
                            ``options``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "glob" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "matches" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationPatternKind.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationPatternOptions.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileOperationPattern.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkspaceFullDocumentDiagnosticReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``version``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resultId``: global.Amongonz.LspTypes.LspString option
    abstract ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>

/// A full document diagnostic report for a workspace diagnostic result.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFullDocumentDiagnosticReport
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceFullDocumentDiagnosticReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFullDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which diagnostic information is reported.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The version number for which the diagnostics are reported.
    /// If the document is not marked as open `null` can be provided.
    member _.Version =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            LspJsonBacking.Element prop

    /// A full document diagnostic report.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// An optional result id. If provided it will
    /// be sent on the next diagnostic request for the
    /// same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``version``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        WorkspaceFullDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceFullDocumentDiagnosticReport with
                    member _.``uri`` = ``uri``
                    member _.``version`` = ``version``
                    member _.``kind`` = ``kind``
                    member _.``resultId`` = ``resultId``
                    member _.``items`` = ``items``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("version")
                        ``version``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)

                        match ``resultId`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resultId`` ->
                            ``json writer``.WritePropertyName("resultId")
                            ``resultId``.WriteTo(``json writer``)

                        ``json writer``.WritePropertyName("items")
                        ``items``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFullDocumentDiagnosticReport.FromElement(element))

type private IWorkspaceUnchangedDocumentDiagnosticReport =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``uri``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``version``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``resultId``: global.Amongonz.LspTypes.LspString

/// An unchanged document diagnostic report for a workspace diagnostic result.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceUnchangedDocumentDiagnosticReport
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceUnchangedDocumentDiagnosticReport>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceUnchangedDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which diagnostic information is reported.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The version number for which the diagnostics are reported.
    /// If the document is not marked as open `null` can be provided.
    member _.Version =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            LspJsonBacking.Element prop

    /// A document diagnostic report indicating
    /// no changes to the last result. A server can
    /// only return `unchanged` if result ids are
    /// provided.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// A result id which will be sent on the next
    /// diagnostic request for the same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``resultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("resultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``version``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        WorkspaceUnchangedDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceUnchangedDocumentDiagnosticReport with
                    member _.``uri`` = ``uri``
                    member _.``version`` = ``version``
                    member _.``kind`` = ``kind``
                    member _.``resultId`` = ``resultId``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("uri", ``uri``.OriginalString)
                        ``json writer``.WritePropertyName("version")
                        ``version``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("kind")
                        ``kind``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("resultId")
                        ``resultId``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceUnchangedDocumentDiagnosticReport.FromElement(element))

type private INotebookCell =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``kind``: NotebookCellKind
    abstract ``document``: global.Amongonz.LspTypes.LspDocumentUri
    abstract ``metadata``: LSPObject option
    abstract ``executionSummary``: ExecutionSummary option

/// A notebook cell.
///
/// A cell&apos;s document URI must be unique across ALL notebook
/// cells and can therefore be used to uniquely identify a
/// notebook cell or the cell&apos;s text document.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookCell private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookCell>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookCell(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The cell&apos;s kind
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            NotebookCellKind.FromElement(prop)

    /// The URI of the cell&apos;s text document
    /// content.
    member _.Document =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``document``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("document")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Additional metadata stored with the cell.
    ///
    /// Note: should always be an object literal (e.g. LSPObject)
    member _.Metadata =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``metadata`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("metadata") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPObject.FromElement(prop))

    /// Additional execution summary information
    /// if supported by the client.
    member _.ExecutionSummary =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``executionSummary`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executionSummary") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ExecutionSummary.FromElement(prop))

    static member Create
        (
            ``kind``: NotebookCellKind,
            ``document``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``metadata``: LSPObject,
            ?``executionSummary``: ExecutionSummary
        ) =
        NotebookCell(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookCell with
                    member _.``kind`` = ``kind``
                    member _.``document`` = ``document``
                    member _.``metadata`` = ``metadata``
                    member _.``executionSummary`` = ``executionSummary``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("kind", int ``kind``)
                        ``json writer``.WriteString("document", ``document``.OriginalString)

                        match ``metadata`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``metadata`` ->
                            ``json writer``.WritePropertyName("metadata")
                            ``metadata``.WriteTo(``json writer``)

                        match ``executionSummary`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``executionSummary`` ->
                            ``json writer``.WritePropertyName("executionSummary")
                            ``executionSummary``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "document" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "metadata" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPObject.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "executionSummary" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ExecutionSummary.Parse(prop)))
        then
            global.FSharp.Core.Ok(NotebookCell.FromElement(element))
        else
            global.FSharp.Core.Error()

type private INotebookCellArrayChange =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``start``: global.FSharp.Core.int
    abstract ``deleteCount``: global.FSharp.Core.int
    abstract ``cells``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// A change describing how to move a `NotebookCell`
/// array from state S to S&apos;.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookCellArrayChange private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookCellArrayChange>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookCellArrayChange(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The start oftest of the cell that changed.
    member _.Start =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``start``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("start")
            prop.GetInt32()

    /// The deleted cells
    member _.DeleteCount =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``deleteCount``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("deleteCount")
            prop.GetInt32()

    /// The new cells, if any
    member _.Cells =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``cells`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cells") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``start``: global.FSharp.Core.int,
            ``deleteCount``: global.FSharp.Core.int,
            ?``cells``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        NotebookCellArrayChange(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookCellArrayChange with
                    member _.``start`` = ``start``
                    member _.``deleteCount`` = ``deleteCount``
                    member _.``cells`` = ``cells``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("start", ``start``)
                        ``json writer``.WriteNumber("deleteCount", ``deleteCount``)

                        match ``cells`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``cells`` ->
                            ``json writer``.WritePropertyName("cells")
                            ``cells``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookCellArrayChange.FromElement(element))

type private ISelectedCompletionInfo =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``range``: Range
    abstract ``text``: global.Amongonz.LspTypes.LspString

/// Describes the currently selected completion item.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectedCompletionInfo private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISelectedCompletionInfo>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectedCompletionInfo(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range that will be replaced if this completion item is accepted.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The text the range will be replaced with if this completion is accepted.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``text``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("text")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``range``: Range, ``text``: global.Amongonz.LspTypes.LspString) =
        SelectedCompletionInfo(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISelectedCompletionInfo with
                    member _.``range`` = ``range``
                    member _.``text`` = ``text``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("range")
                        ``range``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("text")
                        ``text``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(SelectedCompletionInfo.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workspace``: WorkspaceClientCapabilities option
    abstract ``textDocument``: TextDocumentClientCapabilities option
    abstract ``notebookDocument``: NotebookDocumentClientCapabilities option
    abstract ``window``: WindowClientCapabilities option
    abstract ``general``: GeneralClientCapabilities option
    abstract ``experimental``: LSPAny option

/// Defines the capabilities provided by the client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Workspace specific client capabilities.
    member _.Workspace =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workspace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceClientCapabilities.FromElement(prop))

    /// Text document specific client capabilities.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``textDocument`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textDocument") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextDocumentClientCapabilities.FromElement(prop))

    /// Capabilities specific to the notebook document support.
    ///
    /// @since 3.17.0
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``notebookDocument`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("notebookDocument") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(NotebookDocumentClientCapabilities.FromElement(prop))

    /// Window specific client capabilities.
    member _.Window =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``window`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("window") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WindowClientCapabilities.FromElement(prop))

    /// General client capabilities.
    ///
    /// @since 3.16.0
    member _.General =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``general`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("general") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(GeneralClientCapabilities.FromElement(prop))

    /// Experimental client capabilities.
    member _.Experimental =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``experimental`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("experimental") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ?``workspace``: WorkspaceClientCapabilities,
            ?``textDocument``: TextDocumentClientCapabilities,
            ?``notebookDocument``: NotebookDocumentClientCapabilities,
            ?``window``: WindowClientCapabilities,
            ?``general``: GeneralClientCapabilities,
            ?``experimental``: LSPAny
        ) =
        ClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IClientCapabilities with
                    member _.``workspace`` = ``workspace``
                    member _.``textDocument`` = ``textDocument``
                    member _.``notebookDocument`` = ``notebookDocument``
                    member _.``window`` = ``window``
                    member _.``general`` = ``general``
                    member _.``experimental`` = ``experimental``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workspace`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workspace`` ->
                            ``json writer``.WritePropertyName("workspace")
                            ``workspace``.WriteTo(``json writer``)

                        match ``textDocument`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``textDocument`` ->
                            ``json writer``.WritePropertyName("textDocument")
                            ``textDocument``.WriteTo(``json writer``)

                        match ``notebookDocument`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``notebookDocument`` ->
                            ``json writer``.WritePropertyName("notebookDocument")
                            ``notebookDocument``.WriteTo(``json writer``)

                        match ``window`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``window`` ->
                            ``json writer``.WritePropertyName("window")
                            ``window``.WriteTo(``json writer``)

                        match ``general`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``general`` ->
                            ``json writer``.WritePropertyName("general")
                            ``general``.WriteTo(``json writer``)

                        match ``experimental`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``experimental`` ->
                            ``json writer``.WritePropertyName("experimental")
                            ``experimental``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspace" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "notebookDocument" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "window" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WindowClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "general" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (GeneralClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "experimental" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(ClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentSyncOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``openClose``: global.FSharp.Core.bool option
    abstract ``change``: TextDocumentSyncKind option
    abstract ``willSave``: global.FSharp.Core.bool option
    abstract ``willSaveWaitUntil``: global.FSharp.Core.bool option
    abstract ``save``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentSyncOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentSyncOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentSyncOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Open and close notifications are sent to the server. If omitted open close notification should not
    /// be sent.
    member _.OpenClose =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``openClose`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("openClose") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
    /// and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
    member _.Change =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``change`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("change") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextDocumentSyncKind.FromElement(prop))

    /// If present will save notifications are sent to the server. If omitted the notification should not be
    /// sent.
    member _.WillSave =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willSave`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSave") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// If present will save wait until requests are sent to the server. If omitted the request should not be
    /// sent.
    member _.WillSaveWaitUntil =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willSaveWaitUntil`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSaveWaitUntil") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// If present save notifications are sent to the server. If omitted the notification should not be
    /// sent.
    member _.Save =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``save`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("save") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``openClose``: global.FSharp.Core.bool,
            ?``change``: TextDocumentSyncKind,
            ?``willSave``: global.FSharp.Core.bool,
            ?``willSaveWaitUntil``: global.FSharp.Core.bool,
            ?``save``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        TextDocumentSyncOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentSyncOptions with
                    member _.``openClose`` = ``openClose``
                    member _.``change`` = ``change``
                    member _.``willSave`` = ``willSave``
                    member _.``willSaveWaitUntil`` = ``willSaveWaitUntil``
                    member _.``save`` = ``save``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``openClose`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``openClose`` ->
                            ``json writer``.WriteBoolean("openClose", ``openClose``)

                        match ``change`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``change`` -> ``json writer``.WriteNumber("change", int ``change``)

                        match ``willSave`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willSave`` -> ``json writer``.WriteBoolean("willSave", ``willSave``)

                        match ``willSaveWaitUntil`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willSaveWaitUntil`` ->
                            ``json writer``.WriteBoolean("willSaveWaitUntil", ``willSaveWaitUntil``)

                        match ``save`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``save`` ->
                            ``json writer``.WritePropertyName("save")
                            ``save``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentSyncOptions.FromElement(element))

type private INotebookDocumentSyncOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``save``: global.FSharp.Core.bool option

/// Options specific to a notebook plus its cells
/// to be synced to the server.
///
/// If a selector provides a notebook document
/// filter but no cell selector all cells of a
/// matching notebook document will be synced.
///
/// If a selector provides no notebook document
/// filter but only a cell selector all notebook
/// document that contain at least one matching
/// cell will be synced.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentSyncOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookDocumentSyncOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentSyncOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebooks to be synced
    member _.NotebookSelector =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebookSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookSelector")
            LspJsonBacking.Element prop

    /// Whether save notification should be forwarded to
    /// the server. Will only be honored if mode === `notebook`.
    member _.Save =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``save`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("save") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``save``: global.FSharp.Core.bool
        ) =
        NotebookDocumentSyncOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookDocumentSyncOptions with
                    member _.``notebookSelector`` = ``notebookSelector``
                    member _.``save`` = ``save``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("notebookSelector")
                        ``notebookSelector``.WriteTo(``json writer``)

                        match ``save`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``save`` -> ``json writer``.WriteBoolean("save", ``save``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocumentSyncOptions.FromElement(element))

type private INotebookDocumentSyncRegistrationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``save``: global.FSharp.Core.bool option
    abstract ``id``: global.Amongonz.LspTypes.LspString option

/// Registration options specific to a notebook.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentSyncRegistrationOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookDocumentSyncRegistrationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentSyncRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebooks to be synced
    member _.NotebookSelector =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebookSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookSelector")
            LspJsonBacking.Element prop

    /// Whether save notification should be forwarded to
    /// the server. Will only be honored if mode === `notebook`.
    member _.Save =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``save`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("save") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``save``: global.FSharp.Core.bool,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        NotebookDocumentSyncRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookDocumentSyncRegistrationOptions with
                    member _.``notebookSelector`` = ``notebookSelector``
                    member _.``save`` = ``save``
                    member _.``id`` = ``id``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("notebookSelector")
                        ``notebookSelector``.WriteTo(``json writer``)

                        match ``save`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``save`` -> ``json writer``.WriteBoolean("save", ``save``)

                        match ``id`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``id`` ->
                            ``json writer``.WritePropertyName("id")
                            ``id``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocumentSyncRegistrationOptions.FromElement(element))

type private IWorkspaceFoldersServerCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``supported``: global.FSharp.Core.bool option
    abstract ``changeNotifications``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFoldersServerCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceFoldersServerCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFoldersServerCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server has support for workspace folders
    member _.Supported =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``supported`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("supported") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the server wants to receive workspace folder
    /// change notifications.
    ///
    /// If a string is provided the string is treated as an ID
    /// under which the notification is registered on the client
    /// side. The ID can be used to unregister for these events
    /// using the `client/unregisterCapability` request.
    member _.ChangeNotifications =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``changeNotifications`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changeNotifications") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``supported``: global.FSharp.Core.bool,
            ?``changeNotifications``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        WorkspaceFoldersServerCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceFoldersServerCapabilities with
                    member _.``supported`` = ``supported``
                    member _.``changeNotifications`` = ``changeNotifications``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``supported`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``supported`` ->
                            ``json writer``.WriteBoolean("supported", ``supported``)

                        match ``changeNotifications`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``changeNotifications`` ->
                            ``json writer``.WritePropertyName("changeNotifications")
                            ``changeNotifications``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFoldersServerCapabilities.FromElement(element))

type private IFileOperationOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``didCreate``: FileOperationRegistrationOptions option
    abstract ``willCreate``: FileOperationRegistrationOptions option
    abstract ``didRename``: FileOperationRegistrationOptions option
    abstract ``willRename``: FileOperationRegistrationOptions option
    abstract ``didDelete``: FileOperationRegistrationOptions option
    abstract ``willDelete``: FileOperationRegistrationOptions option

/// Options for notifications/requests for user operations on files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationOptions private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileOperationOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server is interested in receiving didCreateFiles notifications.
    member _.DidCreate =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving willCreateFiles requests.
    member _.WillCreate =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving didRenameFiles notifications.
    member _.DidRename =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving willRenameFiles requests.
    member _.WillRename =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving didDeleteFiles file notifications.
    member _.DidDelete =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving willDeleteFiles file requests.
    member _.WillDelete =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    static member Create
        (
            ?``didCreate``: FileOperationRegistrationOptions,
            ?``willCreate``: FileOperationRegistrationOptions,
            ?``didRename``: FileOperationRegistrationOptions,
            ?``willRename``: FileOperationRegistrationOptions,
            ?``didDelete``: FileOperationRegistrationOptions,
            ?``willDelete``: FileOperationRegistrationOptions
        ) =
        FileOperationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileOperationOptions with
                    member _.``didCreate`` = ``didCreate``
                    member _.``willCreate`` = ``willCreate``
                    member _.``didRename`` = ``didRename``
                    member _.``willRename`` = ``willRename``
                    member _.``didDelete`` = ``didDelete``
                    member _.``willDelete`` = ``willDelete``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``didCreate`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didCreate`` ->
                            ``json writer``.WritePropertyName("didCreate")
                            ``didCreate``.WriteTo(``json writer``)

                        match ``willCreate`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willCreate`` ->
                            ``json writer``.WritePropertyName("willCreate")
                            ``willCreate``.WriteTo(``json writer``)

                        match ``didRename`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didRename`` ->
                            ``json writer``.WritePropertyName("didRename")
                            ``didRename``.WriteTo(``json writer``)

                        match ``willRename`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willRename`` ->
                            ``json writer``.WritePropertyName("willRename")
                            ``willRename``.WriteTo(``json writer``)

                        match ``didDelete`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didDelete`` ->
                            ``json writer``.WritePropertyName("didDelete")
                            ``didDelete``.WriteTo(``json writer``)

                        match ``willDelete`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willDelete`` ->
                            ``json writer``.WritePropertyName("willDelete")
                            ``willDelete``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "didCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "willCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "willRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "willDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileOperationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICodeDescription =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``href``: global.System.Uri

/// Structure to capture a description for an error code.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeDescription private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeDescription>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeDescription(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An URI to open with more information about the diagnostic error.
    member _.Href =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``href``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("href")
            global.System.Uri(prop.GetString())

    static member Create(``href``: global.System.Uri) =
        CodeDescription(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeDescription with
                    member _.``href`` = ``href``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteString("href", ``href``.OriginalString)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "href" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(CodeDescription.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDiagnosticRelatedInformation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``location``: Location
    abstract ``message``: global.Amongonz.LspTypes.LspString

/// Represents a related message and source code location for a diagnostic. This should be
/// used to point to code locations that cause or related to a diagnostics, e.g when duplicating
/// a symbol in a scope.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticRelatedInformation
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDiagnosticRelatedInformation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticRelatedInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The location of this related diagnostic information.
    member _.Location =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``location``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("location")
            Location.FromElement(prop)

    /// The message of this related diagnostic information.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``location``: Location, ``message``: global.Amongonz.LspTypes.LspString) =
        DiagnosticRelatedInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDiagnosticRelatedInformation with
                    member _.``location`` = ``location``
                    member _.``message`` = ``message``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("location")
                        ``location``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("message")
                        ``message``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "location" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Location.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(DiagnosticRelatedInformation.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IParameterInformation =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``label``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``documentation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Represents a parameter of a callable-signature. A parameter can
/// have a label and a doc-comment.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ParameterInformation private (backing: global.Amongonz.LspTypes.LspJsonBacking<IParameterInformation>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ParameterInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this parameter information.
    ///
    /// Either a string or an inclusive start and exclusive end offsets within its containing
    /// signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
    /// string representation as `Position` and `Range` does.
    ///
    /// *Note*: a label of type string should be a substring of its containing signature label.
    /// Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
    member _.Label =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            LspJsonBacking.Element prop

    /// The human-readable doc-comment of this parameter. Will be shown
    /// in the UI but can be omitted.
    member _.Documentation =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``documentation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        ParameterInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IParameterInformation with
                    member _.``label`` = ``label``
                    member _.``documentation`` = ``documentation``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("label")
                        ``label``.WriteTo(``json writer``)

                        match ``documentation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentation`` ->
                            ``json writer``.WritePropertyName("documentation")
                            ``documentation``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ParameterInformation.FromElement(element))

type private INotebookCellTextDocumentFilter =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``notebook``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``language``: global.Amongonz.LspTypes.LspString option

/// A notebook cell text document filter denotes a cell text
/// document by different properties.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookCellTextDocumentFilter
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookCellTextDocumentFilter>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookCellTextDocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A filter that matches against the notebook
    /// containing the notebook cell. If a string
    /// value is provided it matches against the
    /// notebook type. &apos;*&apos; matches every notebook.
    member _.Notebook =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``notebook``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebook")
            LspJsonBacking.Element prop

    /// A language id like `python`.
    ///
    /// Will be matched against the language id of the
    /// notebook cell document. &apos;*&apos; matches every language.
    member _.Language =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``language`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("language") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``notebook``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``language``: global.Amongonz.LspTypes.LspString
        ) =
        NotebookCellTextDocumentFilter(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookCellTextDocumentFilter with
                    member _.``notebook`` = ``notebook``
                    member _.``language`` = ``language``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("notebook")
                        ``notebook``.WriteTo(``json writer``)

                        match ``language`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``language`` ->
                            ``json writer``.WritePropertyName("language")
                            ``language``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookCellTextDocumentFilter.FromElement(element))

type private IFileOperationPatternOptions =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``ignoreCase``: global.FSharp.Core.bool option

/// Matching options for the file operation pattern.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationPatternOptions
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileOperationPatternOptions>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationPatternOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The pattern should be matched ignoring casing.
    member _.IgnoreCase =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``ignoreCase`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreCase") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``ignoreCase``: global.FSharp.Core.bool) =
        FileOperationPatternOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileOperationPatternOptions with
                    member _.``ignoreCase`` = ``ignoreCase``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``ignoreCase`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``ignoreCase`` ->
                            ``json writer``.WriteBoolean("ignoreCase", ``ignoreCase``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreCase" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FileOperationPatternOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IExecutionSummary =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``executionOrder``: global.FSharp.Core.int
    abstract ``success``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecutionSummary private (backing: global.Amongonz.LspTypes.LspJsonBacking<IExecutionSummary>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecutionSummary(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A strict monotonically increasing value
    /// indicating the execution order of a cell
    /// inside a notebook.
    member _.ExecutionOrder =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``executionOrder``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("executionOrder")
            prop.GetInt32()

    /// Whether the execution was successful or
    /// not if known by the client.
    member _.Success =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``success`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("success") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(``executionOrder``: global.FSharp.Core.int, ?``success``: global.FSharp.Core.bool) =
        ExecutionSummary(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IExecutionSummary with
                    member _.``executionOrder`` = ``executionOrder``
                    member _.``success`` = ``success``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteNumber("executionOrder", ``executionOrder``)

                        match ``success`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``success`` -> ``json writer``.WriteBoolean("success", ``success``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "executionOrder" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "success" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ExecutionSummary.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkspaceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``applyEdit``: global.FSharp.Core.bool option
    abstract ``workspaceEdit``: WorkspaceEditClientCapabilities option
    abstract ``didChangeConfiguration``: DidChangeConfigurationClientCapabilities option
    abstract ``didChangeWatchedFiles``: DidChangeWatchedFilesClientCapabilities option
    abstract ``symbol``: WorkspaceSymbolClientCapabilities option
    abstract ``executeCommand``: ExecuteCommandClientCapabilities option
    abstract ``workspaceFolders``: global.FSharp.Core.bool option
    abstract ``configuration``: global.FSharp.Core.bool option
    abstract ``semanticTokens``: SemanticTokensWorkspaceClientCapabilities option
    abstract ``codeLens``: CodeLensWorkspaceClientCapabilities option
    abstract ``fileOperations``: FileOperationClientCapabilities option
    abstract ``inlineValue``: InlineValueWorkspaceClientCapabilities option
    abstract ``inlayHint``: InlayHintWorkspaceClientCapabilities option
    abstract ``diagnostics``: DiagnosticWorkspaceClientCapabilities option
    abstract ``foldingRange``: FoldingRangeWorkspaceClientCapabilities option

/// Workspace specific client capabilities.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client supports applying batch edits
    /// to the workspace by supporting the request
    /// &apos;workspace/applyEdit&apos;
    member _.ApplyEdit =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``applyEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("applyEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Capabilities specific to `WorkspaceEdit`s.
    member _.WorkspaceEdit =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workspaceEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceEditClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/didChangeConfiguration` notification.
    member _.DidChangeConfiguration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didChangeConfiguration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didChangeConfiguration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DidChangeConfigurationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
    member _.DidChangeWatchedFiles =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didChangeWatchedFiles`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didChangeWatchedFiles") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DidChangeWatchedFilesClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/symbol` request.
    member _.Symbol =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``symbol`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("symbol") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceSymbolClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/executeCommand` request.
    member _.ExecuteCommand =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``executeCommand`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executeCommand") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ExecuteCommandClientCapabilities.FromElement(prop))

    /// The client has support for workspace folders.
    ///
    /// @since 3.6.0
    member _.WorkspaceFolders =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workspaceFolders`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceFolders") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports `workspace/configuration` requests.
    ///
    /// @since 3.6.0
    member _.Configuration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``configuration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("configuration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Capabilities specific to the semantic token requests scoped to the
    /// workspace.
    ///
    /// @since 3.16.0.
    member _.SemanticTokens =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``semanticTokens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("semanticTokens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SemanticTokensWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the code lens requests scoped to the
    /// workspace.
    ///
    /// @since 3.16.0.
    member _.CodeLens =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeLens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeLens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeLensWorkspaceClientCapabilities.FromElement(prop))

    /// The client has support for file notifications/requests for user operations on files.
    ///
    /// Since 3.16.0
    member _.FileOperations =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``fileOperations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("fileOperations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the inline values requests scoped to the
    /// workspace.
    ///
    /// @since 3.17.0.
    member _.InlineValue =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlineValue`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineValue") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlineValueWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the inlay hint requests scoped to the
    /// workspace.
    ///
    /// @since 3.17.0.
    member _.InlayHint =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlayHint`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlayHint") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlayHintWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the diagnostic requests scoped to the
    /// workspace.
    ///
    /// @since 3.17.0.
    member _.Diagnostics =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``diagnostics`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnostics") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DiagnosticWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the folding range requests scoped to the workspace.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.FoldingRange =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``foldingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FoldingRangeWorkspaceClientCapabilities.FromElement(prop))

    static member Create
        (
            ?``applyEdit``: global.FSharp.Core.bool,
            ?``workspaceEdit``: WorkspaceEditClientCapabilities,
            ?``didChangeConfiguration``: DidChangeConfigurationClientCapabilities,
            ?``didChangeWatchedFiles``: DidChangeWatchedFilesClientCapabilities,
            ?``symbol``: WorkspaceSymbolClientCapabilities,
            ?``executeCommand``: ExecuteCommandClientCapabilities,
            ?``workspaceFolders``: global.FSharp.Core.bool,
            ?``configuration``: global.FSharp.Core.bool,
            ?``semanticTokens``: SemanticTokensWorkspaceClientCapabilities,
            ?``codeLens``: CodeLensWorkspaceClientCapabilities,
            ?``fileOperations``: FileOperationClientCapabilities,
            ?``inlineValue``: InlineValueWorkspaceClientCapabilities,
            ?``inlayHint``: InlayHintWorkspaceClientCapabilities,
            ?``diagnostics``: DiagnosticWorkspaceClientCapabilities,
            ?``foldingRange``: FoldingRangeWorkspaceClientCapabilities
        ) =
        WorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceClientCapabilities with
                    member _.``applyEdit`` = ``applyEdit``
                    member _.``workspaceEdit`` = ``workspaceEdit``
                    member _.``didChangeConfiguration`` = ``didChangeConfiguration``
                    member _.``didChangeWatchedFiles`` = ``didChangeWatchedFiles``
                    member _.``symbol`` = ``symbol``
                    member _.``executeCommand`` = ``executeCommand``
                    member _.``workspaceFolders`` = ``workspaceFolders``
                    member _.``configuration`` = ``configuration``
                    member _.``semanticTokens`` = ``semanticTokens``
                    member _.``codeLens`` = ``codeLens``
                    member _.``fileOperations`` = ``fileOperations``
                    member _.``inlineValue`` = ``inlineValue``
                    member _.``inlayHint`` = ``inlayHint``
                    member _.``diagnostics`` = ``diagnostics``
                    member _.``foldingRange`` = ``foldingRange``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``applyEdit`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``applyEdit`` ->
                            ``json writer``.WriteBoolean("applyEdit", ``applyEdit``)

                        match ``workspaceEdit`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workspaceEdit`` ->
                            ``json writer``.WritePropertyName("workspaceEdit")
                            ``workspaceEdit``.WriteTo(``json writer``)

                        match ``didChangeConfiguration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didChangeConfiguration`` ->
                            ``json writer``.WritePropertyName("didChangeConfiguration")
                            ``didChangeConfiguration``.WriteTo(``json writer``)

                        match ``didChangeWatchedFiles`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didChangeWatchedFiles`` ->
                            ``json writer``.WritePropertyName("didChangeWatchedFiles")
                            ``didChangeWatchedFiles``.WriteTo(``json writer``)

                        match ``symbol`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``symbol`` ->
                            ``json writer``.WritePropertyName("symbol")
                            ``symbol``.WriteTo(``json writer``)

                        match ``executeCommand`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``executeCommand`` ->
                            ``json writer``.WritePropertyName("executeCommand")
                            ``executeCommand``.WriteTo(``json writer``)

                        match ``workspaceFolders`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workspaceFolders`` ->
                            ``json writer``.WriteBoolean("workspaceFolders", ``workspaceFolders``)

                        match ``configuration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``configuration`` ->
                            ``json writer``.WriteBoolean("configuration", ``configuration``)

                        match ``semanticTokens`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``semanticTokens`` ->
                            ``json writer``.WritePropertyName("semanticTokens")
                            ``semanticTokens``.WriteTo(``json writer``)

                        match ``codeLens`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeLens`` ->
                            ``json writer``.WritePropertyName("codeLens")
                            ``codeLens``.WriteTo(``json writer``)

                        match ``fileOperations`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``fileOperations`` ->
                            ``json writer``.WritePropertyName("fileOperations")
                            ``fileOperations``.WriteTo(``json writer``)

                        match ``inlineValue`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlineValue`` ->
                            ``json writer``.WritePropertyName("inlineValue")
                            ``inlineValue``.WriteTo(``json writer``)

                        match ``inlayHint`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlayHint`` ->
                            ``json writer``.WritePropertyName("inlayHint")
                            ``inlayHint``.WriteTo(``json writer``)

                        match ``diagnostics`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``diagnostics`` ->
                            ``json writer``.WritePropertyName("diagnostics")
                            ``diagnostics``.WriteTo(``json writer``)

                        match ``foldingRange`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``foldingRange`` ->
                            ``json writer``.WritePropertyName("foldingRange")
                            ``foldingRange``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "applyEdit" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspaceEdit" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceEditClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didChangeConfiguration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DidChangeConfigurationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didChangeWatchedFiles" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DidChangeWatchedFilesClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "symbol" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceSymbolClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "executeCommand" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ExecuteCommandClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspaceFolders" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "configuration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "semanticTokens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SemanticTokensWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "codeLens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeLensWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "fileOperations" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlineValue" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineValueWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlayHint" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlayHintWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "diagnostics" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DiagnosticWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "foldingRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FoldingRangeWorkspaceClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``synchronization``: TextDocumentSyncClientCapabilities option
    abstract ``completion``: CompletionClientCapabilities option
    abstract ``hover``: HoverClientCapabilities option
    abstract ``signatureHelp``: SignatureHelpClientCapabilities option
    abstract ``declaration``: DeclarationClientCapabilities option
    abstract ``definition``: DefinitionClientCapabilities option
    abstract ``typeDefinition``: TypeDefinitionClientCapabilities option
    abstract ``implementation``: ImplementationClientCapabilities option
    abstract ``references``: ReferenceClientCapabilities option
    abstract ``documentHighlight``: DocumentHighlightClientCapabilities option
    abstract ``documentSymbol``: DocumentSymbolClientCapabilities option
    abstract ``codeAction``: CodeActionClientCapabilities option
    abstract ``codeLens``: CodeLensClientCapabilities option
    abstract ``documentLink``: DocumentLinkClientCapabilities option
    abstract ``colorProvider``: DocumentColorClientCapabilities option
    abstract ``formatting``: DocumentFormattingClientCapabilities option
    abstract ``rangeFormatting``: DocumentRangeFormattingClientCapabilities option
    abstract ``onTypeFormatting``: DocumentOnTypeFormattingClientCapabilities option
    abstract ``rename``: RenameClientCapabilities option
    abstract ``foldingRange``: FoldingRangeClientCapabilities option
    abstract ``selectionRange``: SelectionRangeClientCapabilities option
    abstract ``publishDiagnostics``: PublishDiagnosticsClientCapabilities option
    abstract ``callHierarchy``: CallHierarchyClientCapabilities option
    abstract ``semanticTokens``: SemanticTokensClientCapabilities option
    abstract ``linkedEditingRange``: LinkedEditingRangeClientCapabilities option
    abstract ``moniker``: MonikerClientCapabilities option
    abstract ``typeHierarchy``: TypeHierarchyClientCapabilities option
    abstract ``inlineValue``: InlineValueClientCapabilities option
    abstract ``inlayHint``: InlayHintClientCapabilities option
    abstract ``diagnostic``: DiagnosticClientCapabilities option
    abstract ``inlineCompletion``: InlineCompletionClientCapabilities option

/// Text document specific client capabilities.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Defines which synchronization capabilities the client supports.
    member _.Synchronization =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``synchronization`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("synchronization") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextDocumentSyncClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/completion` request.
    member _.Completion =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``completion`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completion") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/hover` request.
    member _.Hover =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``hover`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("hover") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(HoverClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/signatureHelp` request.
    member _.SignatureHelp =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``signatureHelp`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("signatureHelp") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelpClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/declaration` request.
    ///
    /// @since 3.14.0
    member _.Declaration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``declaration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("declaration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DeclarationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/definition` request.
    member _.Definition =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``definition`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("definition") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DefinitionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/typeDefinition` request.
    ///
    /// @since 3.6.0
    member _.TypeDefinition =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``typeDefinition`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeDefinition") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TypeDefinitionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/implementation` request.
    ///
    /// @since 3.6.0
    member _.Implementation =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``implementation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("implementation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ImplementationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/references` request.
    member _.References =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``references`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("references") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ReferenceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentHighlight` request.
    member _.DocumentHighlight =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentHighlight`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentHighlight") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentHighlightClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentSymbol` request.
    member _.DocumentSymbol =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentSymbol`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentSymbol") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentSymbolClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/codeAction` request.
    member _.CodeAction =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeAction`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeAction") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeActionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/codeLens` request.
    member _.CodeLens =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeLens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeLens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeLensClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentLink` request.
    member _.DocumentLink =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentLink`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentLink") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentLinkClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentColor` and the
    /// `textDocument/colorPresentation` request.
    ///
    /// @since 3.6.0
    member _.ColorProvider =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``colorProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("colorProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentColorClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/formatting` request.
    member _.Formatting =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``formatting`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("formatting") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentFormattingClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/rangeFormatting` request.
    member _.RangeFormatting =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rangeFormatting`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangeFormatting") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentRangeFormattingClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/onTypeFormatting` request.
    member _.OnTypeFormatting =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``onTypeFormatting`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("onTypeFormatting") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentOnTypeFormattingClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/rename` request.
    member _.Rename =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(RenameClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/foldingRange` request.
    ///
    /// @since 3.10.0
    member _.FoldingRange =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``foldingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FoldingRangeClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/selectionRange` request.
    ///
    /// @since 3.15.0
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``selectionRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selectionRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SelectionRangeClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/publishDiagnostics` notification.
    member _.PublishDiagnostics =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``publishDiagnostics`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("publishDiagnostics") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(PublishDiagnosticsClientCapabilities.FromElement(prop))

    /// Capabilities specific to the various call hierarchy requests.
    ///
    /// @since 3.16.0
    member _.CallHierarchy =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``callHierarchy`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("callHierarchy") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CallHierarchyClientCapabilities.FromElement(prop))

    /// Capabilities specific to the various semantic token request.
    ///
    /// @since 3.16.0
    member _.SemanticTokens =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``semanticTokens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("semanticTokens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SemanticTokensClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/linkedEditingRange` request.
    ///
    /// @since 3.16.0
    member _.LinkedEditingRange =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``linkedEditingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkedEditingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LinkedEditingRangeClientCapabilities.FromElement(prop))

    /// Client capabilities specific to the `textDocument/moniker` request.
    ///
    /// @since 3.16.0
    member _.Moniker =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``moniker`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("moniker") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(MonikerClientCapabilities.FromElement(prop))

    /// Capabilities specific to the various type hierarchy requests.
    ///
    /// @since 3.17.0
    member _.TypeHierarchy =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``typeHierarchy`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeHierarchy") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TypeHierarchyClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/inlineValue` request.
    ///
    /// @since 3.17.0
    member _.InlineValue =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlineValue`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineValue") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlineValueClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/inlayHint` request.
    ///
    /// @since 3.17.0
    member _.InlayHint =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlayHint`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlayHint") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlayHintClientCapabilities.FromElement(prop))

    /// Capabilities specific to the diagnostic pull model.
    ///
    /// @since 3.17.0
    member _.Diagnostic =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``diagnostic`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnostic") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DiagnosticClientCapabilities.FromElement(prop))

    /// Client capabilities specific to inline completions.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.InlineCompletion =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``inlineCompletion`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineCompletion") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlineCompletionClientCapabilities.FromElement(prop))

    static member Create
        (
            ?``synchronization``: TextDocumentSyncClientCapabilities,
            ?``completion``: CompletionClientCapabilities,
            ?``hover``: HoverClientCapabilities,
            ?``signatureHelp``: SignatureHelpClientCapabilities,
            ?``declaration``: DeclarationClientCapabilities,
            ?``definition``: DefinitionClientCapabilities,
            ?``typeDefinition``: TypeDefinitionClientCapabilities,
            ?``implementation``: ImplementationClientCapabilities,
            ?``references``: ReferenceClientCapabilities,
            ?``documentHighlight``: DocumentHighlightClientCapabilities,
            ?``documentSymbol``: DocumentSymbolClientCapabilities,
            ?``codeAction``: CodeActionClientCapabilities,
            ?``codeLens``: CodeLensClientCapabilities,
            ?``documentLink``: DocumentLinkClientCapabilities,
            ?``colorProvider``: DocumentColorClientCapabilities,
            ?``formatting``: DocumentFormattingClientCapabilities,
            ?``rangeFormatting``: DocumentRangeFormattingClientCapabilities,
            ?``onTypeFormatting``: DocumentOnTypeFormattingClientCapabilities,
            ?``rename``: RenameClientCapabilities,
            ?``foldingRange``: FoldingRangeClientCapabilities,
            ?``selectionRange``: SelectionRangeClientCapabilities,
            ?``publishDiagnostics``: PublishDiagnosticsClientCapabilities,
            ?``callHierarchy``: CallHierarchyClientCapabilities,
            ?``semanticTokens``: SemanticTokensClientCapabilities,
            ?``linkedEditingRange``: LinkedEditingRangeClientCapabilities,
            ?``moniker``: MonikerClientCapabilities,
            ?``typeHierarchy``: TypeHierarchyClientCapabilities,
            ?``inlineValue``: InlineValueClientCapabilities,
            ?``inlayHint``: InlayHintClientCapabilities,
            ?``diagnostic``: DiagnosticClientCapabilities,
            ?``inlineCompletion``: InlineCompletionClientCapabilities
        ) =
        TextDocumentClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentClientCapabilities with
                    member _.``synchronization`` = ``synchronization``
                    member _.``completion`` = ``completion``
                    member _.``hover`` = ``hover``
                    member _.``signatureHelp`` = ``signatureHelp``
                    member _.``declaration`` = ``declaration``
                    member _.``definition`` = ``definition``
                    member _.``typeDefinition`` = ``typeDefinition``
                    member _.``implementation`` = ``implementation``
                    member _.``references`` = ``references``
                    member _.``documentHighlight`` = ``documentHighlight``
                    member _.``documentSymbol`` = ``documentSymbol``
                    member _.``codeAction`` = ``codeAction``
                    member _.``codeLens`` = ``codeLens``
                    member _.``documentLink`` = ``documentLink``
                    member _.``colorProvider`` = ``colorProvider``
                    member _.``formatting`` = ``formatting``
                    member _.``rangeFormatting`` = ``rangeFormatting``
                    member _.``onTypeFormatting`` = ``onTypeFormatting``
                    member _.``rename`` = ``rename``
                    member _.``foldingRange`` = ``foldingRange``
                    member _.``selectionRange`` = ``selectionRange``
                    member _.``publishDiagnostics`` = ``publishDiagnostics``
                    member _.``callHierarchy`` = ``callHierarchy``
                    member _.``semanticTokens`` = ``semanticTokens``
                    member _.``linkedEditingRange`` = ``linkedEditingRange``
                    member _.``moniker`` = ``moniker``
                    member _.``typeHierarchy`` = ``typeHierarchy``
                    member _.``inlineValue`` = ``inlineValue``
                    member _.``inlayHint`` = ``inlayHint``
                    member _.``diagnostic`` = ``diagnostic``
                    member _.``inlineCompletion`` = ``inlineCompletion``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``synchronization`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``synchronization`` ->
                            ``json writer``.WritePropertyName("synchronization")
                            ``synchronization``.WriteTo(``json writer``)

                        match ``completion`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``completion`` ->
                            ``json writer``.WritePropertyName("completion")
                            ``completion``.WriteTo(``json writer``)

                        match ``hover`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``hover`` ->
                            ``json writer``.WritePropertyName("hover")
                            ``hover``.WriteTo(``json writer``)

                        match ``signatureHelp`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``signatureHelp`` ->
                            ``json writer``.WritePropertyName("signatureHelp")
                            ``signatureHelp``.WriteTo(``json writer``)

                        match ``declaration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``declaration`` ->
                            ``json writer``.WritePropertyName("declaration")
                            ``declaration``.WriteTo(``json writer``)

                        match ``definition`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``definition`` ->
                            ``json writer``.WritePropertyName("definition")
                            ``definition``.WriteTo(``json writer``)

                        match ``typeDefinition`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``typeDefinition`` ->
                            ``json writer``.WritePropertyName("typeDefinition")
                            ``typeDefinition``.WriteTo(``json writer``)

                        match ``implementation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``implementation`` ->
                            ``json writer``.WritePropertyName("implementation")
                            ``implementation``.WriteTo(``json writer``)

                        match ``references`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``references`` ->
                            ``json writer``.WritePropertyName("references")
                            ``references``.WriteTo(``json writer``)

                        match ``documentHighlight`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentHighlight`` ->
                            ``json writer``.WritePropertyName("documentHighlight")
                            ``documentHighlight``.WriteTo(``json writer``)

                        match ``documentSymbol`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentSymbol`` ->
                            ``json writer``.WritePropertyName("documentSymbol")
                            ``documentSymbol``.WriteTo(``json writer``)

                        match ``codeAction`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeAction`` ->
                            ``json writer``.WritePropertyName("codeAction")
                            ``codeAction``.WriteTo(``json writer``)

                        match ``codeLens`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeLens`` ->
                            ``json writer``.WritePropertyName("codeLens")
                            ``codeLens``.WriteTo(``json writer``)

                        match ``documentLink`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentLink`` ->
                            ``json writer``.WritePropertyName("documentLink")
                            ``documentLink``.WriteTo(``json writer``)

                        match ``colorProvider`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``colorProvider`` ->
                            ``json writer``.WritePropertyName("colorProvider")
                            ``colorProvider``.WriteTo(``json writer``)

                        match ``formatting`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``formatting`` ->
                            ``json writer``.WritePropertyName("formatting")
                            ``formatting``.WriteTo(``json writer``)

                        match ``rangeFormatting`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rangeFormatting`` ->
                            ``json writer``.WritePropertyName("rangeFormatting")
                            ``rangeFormatting``.WriteTo(``json writer``)

                        match ``onTypeFormatting`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``onTypeFormatting`` ->
                            ``json writer``.WritePropertyName("onTypeFormatting")
                            ``onTypeFormatting``.WriteTo(``json writer``)

                        match ``rename`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rename`` ->
                            ``json writer``.WritePropertyName("rename")
                            ``rename``.WriteTo(``json writer``)

                        match ``foldingRange`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``foldingRange`` ->
                            ``json writer``.WritePropertyName("foldingRange")
                            ``foldingRange``.WriteTo(``json writer``)

                        match ``selectionRange`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``selectionRange`` ->
                            ``json writer``.WritePropertyName("selectionRange")
                            ``selectionRange``.WriteTo(``json writer``)

                        match ``publishDiagnostics`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``publishDiagnostics`` ->
                            ``json writer``.WritePropertyName("publishDiagnostics")
                            ``publishDiagnostics``.WriteTo(``json writer``)

                        match ``callHierarchy`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``callHierarchy`` ->
                            ``json writer``.WritePropertyName("callHierarchy")
                            ``callHierarchy``.WriteTo(``json writer``)

                        match ``semanticTokens`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``semanticTokens`` ->
                            ``json writer``.WritePropertyName("semanticTokens")
                            ``semanticTokens``.WriteTo(``json writer``)

                        match ``linkedEditingRange`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``linkedEditingRange`` ->
                            ``json writer``.WritePropertyName("linkedEditingRange")
                            ``linkedEditingRange``.WriteTo(``json writer``)

                        match ``moniker`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``moniker`` ->
                            ``json writer``.WritePropertyName("moniker")
                            ``moniker``.WriteTo(``json writer``)

                        match ``typeHierarchy`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``typeHierarchy`` ->
                            ``json writer``.WritePropertyName("typeHierarchy")
                            ``typeHierarchy``.WriteTo(``json writer``)

                        match ``inlineValue`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlineValue`` ->
                            ``json writer``.WritePropertyName("inlineValue")
                            ``inlineValue``.WriteTo(``json writer``)

                        match ``inlayHint`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlayHint`` ->
                            ``json writer``.WritePropertyName("inlayHint")
                            ``inlayHint``.WriteTo(``json writer``)

                        match ``diagnostic`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``diagnostic`` ->
                            ``json writer``.WritePropertyName("diagnostic")
                            ``diagnostic``.WriteTo(``json writer``)

                        match ``inlineCompletion`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``inlineCompletion`` ->
                            ``json writer``.WritePropertyName("inlineCompletion")
                            ``inlineCompletion``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "synchronization" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentSyncClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "completion" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CompletionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "hover" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (HoverClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "signatureHelp" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SignatureHelpClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "declaration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DeclarationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "definition" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DefinitionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "typeDefinition" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeDefinitionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "implementation" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ImplementationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "references" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ReferenceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "documentHighlight" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentHighlightClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "documentSymbol" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentSymbolClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "codeAction" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeActionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "codeLens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeLensClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "documentLink" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentLinkClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "colorProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentColorClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "formatting" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentFormattingClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "rangeFormatting" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentRangeFormattingClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "onTypeFormatting" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentOnTypeFormattingClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "rename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (RenameClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "foldingRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FoldingRangeClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "selectionRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SelectionRangeClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "publishDiagnostics" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (PublishDiagnosticsClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "callHierarchy" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CallHierarchyClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "semanticTokens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SemanticTokensClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkedEditingRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LinkedEditingRangeClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "moniker" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (MonikerClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "typeHierarchy" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeHierarchyClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlineValue" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineValueClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlayHint" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlayHintClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "diagnostic" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DiagnosticClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlineCompletion" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineCompletionClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextDocumentClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private INotebookDocumentClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``synchronization``: NotebookDocumentSyncClientCapabilities

/// Capabilities specific to the notebook document support.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookDocumentClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Capabilities specific to notebook document synchronization
    ///
    /// @since 3.17.0
    member _.Synchronization =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``synchronization``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("synchronization")
            NotebookDocumentSyncClientCapabilities.FromElement(prop)

    static member Create(``synchronization``: NotebookDocumentSyncClientCapabilities) =
        NotebookDocumentClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookDocumentClientCapabilities with
                    member _.``synchronization`` = ``synchronization``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("synchronization")
                        ``synchronization``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "synchronization" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentSyncClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(NotebookDocumentClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWindowClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``workDoneProgress``: global.FSharp.Core.bool option
    abstract ``showMessage``: ShowMessageRequestClientCapabilities option
    abstract ``showDocument``: ShowDocumentClientCapabilities option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WindowClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWindowClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WindowClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// It indicates whether the client supports server initiated
    /// progress using the `window/workDoneProgress/create` request.
    ///
    /// The capability also controls Whether client supports handling
    /// of progress notifications. If set servers are allowed to report a
    /// `workDoneProgress` property in the request specific server
    /// capabilities.
    ///
    /// @since 3.15.0
    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Capabilities specific to the showMessage request.
    ///
    /// @since 3.16.0
    member _.ShowMessage =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``showMessage`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("showMessage") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ShowMessageRequestClientCapabilities.FromElement(prop))

    /// Capabilities specific to the showDocument request.
    ///
    /// @since 3.16.0
    member _.ShowDocument =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``showDocument`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("showDocument") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ShowDocumentClientCapabilities.FromElement(prop))

    static member Create
        (
            ?``workDoneProgress``: global.FSharp.Core.bool,
            ?``showMessage``: ShowMessageRequestClientCapabilities,
            ?``showDocument``: ShowDocumentClientCapabilities
        ) =
        WindowClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWindowClientCapabilities with
                    member _.``workDoneProgress`` = ``workDoneProgress``
                    member _.``showMessage`` = ``showMessage``
                    member _.``showDocument`` = ``showDocument``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``workDoneProgress`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``workDoneProgress`` ->
                            ``json writer``.WriteBoolean("workDoneProgress", ``workDoneProgress``)

                        match ``showMessage`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``showMessage`` ->
                            ``json writer``.WritePropertyName("showMessage")
                            ``showMessage``.WriteTo(``json writer``)

                        match ``showDocument`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``showDocument`` ->
                            ``json writer``.WritePropertyName("showDocument")
                            ``showDocument``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "showMessage" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ShowMessageRequestClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "showDocument" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ShowDocumentClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(WindowClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IGeneralClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``staleRequestSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``regularExpressions``: RegularExpressionsClientCapabilities option
    abstract ``markdown``: MarkdownClientCapabilities option
    abstract ``positionEncodings``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// General client capabilities.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type GeneralClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IGeneralClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        GeneralClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Client capability that signals how the client
    /// handles stale requests (e.g. a request
    /// for which the client will not process the response
    /// anymore since the information is outdated).
    ///
    /// @since 3.17.0
    member _.StaleRequestSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``staleRequestSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("staleRequestSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Client capabilities specific to regular expressions.
    ///
    /// @since 3.16.0
    member _.RegularExpressions =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``regularExpressions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("regularExpressions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(RegularExpressionsClientCapabilities.FromElement(prop))

    /// Client capabilities specific to the client&apos;s markdown parser.
    ///
    /// @since 3.16.0
    member _.Markdown =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``markdown`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("markdown") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(MarkdownClientCapabilities.FromElement(prop))

    /// The position encodings supported by the client. Client and server
    /// have to agree on the same position encoding to ensure that offsets
    /// (e.g. character position in a line) are interpreted the same on both
    /// sides.
    ///
    /// To keep the protocol backwards compatible the following applies: if
    /// the value &apos;utf-16&apos; is missing from the array of position encodings
    /// servers can assume that the client supports UTF-16. UTF-16 is
    /// therefore a mandatory encoding.
    ///
    /// If omitted it defaults to [&apos;utf-16&apos;].
    ///
    /// Implementation considerations: since the conversion from one encoding
    /// into another requires the content of the file / line the conversion
    /// is best done where the file is read which is usually on the server
    /// side.
    ///
    /// @since 3.17.0
    member _.PositionEncodings =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``positionEncodings`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("positionEncodings") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``staleRequestSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``regularExpressions``: RegularExpressionsClientCapabilities,
            ?``markdown``: MarkdownClientCapabilities,
            ?``positionEncodings``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        GeneralClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IGeneralClientCapabilities with
                    member _.``staleRequestSupport`` = ``staleRequestSupport``
                    member _.``regularExpressions`` = ``regularExpressions``
                    member _.``markdown`` = ``markdown``
                    member _.``positionEncodings`` = ``positionEncodings``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``staleRequestSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``staleRequestSupport`` ->
                            ``json writer``.WritePropertyName("staleRequestSupport")
                            ``staleRequestSupport``.WriteTo(``json writer``)

                        match ``regularExpressions`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``regularExpressions`` ->
                            ``json writer``.WritePropertyName("regularExpressions")
                            ``regularExpressions``.WriteTo(``json writer``)

                        match ``markdown`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``markdown`` ->
                            ``json writer``.WritePropertyName("markdown")
                            ``markdown``.WriteTo(``json writer``)

                        match ``positionEncodings`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``positionEncodings`` ->
                            ``json writer``.WritePropertyName("positionEncodings")
                            ``positionEncodings``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(GeneralClientCapabilities.FromElement(element))

type private IRelativePattern =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``baseUri``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``pattern``: Pattern

/// A relative pattern is a helper to construct glob patterns that are matched
/// relatively to a base URI. The common value for a `baseUri` is a workspace
/// folder root, but it can be another absolute URI as well.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RelativePattern private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRelativePattern>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RelativePattern(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A workspace folder or a base URI to which this pattern will be matched
    /// against relatively.
    member _.BaseUri =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``baseUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("baseUri")
            LspJsonBacking.Element prop

    /// The actual glob pattern;
    member _.Pattern =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``pattern``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("pattern")
            (global.Amongonz.LspTypes.LspString.FromElement(prop): Pattern)

    static member Create
        (``baseUri``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>, ``pattern``: Pattern)
        =
        RelativePattern(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRelativePattern with
                    member _.``baseUri`` = ``baseUri``
                    member _.``pattern`` = ``pattern``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("baseUri")
                        ``baseUri``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("pattern")
                        ``pattern``.WriteTo(``json writer``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RelativePattern.FromElement(element))

type private IWorkspaceEditClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``documentChanges``: global.FSharp.Core.bool option
    abstract ``resourceOperations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``failureHandling``: FailureHandlingKind option
    abstract ``normalizesLineEndings``: global.FSharp.Core.bool option
    abstract ``changeAnnotationSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceEditClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceEditClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceEditClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client supports versioned document changes in `WorkspaceEdit`s
    member _.DocumentChanges =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``documentChanges`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentChanges") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The resource operations the client supports. Clients should at least
    /// support &apos;create&apos;, &apos;rename&apos; and &apos;delete&apos; files and folders.
    ///
    /// @since 3.13.0
    member _.ResourceOperations =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resourceOperations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resourceOperations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The failure handling strategy of a client if applying the workspace edit
    /// fails.
    ///
    /// @since 3.13.0
    member _.FailureHandling =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``failureHandling`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("failureHandling") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FailureHandlingKind.FromElement(prop))

    /// Whether the client normalizes line endings to the client specific
    /// setting.
    /// If set to `true` the client will normalize line ending characters
    /// in a workspace edit to the client-specified new line
    /// character.
    ///
    /// @since 3.16.0
    member _.NormalizesLineEndings =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``normalizesLineEndings`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("normalizesLineEndings") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client in general supports change annotations on text edits,
    /// create file, rename file and delete file changes.
    ///
    /// @since 3.16.0
    member _.ChangeAnnotationSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``changeAnnotationSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changeAnnotationSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``documentChanges``: global.FSharp.Core.bool,
            ?``resourceOperations``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``failureHandling``: FailureHandlingKind,
            ?``normalizesLineEndings``: global.FSharp.Core.bool,
            ?``changeAnnotationSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        WorkspaceEditClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceEditClientCapabilities with
                    member _.``documentChanges`` = ``documentChanges``
                    member _.``resourceOperations`` = ``resourceOperations``
                    member _.``failureHandling`` = ``failureHandling``
                    member _.``normalizesLineEndings`` = ``normalizesLineEndings``
                    member _.``changeAnnotationSupport`` = ``changeAnnotationSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``documentChanges`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``documentChanges`` ->
                            ``json writer``.WriteBoolean("documentChanges", ``documentChanges``)

                        match ``resourceOperations`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resourceOperations`` ->
                            ``json writer``.WritePropertyName("resourceOperations")
                            ``resourceOperations``.WriteTo(``json writer``)

                        match ``failureHandling`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``failureHandling`` ->
                            ``json writer``.WritePropertyName("failureHandling")
                            ``failureHandling``.WriteTo(``json writer``)

                        match ``normalizesLineEndings`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``normalizesLineEndings`` ->
                            ``json writer``.WriteBoolean("normalizesLineEndings", ``normalizesLineEndings``)

                        match ``changeAnnotationSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``changeAnnotationSupport`` ->
                            ``json writer``.WritePropertyName("changeAnnotationSupport")
                            ``changeAnnotationSupport``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceEditClientCapabilities.FromElement(element))

type private IDidChangeConfigurationClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeConfigurationClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeConfigurationClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeConfigurationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Did change configuration notification supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DidChangeConfigurationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeConfigurationClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DidChangeConfigurationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDidChangeWatchedFilesClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``relativePatternSupport``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWatchedFilesClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDidChangeWatchedFilesClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWatchedFilesClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Did change watched files notification supports dynamic registration. Please note
    /// that the current protocol doesn&apos;t support static configuration for file changes
    /// from the server side.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client has support for {@link  RelativePattern relative pattern}
    /// or not.
    ///
    /// @since 3.17.0
    member _.RelativePatternSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``relativePatternSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relativePatternSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``relativePatternSupport``: global.FSharp.Core.bool) =
        DidChangeWatchedFilesClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDidChangeWatchedFilesClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``relativePatternSupport`` = ``relativePatternSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``relativePatternSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``relativePatternSupport`` ->
                            ``json writer``.WriteBoolean("relativePatternSupport", ``relativePatternSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "relativePatternSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DidChangeWatchedFilesClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IWorkspaceSymbolClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Client capabilities for a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IWorkspaceSymbolClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Symbol request supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
    member _.SymbolKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``symbolKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("symbolKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports tags on `SymbolInformation`.
    /// Clients supporting tags have to handle unknown tags gracefully.
    ///
    /// @since 3.16.0
    member _.TagSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tagSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tagSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client support partial workspace symbols. The client will send the
    /// request `workspaceSymbol/resolve` to the server to resolve additional
    /// properties.
    ///
    /// @since 3.17.0
    member _.ResolveSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        WorkspaceSymbolClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IWorkspaceSymbolClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``symbolKind`` = ``symbolKind``
                    member _.``tagSupport`` = ``tagSupport``
                    member _.``resolveSupport`` = ``resolveSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``symbolKind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``symbolKind`` ->
                            ``json writer``.WritePropertyName("symbolKind")
                            ``symbolKind``.WriteTo(``json writer``)

                        match ``tagSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tagSupport`` ->
                            ``json writer``.WritePropertyName("tagSupport")
                            ``tagSupport``.WriteTo(``json writer``)

                        match ``resolveSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveSupport`` ->
                            ``json writer``.WritePropertyName("resolveSupport")
                            ``resolveSupport``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceSymbolClientCapabilities.FromElement(element))

type private IExecuteCommandClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// The client capabilities of a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IExecuteCommandClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Execute command supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        ExecuteCommandClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IExecuteCommandClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ExecuteCommandClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISemanticTokensWorkspaceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``refreshSupport``: global.FSharp.Core.bool option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensWorkspaceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensWorkspaceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from
    /// the server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// semantic tokens currently shown. It should be used with absolute care
    /// and is useful for situation where a server for example detects a project
    /// wide change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        SemanticTokensWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensWorkspaceClientCapabilities with
                    member _.``refreshSupport`` = ``refreshSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``refreshSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``refreshSupport`` ->
                            ``json writer``.WriteBoolean("refreshSupport", ``refreshSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SemanticTokensWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICodeLensWorkspaceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``refreshSupport``: global.FSharp.Core.bool option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensWorkspaceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeLensWorkspaceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from the
    /// server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// code lenses currently shown. It should be used with absolute care and is
    /// useful for situation where a server for example detect a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        CodeLensWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeLensWorkspaceClientCapabilities with
                    member _.``refreshSupport`` = ``refreshSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``refreshSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``refreshSupport`` ->
                            ``json writer``.WriteBoolean("refreshSupport", ``refreshSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CodeLensWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFileOperationClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``didCreate``: global.FSharp.Core.bool option
    abstract ``willCreate``: global.FSharp.Core.bool option
    abstract ``didRename``: global.FSharp.Core.bool option
    abstract ``willRename``: global.FSharp.Core.bool option
    abstract ``didDelete``: global.FSharp.Core.bool option
    abstract ``willDelete``: global.FSharp.Core.bool option

/// Capabilities relating to events from file operations by the user in the client.
///
/// These events do not come from the file system, they come from user operations
/// like renaming a file in the UI.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFileOperationClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client supports dynamic registration for file requests/notifications.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending didCreateFiles notifications.
    member _.DidCreate =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending willCreateFiles requests.
    member _.WillCreate =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending didRenameFiles notifications.
    member _.DidRename =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending willRenameFiles requests.
    member _.WillRename =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending didDeleteFiles notifications.
    member _.DidDelete =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending willDeleteFiles requests.
    member _.WillDelete =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``didCreate``: global.FSharp.Core.bool,
            ?``willCreate``: global.FSharp.Core.bool,
            ?``didRename``: global.FSharp.Core.bool,
            ?``willRename``: global.FSharp.Core.bool,
            ?``didDelete``: global.FSharp.Core.bool,
            ?``willDelete``: global.FSharp.Core.bool
        ) =
        FileOperationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFileOperationClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``didCreate`` = ``didCreate``
                    member _.``willCreate`` = ``willCreate``
                    member _.``didRename`` = ``didRename``
                    member _.``willRename`` = ``willRename``
                    member _.``didDelete`` = ``didDelete``
                    member _.``willDelete`` = ``willDelete``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``didCreate`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didCreate`` ->
                            ``json writer``.WriteBoolean("didCreate", ``didCreate``)

                        match ``willCreate`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willCreate`` ->
                            ``json writer``.WriteBoolean("willCreate", ``willCreate``)

                        match ``didRename`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didRename`` ->
                            ``json writer``.WriteBoolean("didRename", ``didRename``)

                        match ``willRename`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willRename`` ->
                            ``json writer``.WriteBoolean("willRename", ``willRename``)

                        match ``didDelete`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didDelete`` ->
                            ``json writer``.WriteBoolean("didDelete", ``didDelete``)

                        match ``willDelete`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willDelete`` ->
                            ``json writer``.WriteBoolean("willDelete", ``willDelete``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FileOperationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueWorkspaceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``refreshSupport``: global.FSharp.Core.bool option

/// Client workspace capabilities specific to inline values.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueWorkspaceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueWorkspaceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from the
    /// server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// inline values currently shown. It should be used with absolute care and is
    /// useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        InlineValueWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueWorkspaceClientCapabilities with
                    member _.``refreshSupport`` = ``refreshSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``refreshSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``refreshSupport`` ->
                            ``json writer``.WriteBoolean("refreshSupport", ``refreshSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlayHintWorkspaceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``refreshSupport``: global.FSharp.Core.bool option

/// Client workspace capabilities specific to inlay hints.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintWorkspaceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlayHintWorkspaceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from
    /// the server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// inlay hints currently shown. It should be used with absolute care and
    /// is useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        InlayHintWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlayHintWorkspaceClientCapabilities with
                    member _.``refreshSupport`` = ``refreshSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``refreshSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``refreshSupport`` ->
                            ``json writer``.WriteBoolean("refreshSupport", ``refreshSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlayHintWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDiagnosticWorkspaceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``refreshSupport``: global.FSharp.Core.bool option

/// Workspace client capabilities specific to diagnostic pull requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticWorkspaceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDiagnosticWorkspaceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from
    /// the server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// pulled diagnostics currently shown. It should be used with absolute care and
    /// is useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        DiagnosticWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDiagnosticWorkspaceClientCapabilities with
                    member _.``refreshSupport`` = ``refreshSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``refreshSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``refreshSupport`` ->
                            ``json writer``.WriteBoolean("refreshSupport", ``refreshSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFoldingRangeWorkspaceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``refreshSupport``: global.FSharp.Core.bool option

/// Client workspace capabilities specific to folding ranges
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeWorkspaceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFoldingRangeWorkspaceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from the
    /// server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// folding ranges currently shown. It should be used with absolute care and is
    /// useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        FoldingRangeWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFoldingRangeWorkspaceClientCapabilities with
                    member _.``refreshSupport`` = ``refreshSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``refreshSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``refreshSupport`` ->
                            ``json writer``.WriteBoolean("refreshSupport", ``refreshSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FoldingRangeWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITextDocumentSyncClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``willSave``: global.FSharp.Core.bool option
    abstract ``willSaveWaitUntil``: global.FSharp.Core.bool option
    abstract ``didSave``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentSyncClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITextDocumentSyncClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentSyncClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether text document synchronization supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports sending will save notifications.
    member _.WillSave =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willSave`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSave") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports sending a will save request and
    /// waits for a response providing text edits which will
    /// be applied to the document before it is saved.
    member _.WillSaveWaitUntil =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``willSaveWaitUntil`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSaveWaitUntil") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports did save notifications.
    member _.DidSave =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``didSave`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didSave") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``willSave``: global.FSharp.Core.bool,
            ?``willSaveWaitUntil``: global.FSharp.Core.bool,
            ?``didSave``: global.FSharp.Core.bool
        ) =
        TextDocumentSyncClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITextDocumentSyncClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``willSave`` = ``willSave``
                    member _.``willSaveWaitUntil`` = ``willSaveWaitUntil``
                    member _.``didSave`` = ``didSave``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``willSave`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willSave`` -> ``json writer``.WriteBoolean("willSave", ``willSave``)

                        match ``willSaveWaitUntil`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``willSaveWaitUntil`` ->
                            ``json writer``.WriteBoolean("willSaveWaitUntil", ``willSaveWaitUntil``)

                        match ``didSave`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``didSave`` -> ``json writer``.WriteBoolean("didSave", ``didSave``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willSave" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willSaveWaitUntil" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didSave" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TextDocumentSyncClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ICompletionClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``completionItemKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``insertTextMode``: InsertTextMode option
    abstract ``contextSupport``: global.FSharp.Core.bool option
    abstract ``completionList``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Completion client capabilities
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICompletionClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether completion supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports the following `CompletionItem` specific
    /// capabilities.
    member _.CompletionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``completionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.CompletionItemKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``completionItemKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItemKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Defines how the client handles whitespace and indentation
    /// when accepting a completion item that uses multi line
    /// text in either `insertText` or `textEdit`.
    ///
    /// @since 3.17.0
    member _.InsertTextMode =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``insertTextMode`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertTextMode") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InsertTextMode.FromElement(prop))

    /// The client supports to send additional context information for a
    /// `textDocument/completion` request.
    member _.ContextSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``contextSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("contextSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports the following `CompletionList` specific
    /// capabilities.
    ///
    /// @since 3.17.0
    member _.CompletionList =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``completionList`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionList") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``completionItemKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``insertTextMode``: InsertTextMode,
            ?``contextSupport``: global.FSharp.Core.bool,
            ?``completionList``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        CompletionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICompletionClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``completionItem`` = ``completionItem``
                    member _.``completionItemKind`` = ``completionItemKind``
                    member _.``insertTextMode`` = ``insertTextMode``
                    member _.``contextSupport`` = ``contextSupport``
                    member _.``completionList`` = ``completionList``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``completionItem`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``completionItem`` ->
                            ``json writer``.WritePropertyName("completionItem")
                            ``completionItem``.WriteTo(``json writer``)

                        match ``completionItemKind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``completionItemKind`` ->
                            ``json writer``.WritePropertyName("completionItemKind")
                            ``completionItemKind``.WriteTo(``json writer``)

                        match ``insertTextMode`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``insertTextMode`` ->
                            ``json writer``.WriteNumber("insertTextMode", int ``insertTextMode``)

                        match ``contextSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``contextSupport`` ->
                            ``json writer``.WriteBoolean("contextSupport", ``contextSupport``)

                        match ``completionList`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``completionList`` ->
                            ``json writer``.WritePropertyName("completionList")
                            ``completionList``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionClientCapabilities.FromElement(element))

type private IHoverClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``contentFormat``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IHoverClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether hover supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports the following content formats for the content
    /// property. The order describes the preferred format of the client.
    member _.ContentFormat =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``contentFormat`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("contentFormat") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``contentFormat``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        HoverClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IHoverClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``contentFormat`` = ``contentFormat``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``contentFormat`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``contentFormat`` ->
                            ``json writer``.WritePropertyName("contentFormat")
                            ``contentFormat``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(HoverClientCapabilities.FromElement(element))

type private ISignatureHelpClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``signatureInformation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``contextSupport``: global.FSharp.Core.bool option

/// Client Capabilities for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISignatureHelpClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether signature help supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports the following `SignatureInformation`
    /// specific properties.
    member _.SignatureInformation =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``signatureInformation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("signatureInformation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports to send additional context information for a
    /// `textDocument/signatureHelp` request. A client that opts into
    /// contextSupport will also support the `retriggerCharacters` on
    /// `SignatureHelpOptions`.
    ///
    /// @since 3.15.0
    member _.ContextSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``contextSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("contextSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``signatureInformation``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``contextSupport``: global.FSharp.Core.bool
        ) =
        SignatureHelpClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISignatureHelpClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``signatureInformation`` = ``signatureInformation``
                    member _.``contextSupport`` = ``contextSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``signatureInformation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``signatureInformation`` ->
                            ``json writer``.WritePropertyName("signatureInformation")
                            ``signatureInformation``.WriteTo(``json writer``)

                        match ``contextSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``contextSupport`` ->
                            ``json writer``.WriteBoolean("contextSupport", ``contextSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelpClientCapabilities.FromElement(element))

type private IDeclarationClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``linkSupport``: global.FSharp.Core.bool option

/// @since 3.14.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDeclarationClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether declaration supports dynamic registration. If this is set to `true`
    /// the client supports the new `DeclarationRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of declaration links.
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        DeclarationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDeclarationClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``linkSupport`` = ``linkSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``linkSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``linkSupport`` ->
                            ``json writer``.WriteBoolean("linkSupport", ``linkSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DeclarationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDefinitionClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``linkSupport``: global.FSharp.Core.bool option

/// Client Capabilities for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDefinitionClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether definition supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of definition links.
    ///
    /// @since 3.14.0
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        DefinitionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDefinitionClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``linkSupport`` = ``linkSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``linkSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``linkSupport`` ->
                            ``json writer``.WriteBoolean("linkSupport", ``linkSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DefinitionClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITypeDefinitionClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``linkSupport``: global.FSharp.Core.bool option

/// Since 3.6.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeDefinitionClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `TypeDefinitionRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of definition links.
    ///
    /// Since 3.14.0
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        TypeDefinitionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeDefinitionClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``linkSupport`` = ``linkSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``linkSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``linkSupport`` ->
                            ``json writer``.WriteBoolean("linkSupport", ``linkSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeDefinitionClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IImplementationClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``linkSupport``: global.FSharp.Core.bool option

/// @since 3.6.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IImplementationClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `ImplementationRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of definition links.
    ///
    /// @since 3.14.0
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        ImplementationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IImplementationClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``linkSupport`` = ``linkSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``linkSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``linkSupport`` ->
                            ``json writer``.WriteBoolean("linkSupport", ``linkSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ImplementationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IReferenceClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client Capabilities for a {@link ReferencesRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IReferenceClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether references supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        ReferenceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IReferenceClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ReferenceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentHighlightClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client Capabilities for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentHighlightClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether document highlight supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentHighlightClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentHighlightClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentHighlightClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentSymbolClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``hierarchicalDocumentSymbolSupport``: global.FSharp.Core.bool option
    abstract ``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``labelSupport``: global.FSharp.Core.bool option

/// Client Capabilities for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentSymbolClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether document symbol supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Specific capabilities for the `SymbolKind` in the
    /// `textDocument/documentSymbol` request.
    member _.SymbolKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``symbolKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("symbolKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports hierarchical document symbols.
    member _.HierarchicalDocumentSymbolSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``hierarchicalDocumentSymbolSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("hierarchicalDocumentSymbolSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports tags on `SymbolInformation`. Tags are supported on
    /// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
    /// Clients supporting tags have to handle unknown tags gracefully.
    ///
    /// @since 3.16.0
    member _.TagSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tagSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tagSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports an additional label presented in the UI when
    /// registering a document symbol provider.
    ///
    /// @since 3.16.0
    member _.LabelSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``labelSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("labelSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``hierarchicalDocumentSymbolSupport``: global.FSharp.Core.bool,
            ?``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``labelSupport``: global.FSharp.Core.bool
        ) =
        DocumentSymbolClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentSymbolClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``symbolKind`` = ``symbolKind``
                    member _.``hierarchicalDocumentSymbolSupport`` = ``hierarchicalDocumentSymbolSupport``
                    member _.``tagSupport`` = ``tagSupport``
                    member _.``labelSupport`` = ``labelSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``symbolKind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``symbolKind`` ->
                            ``json writer``.WritePropertyName("symbolKind")
                            ``symbolKind``.WriteTo(``json writer``)

                        match ``hierarchicalDocumentSymbolSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``hierarchicalDocumentSymbolSupport`` ->
                            ``json writer``.WriteBoolean(
                                "hierarchicalDocumentSymbolSupport",
                                ``hierarchicalDocumentSymbolSupport``
                            )

                        match ``tagSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tagSupport`` ->
                            ``json writer``.WritePropertyName("tagSupport")
                            ``tagSupport``.WriteTo(``json writer``)

                        match ``labelSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``labelSupport`` ->
                            ``json writer``.WriteBoolean("labelSupport", ``labelSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentSymbolClientCapabilities.FromElement(element))

type private ICodeActionClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``codeActionLiteralSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``isPreferredSupport``: global.FSharp.Core.bool option
    abstract ``disabledSupport``: global.FSharp.Core.bool option
    abstract ``dataSupport``: global.FSharp.Core.bool option
    abstract ``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``honorsChangeAnnotations``: global.FSharp.Core.bool option

/// The Client Capabilities of a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeActionClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether code action supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client support code action literals of type `CodeAction` as a valid
    /// response of the `textDocument/codeAction` request. If the property is not
    /// set the request can only return `Command` literals.
    ///
    /// @since 3.8.0
    member _.CodeActionLiteralSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeActionLiteralSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionLiteralSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Whether code action supports the `isPreferred` property.
    ///
    /// @since 3.15.0
    member _.IsPreferredSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``isPreferredSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("isPreferredSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether code action supports the `disabled` property.
    ///
    /// @since 3.16.0
    member _.DisabledSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``disabledSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("disabledSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether code action supports the `data` property which is
    /// preserved between a `textDocument/codeAction` and a
    /// `codeAction/resolve` request.
    ///
    /// @since 3.16.0
    member _.DataSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dataSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dataSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports resolving additional code action
    /// properties via a separate `codeAction/resolve` request.
    ///
    /// @since 3.16.0
    member _.ResolveSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Whether the client honors the change annotations in
    /// text edits and resource operations returned via the
    /// `CodeAction#edit` property by for example presenting
    /// the workspace edit in the user interface and asking
    /// for confirmation.
    ///
    /// @since 3.16.0
    member _.HonorsChangeAnnotations =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``honorsChangeAnnotations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("honorsChangeAnnotations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``codeActionLiteralSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``isPreferredSupport``: global.FSharp.Core.bool,
            ?``disabledSupport``: global.FSharp.Core.bool,
            ?``dataSupport``: global.FSharp.Core.bool,
            ?``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``honorsChangeAnnotations``: global.FSharp.Core.bool
        ) =
        CodeActionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeActionClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``codeActionLiteralSupport`` = ``codeActionLiteralSupport``
                    member _.``isPreferredSupport`` = ``isPreferredSupport``
                    member _.``disabledSupport`` = ``disabledSupport``
                    member _.``dataSupport`` = ``dataSupport``
                    member _.``resolveSupport`` = ``resolveSupport``
                    member _.``honorsChangeAnnotations`` = ``honorsChangeAnnotations``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``codeActionLiteralSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeActionLiteralSupport`` ->
                            ``json writer``.WritePropertyName("codeActionLiteralSupport")
                            ``codeActionLiteralSupport``.WriteTo(``json writer``)

                        match ``isPreferredSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``isPreferredSupport`` ->
                            ``json writer``.WriteBoolean("isPreferredSupport", ``isPreferredSupport``)

                        match ``disabledSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``disabledSupport`` ->
                            ``json writer``.WriteBoolean("disabledSupport", ``disabledSupport``)

                        match ``dataSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dataSupport`` ->
                            ``json writer``.WriteBoolean("dataSupport", ``dataSupport``)

                        match ``resolveSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveSupport`` ->
                            ``json writer``.WritePropertyName("resolveSupport")
                            ``resolveSupport``.WriteTo(``json writer``)

                        match ``honorsChangeAnnotations`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``honorsChangeAnnotations`` ->
                            ``json writer``.WriteBoolean("honorsChangeAnnotations", ``honorsChangeAnnotations``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionClientCapabilities.FromElement(element))

type private ICodeLensClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// The client capabilities  of a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICodeLensClientCapabilities>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether code lens supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        CodeLensClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICodeLensClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CodeLensClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentLinkClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``tooltipSupport``: global.FSharp.Core.bool option

/// The client capabilities of a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentLinkClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether document link supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports the `tooltip` property on `DocumentLink`.
    ///
    /// @since 3.15.0
    member _.TooltipSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tooltipSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltipSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``tooltipSupport``: global.FSharp.Core.bool)
        =
        DocumentLinkClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentLinkClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``tooltipSupport`` = ``tooltipSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``tooltipSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tooltipSupport`` ->
                            ``json writer``.WriteBoolean("tooltipSupport", ``tooltipSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "tooltipSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentLinkClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentColorClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentColorClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `DocumentColorRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentColorClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentColorClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentColorClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentFormattingClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client capabilities of a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentFormattingClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether formatting supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentFormattingClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentFormattingClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentFormattingClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentRangeFormattingClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``rangesSupport``: global.FSharp.Core.bool option

/// Client capabilities of a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentRangeFormattingClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether range formatting supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports formatting multiple ranges at once.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RangesSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rangesSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangesSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``rangesSupport``: global.FSharp.Core.bool)
        =
        DocumentRangeFormattingClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentRangeFormattingClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``rangesSupport`` = ``rangesSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``rangesSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rangesSupport`` ->
                            ``json writer``.WriteBoolean("rangesSupport", ``rangesSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "rangesSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentRangeFormattingClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IDocumentOnTypeFormattingClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client capabilities of a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDocumentOnTypeFormattingClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether on type formatting supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentOnTypeFormattingClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDocumentOnTypeFormattingClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentOnTypeFormattingClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IRenameClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``prepareSupport``: global.FSharp.Core.bool option
    abstract ``prepareSupportDefaultBehavior``: PrepareSupportDefaultBehavior option
    abstract ``honorsChangeAnnotations``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRenameClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether rename supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports testing for validity of rename operations
    /// before execution.
    ///
    /// @since 3.12.0
    member _.PrepareSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``prepareSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports the default behavior result.
    ///
    /// The value indicates the default behavior used by the
    /// client.
    ///
    /// @since 3.16.0
    member _.PrepareSupportDefaultBehavior =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``prepareSupportDefaultBehavior`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareSupportDefaultBehavior") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(PrepareSupportDefaultBehavior.FromElement(prop))

    /// Whether the client honors the change annotations in
    /// text edits and resource operations returned via the
    /// rename request&apos;s workspace edit by for example presenting
    /// the workspace edit in the user interface and asking
    /// for confirmation.
    ///
    /// @since 3.16.0
    member _.HonorsChangeAnnotations =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``honorsChangeAnnotations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("honorsChangeAnnotations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``prepareSupport``: global.FSharp.Core.bool,
            ?``prepareSupportDefaultBehavior``: PrepareSupportDefaultBehavior,
            ?``honorsChangeAnnotations``: global.FSharp.Core.bool
        ) =
        RenameClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRenameClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``prepareSupport`` = ``prepareSupport``
                    member _.``prepareSupportDefaultBehavior`` = ``prepareSupportDefaultBehavior``
                    member _.``honorsChangeAnnotations`` = ``honorsChangeAnnotations``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``prepareSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``prepareSupport`` ->
                            ``json writer``.WriteBoolean("prepareSupport", ``prepareSupport``)

                        match ``prepareSupportDefaultBehavior`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``prepareSupportDefaultBehavior`` ->
                            ``json writer``.WriteNumber(
                                "prepareSupportDefaultBehavior",
                                int ``prepareSupportDefaultBehavior``
                            )

                        match ``honorsChangeAnnotations`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``honorsChangeAnnotations`` ->
                            ``json writer``.WriteBoolean("honorsChangeAnnotations", ``honorsChangeAnnotations``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "prepareSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "prepareSupportDefaultBehavior" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "honorsChangeAnnotations" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(RenameClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IFoldingRangeClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``rangeLimit``: global.FSharp.Core.int option
    abstract ``lineFoldingOnly``: global.FSharp.Core.bool option
    abstract ``foldingRangeKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``foldingRange``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IFoldingRangeClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for folding range
    /// providers. If this is set to `true` the client supports the new
    /// `FoldingRangeRegistrationOptions` return value for the corresponding
    /// server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The maximum number of folding ranges that the client prefers to receive
    /// per document. The value serves as a hint, servers are free to follow the
    /// limit.
    member _.RangeLimit =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``rangeLimit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangeLimit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// If set, the client signals that it only supports folding complete lines.
    /// If set, client will ignore specified `startCharacter` and `endCharacter`
    /// properties in a FoldingRange.
    member _.LineFoldingOnly =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``lineFoldingOnly`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("lineFoldingOnly") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Specific options for the folding range kind.
    ///
    /// @since 3.17.0
    member _.FoldingRangeKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``foldingRangeKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRangeKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Specific options for the folding range.
    ///
    /// @since 3.17.0
    member _.FoldingRange =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``foldingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``rangeLimit``: global.FSharp.Core.int,
            ?``lineFoldingOnly``: global.FSharp.Core.bool,
            ?``foldingRangeKind``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``foldingRange``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        FoldingRangeClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IFoldingRangeClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``rangeLimit`` = ``rangeLimit``
                    member _.``lineFoldingOnly`` = ``lineFoldingOnly``
                    member _.``foldingRangeKind`` = ``foldingRangeKind``
                    member _.``foldingRange`` = ``foldingRange``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``rangeLimit`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``rangeLimit`` ->
                            ``json writer``.WriteNumber("rangeLimit", ``rangeLimit``)

                        match ``lineFoldingOnly`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``lineFoldingOnly`` ->
                            ``json writer``.WriteBoolean("lineFoldingOnly", ``lineFoldingOnly``)

                        match ``foldingRangeKind`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``foldingRangeKind`` ->
                            ``json writer``.WritePropertyName("foldingRangeKind")
                            ``foldingRangeKind``.WriteTo(``json writer``)

                        match ``foldingRange`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``foldingRange`` ->
                            ``json writer``.WritePropertyName("foldingRange")
                            ``foldingRange``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FoldingRangeClientCapabilities.FromElement(element))

type private ISelectionRangeClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISelectionRangeClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
    /// the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
    /// capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        SelectionRangeClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISelectionRangeClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SelectionRangeClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IPublishDiagnosticsClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``relatedInformation``: global.FSharp.Core.bool option
    abstract ``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option
    abstract ``versionSupport``: global.FSharp.Core.bool option
    abstract ``codeDescriptionSupport``: global.FSharp.Core.bool option
    abstract ``dataSupport``: global.FSharp.Core.bool option

/// The publish diagnostic client capabilities.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PublishDiagnosticsClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IPublishDiagnosticsClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PublishDiagnosticsClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the clients accepts diagnostics with related information.
    member _.RelatedInformation =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``relatedInformation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedInformation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports the tag property to provide meta data about a diagnostic.
    /// Clients supporting tags have to handle unknown tags gracefully.
    ///
    /// @since 3.15.0
    member _.TagSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``tagSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tagSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Whether the client interprets the version property of the
    /// `textDocument/publishDiagnostics` notification&apos;s parameter.
    ///
    /// @since 3.15.0
    member _.VersionSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``versionSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("versionSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports a codeDescription property
    ///
    /// @since 3.16.0
    member _.CodeDescriptionSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``codeDescriptionSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeDescriptionSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether code action supports the `data` property which is
    /// preserved between a `textDocument/publishDiagnostics` and
    /// `textDocument/codeAction` request.
    ///
    /// @since 3.16.0
    member _.DataSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dataSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dataSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``relatedInformation``: global.FSharp.Core.bool,
            ?``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``versionSupport``: global.FSharp.Core.bool,
            ?``codeDescriptionSupport``: global.FSharp.Core.bool,
            ?``dataSupport``: global.FSharp.Core.bool
        ) =
        PublishDiagnosticsClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IPublishDiagnosticsClientCapabilities with
                    member _.``relatedInformation`` = ``relatedInformation``
                    member _.``tagSupport`` = ``tagSupport``
                    member _.``versionSupport`` = ``versionSupport``
                    member _.``codeDescriptionSupport`` = ``codeDescriptionSupport``
                    member _.``dataSupport`` = ``dataSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``relatedInformation`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``relatedInformation`` ->
                            ``json writer``.WriteBoolean("relatedInformation", ``relatedInformation``)

                        match ``tagSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``tagSupport`` ->
                            ``json writer``.WritePropertyName("tagSupport")
                            ``tagSupport``.WriteTo(``json writer``)

                        match ``versionSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``versionSupport`` ->
                            ``json writer``.WriteBoolean("versionSupport", ``versionSupport``)

                        match ``codeDescriptionSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``codeDescriptionSupport`` ->
                            ``json writer``.WriteBoolean("codeDescriptionSupport", ``codeDescriptionSupport``)

                        match ``dataSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dataSupport`` ->
                            ``json writer``.WriteBoolean("dataSupport", ``dataSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(PublishDiagnosticsClientCapabilities.FromElement(element))

type private ICallHierarchyClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ICallHierarchyClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        CallHierarchyClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ICallHierarchyClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CallHierarchyClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ISemanticTokensClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``requests``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``formats``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
    abstract ``overlappingTokenSupport``: global.FSharp.Core.bool option
    abstract ``multilineTokenSupport``: global.FSharp.Core.bool option
    abstract ``serverCancelSupport``: global.FSharp.Core.bool option
    abstract ``augmentsSyntaxTokens``: global.FSharp.Core.bool option

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ISemanticTokensClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Which requests the client supports and might send to the server
    /// depending on the server&apos;s capability. Please note that clients might not
    /// show semantic tokens or degrade some of the user experience if a range
    /// or full request is advertised by the client but not provided by the
    /// server. If for example the client capability `requests.full` and
    /// `request.range` are both set to true but the server only provides a
    /// range provider the client might not render a minimap correctly or might
    /// even decide to not show any semantic tokens at all.
    member _.Requests =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``requests``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("requests")
            LspJsonBacking.Element prop

    /// The token types that the client supports.
    member _.TokenTypes =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``tokenTypes``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenTypes")
            LspJsonBacking.Element prop

    /// The token modifiers that the client supports.
    member _.TokenModifiers =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``tokenModifiers``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenModifiers")
            LspJsonBacking.Element prop

    /// The token formats the clients supports.
    member _.Formats =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``formats``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("formats")
            LspJsonBacking.Element prop

    /// Whether the client supports tokens that can overlap each other.
    member _.OverlappingTokenSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``overlappingTokenSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("overlappingTokenSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports tokens that can span multiple lines.
    member _.MultilineTokenSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``multilineTokenSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("multilineTokenSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client allows the server to actively cancel a
    /// semantic token request, e.g. supports returning
    /// LSPErrorCodes.ServerCancelled. If a server does the client
    /// needs to retrigger the request.
    ///
    /// @since 3.17.0
    member _.ServerCancelSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``serverCancelSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("serverCancelSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client uses semantic tokens to augment existing
    /// syntax tokens. If set to `true` client side created syntax
    /// tokens and semantic tokens are both used for colorization. If
    /// set to `false` the client only uses the returned semantic tokens
    /// for colorization.
    ///
    /// If the value is `undefined` then the client behavior is not
    /// specified.
    ///
    /// @since 3.17.0
    member _.AugmentsSyntaxTokens =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``augmentsSyntaxTokens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("augmentsSyntaxTokens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``requests``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ``formats``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>,
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``overlappingTokenSupport``: global.FSharp.Core.bool,
            ?``multilineTokenSupport``: global.FSharp.Core.bool,
            ?``serverCancelSupport``: global.FSharp.Core.bool,
            ?``augmentsSyntaxTokens``: global.FSharp.Core.bool
        ) =
        SemanticTokensClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ISemanticTokensClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``requests`` = ``requests``
                    member _.``tokenTypes`` = ``tokenTypes``
                    member _.``tokenModifiers`` = ``tokenModifiers``
                    member _.``formats`` = ``formats``
                    member _.``overlappingTokenSupport`` = ``overlappingTokenSupport``
                    member _.``multilineTokenSupport`` = ``multilineTokenSupport``
                    member _.``serverCancelSupport`` = ``serverCancelSupport``
                    member _.``augmentsSyntaxTokens`` = ``augmentsSyntaxTokens``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WritePropertyName("requests")
                        ``requests``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("tokenTypes")
                        ``tokenTypes``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("tokenModifiers")
                        ``tokenModifiers``.WriteTo(``json writer``)
                        ``json writer``.WritePropertyName("formats")
                        ``formats``.WriteTo(``json writer``)

                        match ``overlappingTokenSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``overlappingTokenSupport`` ->
                            ``json writer``.WriteBoolean("overlappingTokenSupport", ``overlappingTokenSupport``)

                        match ``multilineTokenSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``multilineTokenSupport`` ->
                            ``json writer``.WriteBoolean("multilineTokenSupport", ``multilineTokenSupport``)

                        match ``serverCancelSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``serverCancelSupport`` ->
                            ``json writer``.WriteBoolean("serverCancelSupport", ``serverCancelSupport``)

                        match ``augmentsSyntaxTokens`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``augmentsSyntaxTokens`` ->
                            ``json writer``.WriteBoolean("augmentsSyntaxTokens", ``augmentsSyntaxTokens``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensClientCapabilities.FromElement(element))

type private ILinkedEditingRangeClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client capabilities for the linked editing range request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ILinkedEditingRangeClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        LinkedEditingRangeClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ILinkedEditingRangeClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(LinkedEditingRangeClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IMonikerClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client capabilities specific to the moniker request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMonikerClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether moniker supports dynamic registration. If this is set to `true`
    /// the client supports the new `MonikerRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        MonikerClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMonikerClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(MonikerClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private ITypeHierarchyClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<ITypeHierarchyClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        TypeHierarchyClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new ITypeHierarchyClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeHierarchyClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineValueClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client capabilities specific to inline values.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineValueClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for inline value providers.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        InlineValueClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineValueClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlayHintClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Inlay hint client capabilities.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlayHintClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether inlay hints support dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Indicates which properties a client can resolve lazily on an inlay
    /// hint.
    member _.ResolveSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``resolveSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        InlayHintClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlayHintClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``resolveSupport`` = ``resolveSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``resolveSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``resolveSupport`` ->
                            ``json writer``.WritePropertyName("resolveSupport")
                            ``resolveSupport``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHintClientCapabilities.FromElement(element))

type private IDiagnosticClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``relatedDocumentSupport``: global.FSharp.Core.bool option

/// Client capabilities specific to diagnostic pull requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IDiagnosticClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the clients supports related documents for document diagnostic pulls.
    member _.RelatedDocumentSupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``relatedDocumentSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedDocumentSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``relatedDocumentSupport``: global.FSharp.Core.bool) =
        DiagnosticClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IDiagnosticClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``relatedDocumentSupport`` = ``relatedDocumentSupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``relatedDocumentSupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``relatedDocumentSupport`` ->
                            ``json writer``.WriteBoolean("relatedDocumentSupport", ``relatedDocumentSupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "relatedDocumentSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IInlineCompletionClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option

/// Client capabilities specific to inline completions.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IInlineCompletionClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for inline completion providers.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        InlineCompletionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IInlineCompletionClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineCompletionClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private INotebookDocumentSyncClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``dynamicRegistration``: global.FSharp.Core.bool option
    abstract ``executionSummarySupport``: global.FSharp.Core.bool option

/// Notebook specific client capabilities.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentSyncClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<INotebookDocumentSyncClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentSyncClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is
    /// set to `true` the client supports the new
    /// `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports sending execution summary data per cell.
    member _.ExecutionSummarySupport =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``executionSummarySupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executionSummarySupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``executionSummarySupport``: global.FSharp.Core.bool) =
        NotebookDocumentSyncClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new INotebookDocumentSyncClientCapabilities with
                    member _.``dynamicRegistration`` = ``dynamicRegistration``
                    member _.``executionSummarySupport`` = ``executionSummarySupport``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``dynamicRegistration`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``dynamicRegistration`` ->
                            ``json writer``.WriteBoolean("dynamicRegistration", ``dynamicRegistration``)

                        match ``executionSummarySupport`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``executionSummarySupport`` ->
                            ``json writer``.WriteBoolean("executionSummarySupport", ``executionSummarySupport``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "executionSummarySupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(NotebookDocumentSyncClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IShowMessageRequestClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``messageActionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Show message request client capabilities
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowMessageRequestClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IShowMessageRequestClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowMessageRequestClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Capabilities specific to the `MessageActionItem` type.
    member _.MessageActionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``messageActionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("messageActionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create(?``messageActionItem``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
        ShowMessageRequestClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IShowMessageRequestClientCapabilities with
                    member _.``messageActionItem`` = ``messageActionItem``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()

                        match ``messageActionItem`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``messageActionItem`` ->
                            ``json writer``.WritePropertyName("messageActionItem")
                            ``messageActionItem``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ShowMessageRequestClientCapabilities.FromElement(element))

type private IShowDocumentClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``support``: global.FSharp.Core.bool

/// Client capabilities for the showDocument request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowDocumentClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IShowDocumentClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowDocumentClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client has support for the showDocument
    /// request.
    member _.Support =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``support``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("support")
            prop.GetBoolean()

    static member Create(``support``: global.FSharp.Core.bool) =
        ShowDocumentClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IShowDocumentClientCapabilities with
                    member _.``support`` = ``support``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WriteBoolean("support", ``support``)
                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "support" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ShowDocumentClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IRegularExpressionsClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``engine``: global.Amongonz.LspTypes.LspString
    abstract ``version``: global.Amongonz.LspTypes.LspString option

/// Client capabilities specific to regular expressions.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RegularExpressionsClientCapabilities
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<IRegularExpressionsClientCapabilities>) =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RegularExpressionsClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The engine&apos;s name.
    member _.Engine =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``engine``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("engine")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The engine&apos;s version.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``version`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("version") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``engine``: global.Amongonz.LspTypes.LspString, ?``version``: global.Amongonz.LspTypes.LspString)
        =
        RegularExpressionsClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IRegularExpressionsClientCapabilities with
                    member _.``engine`` = ``engine``
                    member _.``version`` = ``version``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("engine")
                        ``engine``.WriteTo(``json writer``)

                        match ``version`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``version`` ->
                            ``json writer``.WritePropertyName("version")
                            ``version``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "engine" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(RegularExpressionsClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

type private IMarkdownClientCapabilities =
    inherit global.Amongonz.LspTypes.ILspJsonBackingObj
    abstract ``parser``: global.Amongonz.LspTypes.LspString
    abstract ``version``: global.Amongonz.LspTypes.LspString option
    abstract ``allowedTags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj> option

/// Client capabilities specific to the used markdown parser.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkdownClientCapabilities private (backing: global.Amongonz.LspTypes.LspJsonBacking<IMarkdownClientCapabilities>)
    =
    member _.GetBacking() = backing.Boxed
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MarkdownClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of the parser.
    member _.Parser =
        match backing with
        | LspJsonBacking.Obj backingObj -> backingObj.``parser``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("parser")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The version of the parser.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``version`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("version") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A list of HTML tags that the client allows / supports in
    /// Markdown.
    ///
    /// @since 3.17.0
    member _.AllowedTags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj backingObj ->
            match backingObj.``allowedTags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("allowedTags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``parser``: global.Amongonz.LspTypes.LspString,
            ?``version``: global.Amongonz.LspTypes.LspString,
            ?``allowedTags``: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>
        ) =
        MarkdownClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                { new IMarkdownClientCapabilities with
                    member _.``parser`` = ``parser``
                    member _.``version`` = ``version``
                    member _.``allowedTags`` = ``allowedTags``

                    member _.WriteTo(``json writer``) =
                        ``json writer``.WriteStartObject()
                        ``json writer``.WritePropertyName("parser")
                        ``parser``.WriteTo(``json writer``)

                        match ``version`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``version`` ->
                            ``json writer``.WritePropertyName("version")
                            ``version``.WriteTo(``json writer``)

                        match ``allowedTags`` with
                        | global.FSharp.Core.None -> ()
                        | global.FSharp.Core.Some ``allowedTags`` ->
                            ``json writer``.WritePropertyName("allowedTags")
                            ``allowedTags``.WriteTo(``json writer``)

                        ``json writer``.WriteEndObject()
                }
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(MarkdownClientCapabilities.FromElement(element))

/// The definition of a symbol represented as one or many {@link Location locations}.
/// For most programming languages there is only one location at which a symbol is
/// defined.
///
/// Servers should prefer returning `DefinitionLink` over `Definition` if supported
/// by the client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Definition(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Definition(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(Definition.FromElement(element))

/// Information about where a symbol is defined.
///
/// Provides additional metadata over normal {@link Location location} definitions, including the range of
/// the defining symbol
type DefinitionLink = LocationLink

/// LSP arrays.
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LSPArray(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: array.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LSPArray(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(LSPArray.FromElement(element))

/// The LSP any type.
/// Please note that strictly speaking a property with the value `undefined`
/// can&apos;t be converted into JSON preserving the property name. However for
/// convenience it is allowed and assumed that all these properties are
/// optional as well.
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LSPAny(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LSPAny(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(LSPAny.FromElement(element))

/// The declaration of a symbol representation as one or many {@link Location locations}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Declaration(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Declaration(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(Declaration.FromElement(element))

/// Information about where a symbol is declared.
///
/// Provides additional metadata over normal {@link Location location} declarations, including the range of
/// the declaring symbol.
///
/// Servers should prefer returning `DeclarationLink` over `Declaration` if supported
/// by the client.
type DeclarationLink = LocationLink

/// Inline value information can be provided by different means:
/// - directly as a text value (class InlineValueText).
/// - as a name to use for a variable lookup (class InlineValueVariableLookup)
/// - as an evaluatable expression (class InlineValueEvaluatableExpression)
/// The InlineValue types combines all inline value types into one type.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValue(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValue(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(InlineValue.FromElement(element))

/// The result of a document diagnostic pull request. A report can
/// either be a full report containing all diagnostics for the
/// requested document or an unchanged report indicating that nothing
/// has changed in terms of diagnostics in comparison to the last
/// pull request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticReport(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(DocumentDiagnosticReport.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PrepareRenameResult(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PrepareRenameResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(PrepareRenameResult.FromElement(element))

/// A document selector is the combination of one or many document filters.
///
/// @sample `let sel:DocumentSelector = [{ language: &apos;typescript&apos; }, { language: &apos;json&apos;, pattern: &apos;**∕tsconfig.json&apos; }]`;
///
/// The use of a string as a document filter is deprecated @since 3.16.0.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSelector(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: array.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSelector(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(DocumentSelector.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ProgressToken(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ProgressToken(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(ProgressToken.FromElement(element))

/// An identifier to refer to a change annotation stored with a workspace edit.
type ChangeAnnotationIdentifier = global.Amongonz.LspTypes.LspString

/// A workspace diagnostic document report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDocumentDiagnosticReport(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(WorkspaceDocumentDiagnosticReport.FromElement(element))

/// An event describing a change to a text document. If only a text is provided
/// it is considered to be the full content of the document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentContentChangeEvent(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentContentChangeEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(TextDocumentContentChangeEvent.FromElement(element))

/// MarkedString can be used to render human readable text. It is either a markdown string
/// or a code-block that provides a language and a code snippet. The language identifier
/// is semantically equal to the optional language identifier in fenced code blocks in GitHub
/// issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
///
/// The pair of a language and a value is an equivalent to markdown:
/// ```${language}
/// ${value}
/// ```
///
/// Note that markdown strings will be sanitized - that means html will be escaped.
/// @deprecated use MarkupContent instead.
[<global.System.Obsolete("use MarkupContent instead.")>]
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkedString(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MarkedString(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(MarkedString.FromElement(element))

/// A document filter describes a top level text document or
/// a notebook cell document.
///
/// @since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFilter(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(DocumentFilter.FromElement(element))

/// LSP object definition.
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LSPObject(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: map.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LSPObject(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(LSPObject.FromElement(element))

/// The glob pattern. Either a string pattern or a relative pattern.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type GlobPattern(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        GlobPattern(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(GlobPattern.FromElement(element))

/// A document filter denotes a document by different properties like
/// the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
/// its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
///
/// Glob patterns can have the following syntax:
/// - `*` to match one or more characters in a path segment
/// - `?` to match on one character in a path segment
/// - `**` to match any number of path segments, including none
/// - `{}` to group sub patterns into an OR expression. (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
/// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
/// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
///
/// @sample A language filter that applies to typescript files on disk: `{ language: &apos;typescript&apos;, scheme: &apos;file&apos; }`
/// @sample A language filter that applies to all package.json paths: `{ language: &apos;json&apos;, pattern: &apos;**package.json&apos; }`
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentFilter(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(TextDocumentFilter.FromElement(element))

/// A notebook document filter denotes a notebook document by
/// different properties. The properties will be match
/// against the notebook&apos;s URI (same as with documents)
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentFilter(backing: global.Amongonz.LspTypes.LspJsonBacking<ILspJsonBackingObj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(NotebookDocumentFilter.FromElement(element))

/// The glob pattern to watch relative to the base path. Glob patterns can have the following syntax:
/// - `*` to match one or more characters in a path segment
/// - `?` to match on one character in a path segment
/// - `**` to match any number of path segments, including none
/// - `{}` to group conditions (e.g. `**​/*.{ts,js}` matches all TypeScript and JavaScript files)
/// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
/// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
///
/// @since 3.17.0
type Pattern = global.Amongonz.LspTypes.LspString
