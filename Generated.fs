// This file was auto-generated.
namespace rec Amongonz.LspTypes

#nowarn "44" // Obsolete warnings

/// A set of predefined token types. This set is not fixed
/// an clients can specify additional token types via the
/// corresponding client capabilities.
///
/// @since 3.16.0
type SemanticTokenTypes = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module SemanticTokenTypes =

    [<return: Struct>]
    let (|Namespace|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("namespace") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Represents a generic type. Acts as a fallback for types which can&apos;t be mapped to
    /// a specific type like class or enum.
    [<return: Struct>]
    let (|Type|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("type") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Class|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("class") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Enum|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("enum") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Interface|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("interface") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Struct|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("struct") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|TypeParameter|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("typeParameter") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Parameter|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("parameter") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Variable|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("variable") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Property|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("property") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|EnumMember|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("enumMember") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Event|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("event") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Function|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("function") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Method|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("method") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Macro|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("macro") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Keyword|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("keyword") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Modifier|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("modifier") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Comment|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("comment") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|String|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("string") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Number|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("number") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Regexp|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("regexp") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Operator|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("operator") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// @since 3.17.0
    [<return: Struct>]
    let (|Decorator|_|) (value: SemanticTokenTypes) =
        if value.ValueEquals("decorator") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// A set of predefined token modifiers. This set is not fixed
/// an clients can specify additional token types via the
/// corresponding client capabilities.
///
/// @since 3.16.0
type SemanticTokenModifiers = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module SemanticTokenModifiers =

    [<return: Struct>]
    let (|Declaration|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("declaration") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Definition|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("definition") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Readonly|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("readonly") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Static|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("static") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Deprecated|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("deprecated") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Abstract|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("abstract") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Async|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("async") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Modification|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("modification") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|Documentation|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("documentation") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    [<return: Struct>]
    let (|DefaultLibrary|_|) (value: SemanticTokenModifiers) =
        if value.ValueEquals("defaultLibrary") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// The document diagnostic report kinds.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticReportKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | DocumentDiagnosticReportKind.Full
        | DocumentDiagnosticReportKind.Unchanged as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        DocumentDiagnosticReportKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (DocumentDiagnosticReportKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (DocumentDiagnosticReportKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module DocumentDiagnosticReportKind =

    /// A diagnostic report with a full
    /// set of problems.
    [<return: Struct>]
    let (|Full|_|) (value: DocumentDiagnosticReportKind) =
        if value.ValueEquals("full") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// A report indicating that the last
    /// returned report is still accurate.
    [<return: Struct>]
    let (|Unchanged|_|) (value: DocumentDiagnosticReportKind) =
        if value.ValueEquals("unchanged") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Predefined error codes.
type ErrorCodes = int

module ErrorCodes =

    [<Literal>]
    let ParseError = -32700

    [<Literal>]
    let InvalidRequest = -32600

    [<Literal>]
    let MethodNotFound = -32601

    [<Literal>]
    let InvalidParams = -32602

    [<Literal>]
    let InternalError = -32603

    /// Error code indicating that a server received a notification or
    /// request before the server has received the `initialize` request.
    [<Literal>]
    let ServerNotInitialized = -32002

    [<Literal>]
    let UnknownErrorCode = -32001

type LSPErrorCodes = int

module LSPErrorCodes =

    /// A request failed but it was syntactically correct, e.g the
    /// method name was known and the parameters were valid. The error
    /// message should contain human readable information about why
    /// the request failed.
    ///
    /// @since 3.17.0
    [<Literal>]
    let RequestFailed = -32803

    /// The server cancelled the request. This error code should
    /// only be used for requests that explicitly support being
    /// server cancellable.
    ///
    /// @since 3.17.0
    [<Literal>]
    let ServerCancelled = -32802

    /// The server detected that the content of a document got
    /// modified outside normal conditions. A server should
    /// NOT send this error code if it detects a content change
    /// in it unprocessed messages. The result even computed
    /// on an older state might still be useful for the client.
    ///
    /// If a client decides that a result is not of any use anymore
    /// the client should cancel the request.
    [<Literal>]
    let ContentModified = -32801

    /// The client has canceled a request and a server has detected
    /// the cancel.
    [<Literal>]
    let RequestCancelled = -32800

/// A set of predefined range kinds.
type FoldingRangeKind = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module FoldingRangeKind =

    /// Folding range for a comment
    [<return: Struct>]
    let (|Comment|_|) (value: FoldingRangeKind) =
        if value.ValueEquals("comment") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Folding range for an import or include
    [<return: Struct>]
    let (|Imports|_|) (value: FoldingRangeKind) =
        if value.ValueEquals("imports") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Folding range for a region (e.g. `#region`)
    [<return: Struct>]
    let (|Region|_|) (value: FoldingRangeKind) =
        if value.ValueEquals("region") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// A symbol kind.
type SymbolKind =
    | File = 1
    | Module = 2
    | Namespace = 3
    | Package = 4
    | Class = 5
    | Method = 6
    | Property = 7
    | Field = 8
    | Constructor = 9
    | Enum = 10
    | Interface = 11
    | Function = 12
    | Variable = 13
    | Constant = 14
    | String = 15
    | Number = 16
    | Boolean = 17
    | Array = 18
    | Object = 19
    | Key = 20
    | Null = 21
    | EnumMember = 22
    | Struct = 23
    | Event = 24
    | Operator = 25
    | TypeParameter = 26

/// Symbol tags are extra annotations that tweak the rendering of a symbol.
///
/// @since 3.16
type SymbolTag =

    /// Render a symbol as obsolete, usually using a strike-out.
    | Deprecated = 1

/// Moniker uniqueness level to define scope of the moniker.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type UniquenessLevel(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | UniquenessLevel.Document
        | UniquenessLevel.Project
        | UniquenessLevel.Group
        | UniquenessLevel.Scheme
        | UniquenessLevel.Global as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        UniquenessLevel(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (UniquenessLevel(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (UniquenessLevel(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module UniquenessLevel =

    /// The moniker is only unique inside a document
    [<return: Struct>]
    let (|Document|_|) (value: UniquenessLevel) =
        if value.ValueEquals("document") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is unique inside a project for which a dump got created
    [<return: Struct>]
    let (|Project|_|) (value: UniquenessLevel) =
        if value.ValueEquals("project") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is unique inside the group to which a project belongs
    [<return: Struct>]
    let (|Group|_|) (value: UniquenessLevel) =
        if value.ValueEquals("group") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is unique inside the moniker scheme.
    [<return: Struct>]
    let (|Scheme|_|) (value: UniquenessLevel) =
        if value.ValueEquals("scheme") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker is globally unique
    [<return: Struct>]
    let (|Global|_|) (value: UniquenessLevel) =
        if value.ValueEquals("global") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// The moniker kind.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | MonikerKind.Import
        | MonikerKind.Export
        | MonikerKind.Local as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        MonikerKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (MonikerKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (MonikerKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module MonikerKind =

    /// The moniker represent a symbol that is imported into a project
    [<return: Struct>]
    let (|Import|_|) (value: MonikerKind) =
        if value.ValueEquals("import") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker represents a symbol that is exported from a project
    [<return: Struct>]
    let (|Export|_|) (value: MonikerKind) =
        if value.ValueEquals("export") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The moniker represents a symbol that is local to a project (e.g. a local
    /// variable of a function, a class not visible outside the project, ...)
    [<return: Struct>]
    let (|Local|_|) (value: MonikerKind) =
        if value.ValueEquals("local") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Inlay hint kinds.
///
/// @since 3.17.0
type InlayHintKind =

    /// An inlay hint that for a type annotation.
    | Type = 1

    /// An inlay hint that is for a parameter.
    | Parameter = 2

/// The message type
type MessageType =

    /// An error message.
    | Error = 1

    /// A warning message.
    | Warning = 2

    /// An information message.
    | Info = 3

    /// A log message.
    | Log = 4

    /// A debug message.
    ///
    /// @since 3.18.0
    | Debug = 5

/// Defines how the host (editor) should sync
/// document changes to the language server.
type TextDocumentSyncKind =

    /// Documents should not be synced at all.
    | None = 0

    /// Documents are synced by always sending the full content
    /// of the document.
    | Full = 1

    /// Documents are synced by sending the full content on open.
    /// After that only incremental updates to the document are
    /// send.
    | Incremental = 2

/// Represents reasons why a text document is saved.
type TextDocumentSaveReason =

    /// Manually triggered, e.g. by the user pressing save, by starting debugging,
    /// or by an API call.
    | Manual = 1

    /// Automatic after a delay.
    | AfterDelay = 2

    /// When the editor lost focus.
    | FocusOut = 3

/// The kind of a completion entry.
type CompletionItemKind =
    | Text = 1
    | Method = 2
    | Function = 3
    | Constructor = 4
    | Field = 5
    | Variable = 6
    | Class = 7
    | Interface = 8
    | Module = 9
    | Property = 10
    | Unit = 11
    | Value = 12
    | Enum = 13
    | Keyword = 14
    | Snippet = 15
    | Color = 16
    | File = 17
    | Reference = 18
    | Folder = 19
    | EnumMember = 20
    | Constant = 21
    | Struct = 22
    | Event = 23
    | Operator = 24
    | TypeParameter = 25

/// Completion item tags are extra annotations that tweak the rendering of a completion
/// item.
///
/// @since 3.15.0
type CompletionItemTag =

    /// Render a completion as obsolete, usually using a strike-out.
    | Deprecated = 1

/// Defines whether the insert text in a completion item should be interpreted as
/// plain text or a snippet.
type InsertTextFormat =

    /// The primary text to be inserted is treated as a plain string.
    | PlainText = 1

    /// The primary text to be inserted is treated as a snippet.
    ///
    /// A snippet can define tab stops and placeholders with `$1`, `$2`
    /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
    /// the end of the snippet. Placeholders with equal identifiers are linked,
    /// that is typing in one will update others too.
    ///
    /// See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
    | Snippet = 2

/// How whitespace and indentation is handled during completion
/// item insertion.
///
/// @since 3.16.0
type InsertTextMode =

    /// The insertion or replace strings is taken as it is. If the
    /// value is multi line the lines below the cursor will be
    /// inserted using the indentation defined in the string value.
    /// The client will not apply any kind of adjustments to the
    /// string.
    | AsIs = 1

    /// The editor adjusts leading whitespace of new lines so that
    /// they match the indentation up to the cursor of the line for
    /// which the item is accepted.
    ///
    /// Consider a line like this: &lt;2tabs&gt;&lt;cursor&gt;&lt;3tabs&gt;foo. Accepting a
    /// multi line completion item is indented using 2 tabs and all
    /// following lines inserted will be indented using 2 tabs as well.
    | AdjustIndentation = 2

/// A document highlight kind.
type DocumentHighlightKind =

    /// A textual occurrence.
    | Text = 1

    /// Read-access of a symbol, like reading a variable.
    | Read = 2

    /// Write-access of a symbol, like writing to a variable.
    | Write = 3

/// A set of predefined code action kinds
type CodeActionKind = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module CodeActionKind =

    /// Empty kind.
    [<return: Struct>]
    let (|Empty|_|) (value: CodeActionKind) =
        if value.ValueEquals("") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for quickfix actions: &apos;quickfix&apos;
    [<return: Struct>]
    let (|QuickFix|_|) (value: CodeActionKind) =
        if value.ValueEquals("quickfix") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring actions: &apos;refactor&apos;
    [<return: Struct>]
    let (|Refactor|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring extraction actions: &apos;refactor.extract&apos;
    ///
    /// Example extract actions:
    ///
    /// - Extract method
    /// - Extract function
    /// - Extract variable
    /// - Extract interface from class
    /// - ...
    [<return: Struct>]
    let (|RefactorExtract|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor.extract") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring inline actions: &apos;refactor.inline&apos;
    ///
    /// Example inline actions:
    ///
    /// - Inline function
    /// - Inline variable
    /// - Inline constant
    /// - ...
    [<return: Struct>]
    let (|RefactorInline|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor.inline") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for refactoring rewrite actions: &apos;refactor.rewrite&apos;
    ///
    /// Example rewrite actions:
    ///
    /// - Convert JavaScript function to class
    /// - Add or remove parameter
    /// - Encapsulate field
    /// - Make method static
    /// - Move method to base class
    /// - ...
    [<return: Struct>]
    let (|RefactorRewrite|_|) (value: CodeActionKind) =
        if value.ValueEquals("refactor.rewrite") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for source actions: `source`
    ///
    /// Source code actions apply to the entire file.
    [<return: Struct>]
    let (|Source|_|) (value: CodeActionKind) =
        if value.ValueEquals("source") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for an organize imports source action: `source.organizeImports`
    [<return: Struct>]
    let (|SourceOrganizeImports|_|) (value: CodeActionKind) =
        if value.ValueEquals("source.organizeImports") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Base kind for auto-fix source actions: `source.fixAll`.
    ///
    /// Fix all actions automatically fix errors that have a clear fix that do not require user input.
    /// They should not suppress errors or perform unsafe fixes such as generating new types or classes.
    ///
    /// @since 3.15.0
    [<return: Struct>]
    let (|SourceFixAll|_|) (value: CodeActionKind) =
        if value.ValueEquals("source.fixAll") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TraceValues(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | TraceValues.Off
        | TraceValues.Messages
        | TraceValues.Verbose as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        TraceValues(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (TraceValues(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (TraceValues(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module TraceValues =

    /// Turn tracing off.
    [<return: Struct>]
    let (|Off|_|) (value: TraceValues) =
        if value.ValueEquals("off") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Trace messages only.
    [<return: Struct>]
    let (|Messages|_|) (value: TraceValues) =
        if value.ValueEquals("messages") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Verbose message tracing.
    [<return: Struct>]
    let (|Verbose|_|) (value: TraceValues) =
        if value.ValueEquals("verbose") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Describes the content type that a client supports in various
/// result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
///
/// Please note that `MarkupKinds` must not start with a `$`. This kinds
/// are reserved for internal usage.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkupKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | MarkupKind.PlainText
        | MarkupKind.Markdown as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        MarkupKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (MarkupKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (MarkupKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module MarkupKind =

    /// Plain text is supported as a content format
    [<return: Struct>]
    let (|PlainText|_|) (value: MarkupKind) =
        if value.ValueEquals("plaintext") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Markdown is supported as a content format
    [<return: Struct>]
    let (|Markdown|_|) (value: MarkupKind) =
        if value.ValueEquals("markdown") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
///
/// @since 3.18.0
/// @proposed
type InlineCompletionTriggerKind =

    /// Completion was triggered explicitly by a user gesture.
    | Invoked = 0

    /// Completion was triggered automatically while editing.
    | Automatic = 1

/// A set of predefined position encoding kinds.
///
/// @since 3.17.0
type PositionEncodingKind = global.Amongonz.LspTypes.LspString

[<global.FSharp.Core.RequireQualifiedAccess>]
module PositionEncodingKind =

    /// Character offsets count UTF-8 code units (e.g. bytes).
    [<return: Struct>]
    let (|UTF8|_|) (value: PositionEncodingKind) =
        if value.ValueEquals("utf-8") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Character offsets count UTF-16 code units.
    ///
    /// This is the default and must always be supported
    /// by servers
    [<return: Struct>]
    let (|UTF16|_|) (value: PositionEncodingKind) =
        if value.ValueEquals("utf-16") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Character offsets count UTF-32 code units.
    ///
    /// Implementation note: these are the same as Unicode codepoints,
    /// so this `PositionEncodingKind` may also be used for an
    /// encoding-agnostic representation of character offsets.
    [<return: Struct>]
    let (|UTF32|_|) (value: PositionEncodingKind) =
        if value.ValueEquals("utf-32") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// The file event type
type FileChangeType =

    /// The file got created.
    | Created = 1

    /// The file got changed.
    | Changed = 2

    /// The file got deleted.
    | Deleted = 3

type WatchKind = int

module WatchKind =

    /// Interested in create events.
    [<Literal>]
    let Create = 1

    /// Interested in change events
    [<Literal>]
    let Change = 2

    /// Interested in delete events
    [<Literal>]
    let Delete = 4

/// The diagnostic&apos;s severity.
type DiagnosticSeverity =

    /// Reports an error.
    | Error = 1

    /// Reports a warning.
    | Warning = 2

    /// Reports an information.
    | Information = 3

    /// Reports a hint.
    | Hint = 4

/// The diagnostic tags.
///
/// @since 3.15.0
type DiagnosticTag =

    /// Unused or unnecessary code.
    ///
    /// Clients are allowed to render diagnostics with this tag faded out instead of having
    /// an error squiggle.
    | Unnecessary = 1

    /// Deprecated or obsolete code.
    ///
    /// Clients are allowed to rendered diagnostics with this tag strike through.
    | Deprecated = 2

/// How a completion was triggered
type CompletionTriggerKind =

    /// Completion was triggered by typing an identifier (24x7 code
    /// complete), manual invocation (e.g Ctrl+Space) or via API.
    | Invoked = 1

    /// Completion was triggered by a trigger character specified by
    /// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
    | TriggerCharacter = 2

    /// Completion was re-triggered as current completion list is incomplete
    | TriggerForIncompleteCompletions = 3

/// How a signature help was triggered.
///
/// @since 3.15.0
type SignatureHelpTriggerKind =

    /// Signature help was invoked manually by the user or by a command.
    | Invoked = 1

    /// Signature help was triggered by a trigger character.
    | TriggerCharacter = 2

    /// Signature help was triggered by the cursor moving or by the document content changing.
    | ContentChange = 3

/// The reason why code actions were requested.
///
/// @since 3.17.0
type CodeActionTriggerKind =

    /// Code actions were explicitly requested by the user or by an extension.
    | Invoked = 1

    /// Code actions were requested automatically.
    ///
    /// This typically happens when current selection in a file changes, but can
    /// also be triggered when file content changes.
    | Automatic = 2

/// A pattern kind describing if a glob pattern matches a file a folder or
/// both.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationPatternKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | FileOperationPatternKind.File
        | FileOperationPatternKind.Folder as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        FileOperationPatternKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (FileOperationPatternKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (FileOperationPatternKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module FileOperationPatternKind =

    /// The pattern matches a file only.
    [<return: Struct>]
    let (|File|_|) (value: FileOperationPatternKind) =
        if value.ValueEquals("file") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The pattern matches a folder only.
    [<return: Struct>]
    let (|Folder|_|) (value: FileOperationPatternKind) =
        if value.ValueEquals("folder") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

/// A notebook cell kind.
///
/// @since 3.17.0
type NotebookCellKind =

    /// A markup-cell is formatted source that is used for display.
    | Markup = 1

    /// A code-cell is source code.
    | Code = 2

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ResourceOperationKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | ResourceOperationKind.Create
        | ResourceOperationKind.Rename
        | ResourceOperationKind.Delete as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        ResourceOperationKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (ResourceOperationKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (ResourceOperationKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module ResourceOperationKind =

    /// Supports creating new files and folders.
    [<return: Struct>]
    let (|Create|_|) (value: ResourceOperationKind) =
        if value.ValueEquals("create") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Supports renaming existing files and folders.
    [<return: Struct>]
    let (|Rename|_|) (value: ResourceOperationKind) =
        if value.ValueEquals("rename") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// Supports deleting existing files and folders.
    [<return: Struct>]
    let (|Delete|_|) (value: ResourceOperationKind) =
        if value.ValueEquals("delete") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FailureHandlingKind(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | FailureHandlingKind.Abort
        | FailureHandlingKind.Transactional
        | FailureHandlingKind.TextOnlyTransactional
        | FailureHandlingKind.Undo as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        FailureHandlingKind(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (FailureHandlingKind(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (FailureHandlingKind(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module FailureHandlingKind =

    /// Applying the workspace change is simply aborted if one of the changes provided
    /// fails. All operations executed before the failing operation stay executed.
    [<return: Struct>]
    let (|Abort|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("abort") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// All operations are executed transactional. That means they either all
    /// succeed or no changes at all are applied to the workspace.
    [<return: Struct>]
    let (|Transactional|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("transactional") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// If the workspace edit contains only textual file changes they are executed transactional.
    /// If resource changes (create, rename or delete file) are part of the change the failure
    /// handling strategy is abort.
    [<return: Struct>]
    let (|TextOnlyTransactional|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("textOnlyTransactional") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

    /// The client tries to undo the operations already executed. But there is no
    /// guarantee that this is succeeding.
    [<return: Struct>]
    let (|Undo|_|) (value: FailureHandlingKind) =
        if value.ValueEquals("undo") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

type PrepareSupportDefaultBehavior =

    /// The client&apos;s default behavior is to select the identifier
    /// according the to language&apos;s syntax rule.
    | Identifier = 1

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TokenFormat(stringValue: global.Amongonz.LspTypes.LspString) =
    static let validate value =
        match value with
        | TokenFormat.Relative as value -> global.FSharp.Core.Ok(value)
        | _ -> global.FSharp.Core.Error()

    member _.GetBacking() = stringValue.GetBacking()
    member _.WriteTo(writer) = stringValue.WriteTo(writer)

    member _.StringValue = stringValue
    member _.ValueEquals(other) = stringValue.ValueEquals(other)

    static member FromElement(element) =
        TokenFormat(global.Amongonz.LspTypes.LspString.FromElement(element))

    static member FromString(value) =
        match validate (TokenFormat(value)) with
        | global.FSharp.Core.Ok value -> value
        | global.FSharp.Core.Error() -> global.FSharp.Core.Operators.invalidArg "value" "Invalid string enum constant."

    static member Parse(element: global.System.Text.Json.JsonElement) =
        match LspString.Parse(element) with
        | global.FSharp.Core.Ok stringValue -> validate (TokenFormat(stringValue))
        | global.FSharp.Core.Error() -> global.FSharp.Core.Error()

[<global.FSharp.Core.RequireQualifiedAccess>]
module TokenFormat =

    [<return: Struct>]
    let (|Relative|_|) (value: TokenFormat) =
        if value.ValueEquals("relative") then
            global.FSharp.Core.ValueSome()
        else
            global.FSharp.Core.ValueNone

[<global.FSharp.Core.AutoOpen>]
module EnumerationExtensions =

    type SymbolKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<SymbolKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<SymbolKind> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<SymbolKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type SymbolTag with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<SymbolTag> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<SymbolTag> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<SymbolTag> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InlayHintKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InlayHintKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InlayHintKind> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InlayHintKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type MessageType with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<MessageType> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<MessageType> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<MessageType> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type TextDocumentSyncKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<TextDocumentSyncKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<TextDocumentSyncKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<TextDocumentSyncKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type TextDocumentSaveReason with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<TextDocumentSaveReason> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<TextDocumentSaveReason> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<TextDocumentSaveReason> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CompletionItemKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CompletionItemKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CompletionItemKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CompletionItemKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CompletionItemTag with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CompletionItemTag> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CompletionItemTag> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CompletionItemTag> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InsertTextFormat with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InsertTextFormat> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InsertTextFormat> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InsertTextFormat> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InsertTextMode with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InsertTextMode> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InsertTextMode> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InsertTextMode> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type DocumentHighlightKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<DocumentHighlightKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<DocumentHighlightKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<DocumentHighlightKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type InlineCompletionTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<InlineCompletionTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<InlineCompletionTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<InlineCompletionTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type FileChangeType with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<FileChangeType> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<FileChangeType> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<FileChangeType> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type DiagnosticSeverity with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<DiagnosticSeverity> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<DiagnosticSeverity> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<DiagnosticSeverity> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type DiagnosticTag with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<DiagnosticTag> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<DiagnosticTag> value) ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<DiagnosticTag> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CompletionTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CompletionTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CompletionTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CompletionTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type SignatureHelpTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<SignatureHelpTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<SignatureHelpTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<SignatureHelpTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type CodeActionTriggerKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<CodeActionTriggerKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<CodeActionTriggerKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<CodeActionTriggerKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type NotebookCellKind with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<NotebookCellKind> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<NotebookCellKind> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<NotebookCellKind> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

    type PrepareSupportDefaultBehavior with
        static member FromElement(element: global.System.Text.Json.JsonElement) =
            global.FSharp.Core.Operators.enum<PrepareSupportDefaultBehavior> (element.GetInt32())

        static member Parse(element: global.System.Text.Json.JsonElement) =
            match element.ValueKind with
            | global.System.Text.Json.JsonValueKind.Number ->
                match element.TryGetInt32() with
                | true, value when
                    global.System.Enum.IsDefined(global.FSharp.Core.Operators.enum<PrepareSupportDefaultBehavior> value)
                    ->
                    global.FSharp.Core.Ok(global.FSharp.Core.Operators.enum<PrepareSupportDefaultBehavior> value)
                | _ -> global.FSharp.Core.Error()
            | _ -> global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        ImplementationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(ImplementationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a location inside a resource, such as a line
/// inside a text file.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Location
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``range``: Range
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Location(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspDocumentUri, ``range``: Range) =
        Location(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``range`` = ``range``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(Location.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        ImplementationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ImplementationRegistrationOptions.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        TypeDefinitionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeDefinitionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        TypeDefinitionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TypeDefinitionRegistrationOptions.FromElement(element))

/// A workspace folder inside a client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFolder
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.System.Uri
                ``name``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFolder(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The associated URI for this workspace folder.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    /// The name of the workspace folder. Used to refer to this
    /// workspace folder in the user interface.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``uri``: global.System.Uri, ``name``: global.Amongonz.LspTypes.LspString) =
        WorkspaceFolder(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``name`` = ``name``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``name``
                    writer.WritePropertyName("name")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "name" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkspaceFolder.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameters of a `workspace/didChangeWorkspaceFolders` notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWorkspaceFoldersParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``event``: WorkspaceFoldersChangeEvent
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWorkspaceFoldersParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual workspace folder change event.
    member _.Event =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``event``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("event")
            WorkspaceFoldersChangeEvent.FromElement(prop)

    static member Create(``event``: WorkspaceFoldersChangeEvent) =
        DidChangeWorkspaceFoldersParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``event`` = ``event`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``event``
                    writer.WritePropertyName("event")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "event" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceFoldersChangeEvent.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidChangeWorkspaceFoldersParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameters of a configuration request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ConfigurationParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ConfigurationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        ConfigurationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``items`` = ``items`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ConfigurationParams.FromElement(element))

/// Parameters for a {@link DocumentColorRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentColorParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentColorParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a color range from a document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ColorInformation
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``range``: Range; ``color``: Color |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ColorInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range in the document where this color appears.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The actual color value for this color range.
    member _.Color =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``color``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("color")
            Color.FromElement(prop)

    static member Create(``range``: Range, ``color``: Color) =
        ColorInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``color`` = ``color``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``color``
                    writer.WritePropertyName("color")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "color" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Color.Parse(prop)))
        then
            global.FSharp.Core.Ok(ColorInformation.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        DocumentColorRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentColorRegistrationOptions.FromElement(element))

/// Parameters for a {@link ColorPresentationRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ColorPresentationParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``color``: Color
                ``range``: Range
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ColorPresentationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The color to request presentations for.
    member _.Color =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``color``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("color")
            Color.FromElement(prop)

    /// The range where the color would be inserted. Serves as a context.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``color``: Color,
            ``range``: Range,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        ColorPresentationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``color`` = ``color``
                    ``range`` = ``range``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``color``
                    writer.WritePropertyName("color")
                    value.WriteTo(writer)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "color" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Color.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(ColorPresentationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ColorPresentation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``label``: global.Amongonz.LspTypes.LspString
                ``textEdit``: TextEdit option
                ``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ColorPresentation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this color presentation. It will be shown on the color
    /// picker header. By default this is also the text that is inserted when selecting
    /// this color presentation.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An {@link TextEdit edit} which is applied to a document when selecting
    /// this presentation for the color.  When `falsy` the {@link ColorPresentation.label label}
    /// is used.
    member _.TextEdit =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``textEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextEdit.FromElement(prop))

    /// An optional array of additional {@link TextEdit text edits} that are applied when
    /// selecting this color presentation. Edits must not overlap with the main {@link ColorPresentation.textEdit edit} nor with themselves.
    member _.AdditionalTextEdits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``additionalTextEdits`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("additionalTextEdits") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``textEdit``: TextEdit,
            ?``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        ColorPresentation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``label`` = ``label``
                    ``textEdit`` = ``textEdit``
                    ``additionalTextEdits`` = ``additionalTextEdits``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``label``
                    writer.WritePropertyName("label")
                    value.WriteTo(writer)

                    match backingObj.``textEdit`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("textEdit")
                        value.WriteTo(writer)

                    match backingObj.``additionalTextEdits`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("additionalTextEdits")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ColorPresentation.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        WorkDoneProgressOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(WorkDoneProgressOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// General text document registration options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        TextDocumentRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentRegistrationOptions.FromElement(element))

/// Parameters for a {@link FoldingRangeRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        FoldingRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(FoldingRangeParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a folding range. To be valid, start and end line must be bigger than zero and smaller
/// than the number of lines in the document. Clients are free to ignore invalid ranges.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRange
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``startLine``: global.FSharp.Core.int
                ``startCharacter``: global.FSharp.Core.int option
                ``endLine``: global.FSharp.Core.int
                ``endCharacter``: global.FSharp.Core.int option
                ``kind``: FoldingRangeKind option
                ``collapsedText``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRange(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The zero-based start line of the range to fold. The folded area starts after the line&apos;s last character.
    /// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
    member _.StartLine =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``startLine``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("startLine")
            prop.GetInt32()

    /// The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
    member _.StartCharacter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``startCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("startCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// The zero-based end line of the range to fold. The folded area ends with the line&apos;s last character.
    /// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
    member _.EndLine =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``endLine``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("endLine")
            prop.GetInt32()

    /// The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
    member _.EndCharacter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``endCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("endCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// Describes the kind of the folding range such as `comment&apos; or &apos;region&apos;. The kind
    /// is used to categorize folding ranges and used by commands like &apos;Fold all comments&apos;.
    /// See {@link FoldingRangeKind} for an enumeration of standardized kinds.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FoldingRangeKind.FromElement(prop))

    /// The text that the client should show when the specified range is
    /// collapsed. If not defined or not supported by the client, a default
    /// will be chosen by the client.
    ///
    /// @since 3.17.0
    member _.CollapsedText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``collapsedText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("collapsedText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``startLine``: global.FSharp.Core.int,
            ``endLine``: global.FSharp.Core.int,
            ?``startCharacter``: global.FSharp.Core.int,
            ?``endCharacter``: global.FSharp.Core.int,
            ?``kind``: FoldingRangeKind,
            ?``collapsedText``: global.Amongonz.LspTypes.LspString
        ) =
        FoldingRange(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``startLine`` = ``startLine``
                    ``startCharacter`` = ``startCharacter``
                    ``endLine`` = ``endLine``
                    ``endCharacter`` = ``endCharacter``
                    ``kind`` = ``kind``
                    ``collapsedText`` = ``collapsedText``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``startLine``
                    writer.WriteNumber("startLine", value)

                    match backingObj.``startCharacter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("startCharacter", value)

                    let value = backingObj.``endLine``
                    writer.WriteNumber("endLine", value)

                    match backingObj.``endCharacter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("endCharacter", value)

                    match backingObj.``kind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("kind")
                        value.WriteTo(writer)

                    match backingObj.``collapsedText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("collapsedText")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "startLine" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "startCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "endLine" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "endCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FoldingRangeKind.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "collapsedText" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FoldingRange.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        FoldingRangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FoldingRangeRegistrationOptions.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DeclarationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DeclarationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        DeclarationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DeclarationRegistrationOptions.FromElement(element))

/// A parameter literal used in selection range requests.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``positions``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The positions inside the text document.
    member _.Positions =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``positions``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("positions")
            LspJsonBacking.Element prop

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``positions``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SelectionRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``positions`` = ``positions``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``positions``
                    writer.WritePropertyName("positions")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SelectionRangeParams.FromElement(element))

/// A selection range represents a part of a selection hierarchy. A selection range
/// may have a parent selection range that contains it.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRange
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``parent``: SelectionRange option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRange(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The {@link Range range} of this selection range.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
    member _.Parent =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``parent`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("parent") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SelectionRange.FromElement(prop))

    static member Create(``range``: Range, ?``parent``: SelectionRange) =
        SelectionRange(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``parent`` = ``parent``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``parent`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("parent")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "parent" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SelectionRange.Parse(prop)))
        then
            global.FSharp.Core.Ok(SelectionRange.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        SelectionRangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SelectionRangeRegistrationOptions.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressCreateParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``token``: ProgressToken |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressCreateParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The token to be used to report progress.
    member _.Token =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``token``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("token")
            ProgressToken.FromElement(prop)

    static member Create(``token``: ProgressToken) =
        WorkDoneProgressCreateParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``token`` = ``token`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``token``
                    writer.WritePropertyName("token")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "token" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkDoneProgressCreateParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressCancelParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``token``: ProgressToken |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressCancelParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The token to be used to report progress.
    member _.Token =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``token``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("token")
            ProgressToken.FromElement(prop)

    static member Create(``token``: ProgressToken) =
        WorkDoneProgressCancelParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``token`` = ``token`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``token``
                    writer.WritePropertyName("token")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "token" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkDoneProgressCancelParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameter of a `textDocument/prepareCallHierarchy` request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyPrepareParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyPrepareParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        CallHierarchyPrepareParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CallHierarchyPrepareParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents programming constructs like functions or constructors in the context
/// of call hierarchy.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyItem
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``name``: global.Amongonz.LspTypes.LspString
                ``kind``: SymbolKind
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``detail``: global.Amongonz.LspTypes.LspString option
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``range``: Range
                ``selectionRange``: Range
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this item.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this item.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this item.
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// More detail for this item, e.g. the signature of a function.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The resource identifier of this item.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
    /// Must be contained by the {@link CallHierarchyItem.range `range`}.
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``selectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("selectionRange")
            Range.FromElement(prop)

    /// A data entry field that is preserved between a call hierarchy prepare and
    /// incoming calls or outgoing calls requests.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``range``: Range,
            ``selectionRange``: Range,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``data``: LSPAny
        ) =
        CallHierarchyItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``name`` = ``name``
                    ``kind`` = ``kind``
                    ``tags`` = ``tags``
                    ``detail`` = ``detail``
                    ``uri`` = ``uri``
                    ``range`` = ``range``
                    ``selectionRange`` = ``selectionRange``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``name``
                    writer.WritePropertyName("name")
                    value.WriteTo(writer)
                    let value = backingObj.``kind``
                    writer.WriteNumber("kind", int value)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``detail`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("detail")
                        value.WriteTo(writer)

                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``selectionRange``
                    writer.WritePropertyName("selectionRange")
                    value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyItem.FromElement(element))

/// Call hierarchy options used during static or dynamic registration.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        CallHierarchyRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyRegistrationOptions.FromElement(element))

/// The parameter of a `callHierarchy/incomingCalls` request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyIncomingCallsParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``item``: CallHierarchyItem
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyIncomingCallsParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            CallHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: CallHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        CallHierarchyIncomingCallsParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``item`` = ``item``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``item``
                    writer.WritePropertyName("item")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (CallHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CallHierarchyIncomingCallsParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents an incoming call, e.g. a caller of a method or constructor.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyIncomingCall
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``from``: CallHierarchyItem
                ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyIncomingCall(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The item that makes the call.
    member _.From =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``from``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("from")
            CallHierarchyItem.FromElement(prop)

    /// The ranges at which the calls appear. This is relative to the caller
    /// denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
    member _.FromRanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``fromRanges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("fromRanges")
            LspJsonBacking.Element prop

    static member Create(``from``: CallHierarchyItem, ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        CallHierarchyIncomingCall(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``from`` = ``from``
                    ``fromRanges`` = ``fromRanges``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``from``
                    writer.WritePropertyName("from")
                    value.WriteTo(writer)
                    let value = backingObj.``fromRanges``
                    writer.WritePropertyName("fromRanges")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyIncomingCall.FromElement(element))

/// The parameter of a `callHierarchy/outgoingCalls` request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyOutgoingCallsParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``item``: CallHierarchyItem
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyOutgoingCallsParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            CallHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: CallHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        CallHierarchyOutgoingCallsParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``item`` = ``item``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``item``
                    writer.WritePropertyName("item")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (CallHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CallHierarchyOutgoingCallsParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyOutgoingCall
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``to``: CallHierarchyItem
                ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyOutgoingCall(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The item that is called.
    member _.To =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``to``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("to")
            CallHierarchyItem.FromElement(prop)

    /// The range at which this item is called. This is the range relative to the caller, e.g the item
    /// passed to {@link CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls `provideCallHierarchyOutgoingCalls`}
    /// and not {@link CallHierarchyOutgoingCall.to `this.to`}.
    member _.FromRanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``fromRanges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("fromRanges")
            LspJsonBacking.Element prop

    static member Create(``to``: CallHierarchyItem, ``fromRanges``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        CallHierarchyOutgoingCall(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``to`` = ``to``
                    ``fromRanges`` = ``fromRanges``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``to``
                    writer.WritePropertyName("to")
                    value.WriteTo(writer)
                    let value = backingObj.``fromRanges``
                    writer.WritePropertyName("fromRanges")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CallHierarchyOutgoingCall.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SemanticTokensParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SemanticTokensParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokens
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resultId``: global.Amongonz.LspTypes.LspString option
                ``data``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokens(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional result id. If provided and clients support delta updating
    /// the client will include the result id in the next semantic token request.
    /// A server can then instead of computing all semantic tokens again simply
    /// send a delta.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual tokens.
    member _.Data =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``data``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("data")
            LspJsonBacking.Element prop

    static member Create
        (``data``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``resultId``: global.Amongonz.LspTypes.LspString) =
        SemanticTokens(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resultId`` = ``resultId``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resultId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resultId")
                        value.WriteTo(writer)

                    let value = backingObj.``data``
                    writer.WritePropertyName("data")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokens.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensPartialResult
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``data``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Data =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``data``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("data")
            LspJsonBacking.Element prop

    static member Create(``data``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        SemanticTokensPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``data`` = ``data`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``data``
                    writer.WritePropertyName("data")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensPartialResult.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``legend``: SemanticTokensLegend
                ``range``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``full``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The legend used by the server
    member _.Legend =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``legend``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("legend")
            SemanticTokensLegend.FromElement(prop)

    /// Server supports providing semantic tokens for a specific range
    /// of a document.
    member _.Range =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Server supports providing semantic tokens for a full document.
    member _.Full =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``full`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("full") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``legend``: SemanticTokensLegend,
            ?``range``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``full``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        SemanticTokensRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``legend`` = ``legend``
                    ``range`` = ``range``
                    ``full`` = ``full``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    let value = backingObj.``legend``
                    writer.WritePropertyName("legend")
                    value.WriteTo(writer)

                    match backingObj.``range`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("range")
                        value.WriteTo(writer)

                    match backingObj.``full`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("full")
                        value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensRegistrationOptions.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensDeltaParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``previousResultId``: global.Amongonz.LspTypes.LspString
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensDeltaParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The result id of a previous response. The result Id can either point to a full response
    /// or a delta response depending on what was received last.
    member _.PreviousResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``previousResultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("previousResultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``previousResultId``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SemanticTokensDeltaParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``previousResultId`` = ``previousResultId``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``previousResultId``
                    writer.WritePropertyName("previousResultId")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "previousResultId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SemanticTokensDeltaParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensDelta
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resultId``: global.Amongonz.LspTypes.LspString option
                ``edits``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensDelta(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The semantic token edits to transform a previous result into a new result.
    member _.Edits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``edits``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edits")
            LspJsonBacking.Element prop

    static member Create
        (``edits``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``resultId``: global.Amongonz.LspTypes.LspString) =
        SemanticTokensDelta(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resultId`` = ``resultId``
                    ``edits`` = ``edits``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resultId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resultId")
                        value.WriteTo(writer)

                    let value = backingObj.``edits``
                    writer.WritePropertyName("edits")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensDelta.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensDeltaPartialResult
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``edits``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensDeltaPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Edits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``edits``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edits")
            LspJsonBacking.Element prop

    static member Create(``edits``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        SemanticTokensDeltaPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``edits`` = ``edits`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``edits``
                    writer.WritePropertyName("edits")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensDeltaPartialResult.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensRangeParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``range``: Range
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The range the semantic tokens are requested for.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        SemanticTokensRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``range`` = ``range``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SemanticTokensRangeParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Params to show a resource in the UI.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.System.Uri
                ``external``: global.FSharp.Core.bool option
                ``takeFocus``: global.FSharp.Core.bool option
                ``selection``: Range option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The uri to show.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    /// Indicates to show the resource in an external program.
    /// To show, for example, `https://code.visualstudio.com/`
    /// in the default WEB browser set `external` to `true`.
    member _.External =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``external`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("external") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// An optional property to indicate whether the editor
    /// showing the document should take focus or not.
    /// Clients might ignore this property if an external
    /// program is started.
    member _.TakeFocus =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``takeFocus`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("takeFocus") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// An optional selection range if the document is a text
    /// document. Clients might ignore the property if an
    /// external program is started or the file is not a text
    /// file.
    member _.Selection =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``selection`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selection") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    static member Create
        (
            ``uri``: global.System.Uri,
            ?``external``: global.FSharp.Core.bool,
            ?``takeFocus``: global.FSharp.Core.bool,
            ?``selection``: Range
        ) =
        ShowDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``external`` = ``external``
                    ``takeFocus`` = ``takeFocus``
                    ``selection`` = ``selection``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)

                    match backingObj.``external`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("external", value)

                    match backingObj.``takeFocus`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("takeFocus", value)

                    match backingObj.``selection`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("selection")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "external" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "takeFocus" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "selection" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(ShowDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The result of a showDocument request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowDocumentResult
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``success``: global.FSharp.Core.bool
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowDocumentResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A boolean indicating if the show was successful.
    member _.Success =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``success``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("success")
            prop.GetBoolean()

    static member Create(``success``: global.FSharp.Core.bool) =
        ShowDocumentResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``success`` = ``success`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``success``
                    writer.WriteBoolean("success", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "success" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ShowDocumentResult.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        LinkedEditingRangeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(LinkedEditingRangeParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The result of a linked editing range request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRanges
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``ranges``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``wordPattern``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRanges(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A list of ranges that can be edited together. The ranges must have
    /// identical length and contain identical text content. The ranges cannot overlap.
    member _.Ranges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``ranges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("ranges")
            LspJsonBacking.Element prop

    /// An optional word pattern (regular expression) that describes valid contents for
    /// the given ranges. If no pattern is provided, the client configuration&apos;s word
    /// pattern will be used.
    member _.WordPattern =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``wordPattern`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("wordPattern") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``ranges``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``wordPattern``: global.Amongonz.LspTypes.LspString) =
        LinkedEditingRanges(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``ranges`` = ``ranges``
                    ``wordPattern`` = ``wordPattern``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``ranges``
                    writer.WritePropertyName("ranges")
                    value.WriteTo(writer)

                    match backingObj.``wordPattern`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("wordPattern")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(LinkedEditingRanges.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        LinkedEditingRangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(LinkedEditingRangeRegistrationOptions.FromElement(element))

/// The parameters sent in notifications/requests for user-initiated creation of
/// files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CreateFilesParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``files``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CreateFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of all files/folders created in this operation.
    member _.Files =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``files``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("files")
            LspJsonBacking.Element prop

    static member Create(``files``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        CreateFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``files`` = ``files`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``files``
                    writer.WritePropertyName("files")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CreateFilesParams.FromElement(element))

/// A workspace edit represents changes to many resources managed in the workspace. The edit
/// should either provide `changes` or `documentChanges`. If documentChanges are present
/// they are preferred over `changes` if the client can handle versioned document edits.
///
/// Since version 3.13.0 a workspace edit can contain resource operations as well. If resource
/// operations are present clients need to execute the operations in the order in which they
/// are provided. So a workspace edit for example can consist of the following two changes:
/// (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.
///
/// An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will
/// cause failure of the operation. How the client recovers from the failure is described by
/// the client capability: `workspace.workspaceEdit.failureHandling`
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceEdit
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``changes``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``documentChanges``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``changeAnnotations``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Holds changes to existing resources.
    member _.Changes =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``changes`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changes") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
    /// are either an array of `TextDocumentEdit`s to express changes to n different text documents
    /// where each text document edit addresses a specific version of a text document. Or it can contain
    /// above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
    ///
    /// Whether a client supports versioned document edits is expressed via
    /// `workspace.workspaceEdit.documentChanges` client capability.
    ///
    /// If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
    /// only plain `TextEdit`s using the `changes` property are supported.
    member _.DocumentChanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentChanges`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentChanges") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
    /// delete file / folder operations.
    ///
    /// Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.
    ///
    /// @since 3.16.0
    member _.ChangeAnnotations =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``changeAnnotations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changeAnnotations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``changes``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``documentChanges``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``changeAnnotations``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        WorkspaceEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``changes`` = ``changes``
                    ``documentChanges`` = ``documentChanges``
                    ``changeAnnotations`` = ``changeAnnotations``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``changes`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("changes")
                        value.WriteTo(writer)

                    match backingObj.``documentChanges`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentChanges")
                        value.WriteTo(writer)

                    match backingObj.``changeAnnotations`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("changeAnnotations")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceEdit.FromElement(element))

/// The options to register for file operations.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``filters``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual filters.
    member _.Filters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``filters``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("filters")
            LspJsonBacking.Element prop

    static member Create(``filters``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        FileOperationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``filters`` = ``filters`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``filters``
                    writer.WritePropertyName("filters")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FileOperationRegistrationOptions.FromElement(element))

/// The parameters sent in notifications/requests for user-initiated renames of
/// files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameFilesParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``files``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of all files/folders renamed in this operation. When a folder is renamed, only
    /// the folder will be included, and not its children.
    member _.Files =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``files``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("files")
            LspJsonBacking.Element prop

    static member Create(``files``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        RenameFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``files`` = ``files`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``files``
                    writer.WritePropertyName("files")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RenameFilesParams.FromElement(element))

/// The parameters sent in notifications/requests for user-initiated deletes of
/// files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeleteFilesParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``files``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeleteFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of all files/folders deleted in this operation.
    member _.Files =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``files``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("files")
            LspJsonBacking.Element prop

    static member Create(``files``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DeleteFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``files`` = ``files`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``files``
                    writer.WritePropertyName("files")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DeleteFilesParams.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        MonikerParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(MonikerParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Moniker definition to match LSIF 0.5 moniker definition.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Moniker
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``scheme``: global.Amongonz.LspTypes.LspString
                ``identifier``: global.Amongonz.LspTypes.LspString
                ``unique``: UniquenessLevel
                ``kind``: MonikerKind option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Moniker(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The scheme of the moniker. For example tsc or .Net
    member _.Scheme =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``scheme``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("scheme")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The identifier of the moniker. The value is opaque in LSIF however
    /// schema owners are allowed to define the structure if they want.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``identifier``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("identifier")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The scope in which the moniker is unique
    member _.Unique =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``unique``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("unique")
            UniquenessLevel.FromElement(prop)

    /// The moniker kind if known.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(MonikerKind.FromElement(prop))

    static member Create
        (
            ``scheme``: global.Amongonz.LspTypes.LspString,
            ``identifier``: global.Amongonz.LspTypes.LspString,
            ``unique``: UniquenessLevel,
            ?``kind``: MonikerKind
        ) =
        Moniker(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``scheme`` = ``scheme``
                    ``identifier`` = ``identifier``
                    ``unique`` = ``unique``
                    ``kind`` = ``kind``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``scheme``
                    writer.WritePropertyName("scheme")
                    value.WriteTo(writer)
                    let value = backingObj.``identifier``
                    writer.WritePropertyName("identifier")
                    value.WriteTo(writer)
                    let value = backingObj.``unique``
                    writer.WritePropertyName("unique")
                    value.WriteTo(writer)

                    match backingObj.``kind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("kind")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "scheme" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "identifier" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "unique" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (UniquenessLevel.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (MonikerKind.Parse(prop)))
        then
            global.FSharp.Core.Ok(Moniker.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        MonikerRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(MonikerRegistrationOptions.FromElement(element))

/// The parameter of a `textDocument/prepareTypeHierarchy` request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyPrepareParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyPrepareParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        TypeHierarchyPrepareParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeHierarchyPrepareParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyItem
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``name``: global.Amongonz.LspTypes.LspString
                ``kind``: SymbolKind
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``detail``: global.Amongonz.LspTypes.LspString option
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``range``: Range
                ``selectionRange``: Range
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this item.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this item.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this item.
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// More detail for this item, e.g. the signature of a function.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The resource identifier of this item.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The range enclosing this symbol not including leading/trailing whitespace
    /// but everything else, e.g. comments and code.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this symbol is being
    /// picked, e.g. the name of a function. Must be contained by the
    /// {@link TypeHierarchyItem.range `range`}.
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``selectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("selectionRange")
            Range.FromElement(prop)

    /// A data entry field that is preserved between a type hierarchy prepare and
    /// supertypes or subtypes requests. It could also be used to identify the
    /// type hierarchy in the server, helping improve the performance on
    /// resolving supertypes and subtypes.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``range``: Range,
            ``selectionRange``: Range,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``data``: LSPAny
        ) =
        TypeHierarchyItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``name`` = ``name``
                    ``kind`` = ``kind``
                    ``tags`` = ``tags``
                    ``detail`` = ``detail``
                    ``uri`` = ``uri``
                    ``range`` = ``range``
                    ``selectionRange`` = ``selectionRange``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``name``
                    writer.WritePropertyName("name")
                    value.WriteTo(writer)
                    let value = backingObj.``kind``
                    writer.WriteNumber("kind", int value)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``detail`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("detail")
                        value.WriteTo(writer)

                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``selectionRange``
                    writer.WritePropertyName("selectionRange")
                    value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TypeHierarchyItem.FromElement(element))

/// Type hierarchy options used during static or dynamic registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        TypeHierarchyRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TypeHierarchyRegistrationOptions.FromElement(element))

/// The parameter of a `typeHierarchy/supertypes` request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchySupertypesParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``item``: TypeHierarchyItem
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchySupertypesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            TypeHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: TypeHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        TypeHierarchySupertypesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``item`` = ``item``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``item``
                    writer.WritePropertyName("item")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeHierarchySupertypesParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameter of a `typeHierarchy/subtypes` request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchySubtypesParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``item``: TypeHierarchyItem
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchySubtypesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Item =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``item``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("item")
            TypeHierarchyItem.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``item``: TypeHierarchyItem, ?``workDoneToken``: ProgressToken, ?``partialResultToken``: ProgressToken) =
        TypeHierarchySubtypesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``item`` = ``item``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``item``
                    writer.WritePropertyName("item")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "item" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeHierarchyItem.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(TypeHierarchySubtypesParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A parameter literal used in inline value requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``range``: Range
                ``context``: InlineValueContext
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The document range for which inline values should be computed.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// Additional information about the context in which inline values were
    /// requested.
    member _.Context =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            InlineValueContext.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ``context``: InlineValueContext,
            ?``workDoneToken``: ProgressToken
        ) =
        InlineValueParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``range`` = ``range``
                    ``context`` = ``context``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``context``
                    writer.WritePropertyName("context")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineValueContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Inline value options used during static or dynamic registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        InlineValueRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineValueRegistrationOptions.FromElement(element))

/// A parameter literal used in inlay hint requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``range``: Range
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The document range for which inlay hints should be computed.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``range``: Range, ?``workDoneToken``: ProgressToken)
        =
        InlayHintParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``range`` = ``range``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlayHintParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Inlay hint information.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHint
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``position``: Position
                ``label``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``kind``: InlayHintKind option
                ``textEdits``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``paddingLeft``: global.FSharp.Core.bool option
                ``paddingRight``: global.FSharp.Core.bool option
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHint(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The position of this hint.
    ///
    /// If multiple hints have the same position, they will be shown in the order
    /// they appear in the response.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// The label of this hint. A human readable string or an array of
    /// InlayHintLabelPart label parts.
    ///
    /// *Note* that neither the string nor the label part can be empty.
    member _.Label =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            LspJsonBacking.Element prop

    /// The kind of this hint. Can be omitted in which case the client
    /// should fall back to a reasonable default.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlayHintKind.FromElement(prop))

    /// Optional text edits that are performed when accepting this inlay hint.
    ///
    /// *Note* that edits are expected to change the document so that the inlay
    /// hint (or its nearest variant) is now part of the document and the inlay
    /// hint itself is now obsolete.
    member _.TextEdits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``textEdits`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEdits") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The tooltip text when you hover over this item.
    member _.Tooltip =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tooltip`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltip") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Render padding before the hint.
    ///
    /// Note: Padding should use the editor&apos;s background color, not the
    /// background color of the hint itself. That means padding can be used
    /// to visually align/separate an inlay hint.
    member _.PaddingLeft =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``paddingLeft`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("paddingLeft") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Render padding after the hint.
    ///
    /// Note: Padding should use the editor&apos;s background color, not the
    /// background color of the hint itself. That means padding can be used
    /// to visually align/separate an inlay hint.
    member _.PaddingRight =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``paddingRight`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("paddingRight") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A data entry field that is preserved on an inlay hint between
    /// a `textDocument/inlayHint` and a `inlayHint/resolve` request.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``position``: Position,
            ``label``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``kind``: InlayHintKind,
            ?``textEdits``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``paddingLeft``: global.FSharp.Core.bool,
            ?``paddingRight``: global.FSharp.Core.bool,
            ?``data``: LSPAny
        ) =
        InlayHint(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``position`` = ``position``
                    ``label`` = ``label``
                    ``kind`` = ``kind``
                    ``textEdits`` = ``textEdits``
                    ``tooltip`` = ``tooltip``
                    ``paddingLeft`` = ``paddingLeft``
                    ``paddingRight`` = ``paddingRight``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)
                    let value = backingObj.``label``
                    writer.WritePropertyName("label")
                    value.WriteTo(writer)

                    match backingObj.``kind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("kind", int value)

                    match backingObj.``textEdits`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("textEdits")
                        value.WriteTo(writer)

                    match backingObj.``tooltip`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tooltip")
                        value.WriteTo(writer)

                    match backingObj.``paddingLeft`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("paddingLeft", value)

                    match backingObj.``paddingRight`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("paddingRight", value)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHint.FromElement(element))

/// Inlay hint options used during static or dynamic registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resolveProvider``: global.FSharp.Core.bool option
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for an inlay hint item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        InlayHintRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resolveProvider`` = ``resolveProvider``
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHintRegistrationOptions.FromElement(element))

/// Parameters of the document diagnostic request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``identifier``: global.Amongonz.LspTypes.LspString option
                ``previousResultId``: global.Amongonz.LspTypes.LspString option
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentDiagnosticParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The additional identifier  provided during registration.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The result id of a previous response if provided.
    member _.PreviousResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``previousResultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("previousResultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``previousResultId``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentDiagnosticParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``identifier`` = ``identifier``
                    ``previousResultId`` = ``previousResultId``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``identifier`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("identifier")
                        value.WriteTo(writer)

                    match backingObj.``previousResultId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("previousResultId")
                        value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "identifier" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "previousResultId" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentDiagnosticParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A partial result for a document diagnostic report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticReportPartialResult
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentDiagnosticReportPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.RelatedDocuments =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``relatedDocuments``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("relatedDocuments")
            LspJsonBacking.Element prop

    static member Create(``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DocumentDiagnosticReportPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``relatedDocuments`` = ``relatedDocuments``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``relatedDocuments``
                    writer.WritePropertyName("relatedDocuments")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentDiagnosticReportPartialResult.FromElement(element))

/// Cancellation data returned from a diagnostic request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticServerCancellationData
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``retriggerRequest``: global.FSharp.Core.bool
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticServerCancellationData(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.RetriggerRequest =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``retriggerRequest``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("retriggerRequest")
            prop.GetBoolean()

    static member Create(``retriggerRequest``: global.FSharp.Core.bool) =
        DiagnosticServerCancellationData(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``retriggerRequest`` = ``retriggerRequest``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``retriggerRequest``
                    writer.WriteBoolean("retriggerRequest", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "retriggerRequest" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticServerCancellationData.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Diagnostic registration options.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``identifier``: global.Amongonz.LspTypes.LspString option
                ``interFileDependencies``: global.FSharp.Core.bool
                ``workspaceDiagnostics``: global.FSharp.Core.bool
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// An optional identifier under which the diagnostics are
    /// managed by the client.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Whether the language has inter file dependencies meaning that
    /// editing code in one file can result in a different diagnostic
    /// set in another file. Inter file dependencies are common for
    /// most programming languages and typically uncommon for linters.
    member _.InterFileDependencies =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``interFileDependencies``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("interFileDependencies")
            prop.GetBoolean()

    /// The server provides support for workspace diagnostics as well.
    member _.WorkspaceDiagnostics =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``workspaceDiagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("workspaceDiagnostics")
            prop.GetBoolean()

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``interFileDependencies``: global.FSharp.Core.bool,
            ``workspaceDiagnostics``: global.FSharp.Core.bool,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        DiagnosticRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``identifier`` = ``identifier``
                    ``interFileDependencies`` = ``interFileDependencies``
                    ``workspaceDiagnostics`` = ``workspaceDiagnostics``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``identifier`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("identifier")
                        value.WriteTo(writer)

                    let value = backingObj.``interFileDependencies``
                    writer.WriteBoolean("interFileDependencies", value)
                    let value = backingObj.``workspaceDiagnostics``
                    writer.WriteBoolean("workspaceDiagnostics", value)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DiagnosticRegistrationOptions.FromElement(element))

/// Parameters of the workspace diagnostic request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDiagnosticParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``identifier``: global.Amongonz.LspTypes.LspString option
                ``previousResultIds``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDiagnosticParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The additional identifier provided during registration.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The currently known diagnostic reports with their
    /// previous result ids.
    member _.PreviousResultIds =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``previousResultIds``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("previousResultIds")
            LspJsonBacking.Element prop

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``previousResultIds``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        WorkspaceDiagnosticParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``identifier`` = ``identifier``
                    ``previousResultIds`` = ``previousResultIds``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``identifier`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("identifier")
                        value.WriteTo(writer)

                    let value = backingObj.``previousResultIds``
                    writer.WritePropertyName("previousResultIds")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceDiagnosticParams.FromElement(element))

/// A workspace diagnostic report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDiagnosticReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        WorkspaceDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``items`` = ``items`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceDiagnosticReport.FromElement(element))

/// A partial result for a workspace diagnostic report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDiagnosticReportPartialResult
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDiagnosticReportPartialResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        WorkspaceDiagnosticReportPartialResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``items`` = ``items`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceDiagnosticReportPartialResult.FromElement(element))

/// The params sent in an open notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidOpenNotebookDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``notebookDocument``: NotebookDocument
                ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidOpenNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that got opened.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            NotebookDocument.FromElement(prop)

    /// The text documents that represent the content
    /// of a notebook cell.
    member _.CellTextDocuments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``cellTextDocuments``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("cellTextDocuments")
            LspJsonBacking.Element prop

    static member Create
        (``notebookDocument``: NotebookDocument, ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DidOpenNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``notebookDocument`` = ``notebookDocument``
                    ``cellTextDocuments`` = ``cellTextDocuments``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``notebookDocument``
                    writer.WritePropertyName("notebookDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``cellTextDocuments``
                    writer.WritePropertyName("cellTextDocuments")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidOpenNotebookDocumentParams.FromElement(element))

/// The params sent in a change notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeNotebookDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``notebookDocument``: VersionedNotebookDocumentIdentifier
                ``change``: NotebookDocumentChangeEvent
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that did change. The version number points
    /// to the version after all provided changes have been applied. If
    /// only the text document content of a cell changes the notebook version
    /// doesn&apos;t necessarily have to change.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            VersionedNotebookDocumentIdentifier.FromElement(prop)

    /// The actual changes to the notebook document.
    ///
    /// The changes describe single state changes to the notebook document.
    /// So if there are two changes c1 (at array index 0) and c2 (at array
    /// index 1) for a notebook in state S then c1 moves the notebook from
    /// S to S&apos; and c2 from S&apos; to S&apos;&apos;. So c1 is computed on the state S and
    /// c2 is computed on the state S&apos;.
    ///
    /// To mirror the content of a notebook using change events use the following approach:
    /// - start with the same initial content
    /// - apply the &apos;notebookDocument/didChange&apos; notifications in the order you receive them.
    /// - apply the `NotebookChangeEvent`s in a single notification in the order
    ///   you receive them.
    member _.Change =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``change``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("change")
            NotebookDocumentChangeEvent.FromElement(prop)

    static member Create
        (``notebookDocument``: VersionedNotebookDocumentIdentifier, ``change``: NotebookDocumentChangeEvent)
        =
        DidChangeNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``notebookDocument`` = ``notebookDocument``
                    ``change`` = ``change``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``notebookDocument``
                    writer.WritePropertyName("notebookDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``change``
                    writer.WritePropertyName("change")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "notebookDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (VersionedNotebookDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "change" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentChangeEvent.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidChangeNotebookDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The params sent in a save notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidSaveNotebookDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``notebookDocument``: NotebookDocumentIdentifier
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidSaveNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that got saved.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            NotebookDocumentIdentifier.FromElement(prop)

    static member Create(``notebookDocument``: NotebookDocumentIdentifier) =
        DidSaveNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``notebookDocument`` = ``notebookDocument``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``notebookDocument``
                    writer.WritePropertyName("notebookDocument")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "notebookDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentIdentifier.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidSaveNotebookDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The params sent in a close notebook document notification.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidCloseNotebookDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``notebookDocument``: NotebookDocumentIdentifier
                ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidCloseNotebookDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document that got closed.
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebookDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookDocument")
            NotebookDocumentIdentifier.FromElement(prop)

    /// The text documents that represent the content
    /// of a notebook cell that got closed.
    member _.CellTextDocuments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``cellTextDocuments``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("cellTextDocuments")
            LspJsonBacking.Element prop

    static member Create
        (
            ``notebookDocument``: NotebookDocumentIdentifier,
            ``cellTextDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        DidCloseNotebookDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``notebookDocument`` = ``notebookDocument``
                    ``cellTextDocuments`` = ``cellTextDocuments``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``notebookDocument``
                    writer.WritePropertyName("notebookDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``cellTextDocuments``
                    writer.WritePropertyName("cellTextDocuments")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidCloseNotebookDocumentParams.FromElement(element))

/// A parameter literal used in inline completion requests.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``context``: InlineCompletionContext
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Additional information about the context in which inline completions were
    /// requested.
    member _.Context =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            InlineCompletionContext.FromElement(prop)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``context``: InlineCompletionContext,
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken
        ) =
        InlineCompletionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``context`` = ``context``
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``context``
                    writer.WritePropertyName("context")
                    value.WriteTo(writer)
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineCompletionContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineCompletionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a collection of {@link InlineCompletionItem inline completion items} to be presented in the editor.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionList
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionList(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The inline completion items
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create(``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        InlineCompletionList(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``items`` = ``items`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineCompletionList.FromElement(element))

/// An inline completion item represents a text snippet that is proposed inline to complete text that is being typed.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionItem
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``insertText``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``filterText``: global.Amongonz.LspTypes.LspString option
                ``range``: Range option
                ``command``: Command option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text to replace the range with. Must be set.
    member _.InsertText =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``insertText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("insertText")
            LspJsonBacking.Element prop

    /// A text that is used to decide if this inline completion should be shown. When `falsy` the {@link InlineCompletionItem.insertText} is used.
    member _.FilterText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``filterText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("filterText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The range to replace. Must begin and end on the same line.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    /// An optional {@link Command} that is executed *after* inserting this completion.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    static member Create
        (
            ``insertText``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``filterText``: global.Amongonz.LspTypes.LspString,
            ?``range``: Range,
            ?``command``: Command
        ) =
        InlineCompletionItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``insertText`` = ``insertText``
                    ``filterText`` = ``filterText``
                    ``range`` = ``range``
                    ``command`` = ``command``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``insertText``
                    writer.WritePropertyName("insertText")
                    value.WriteTo(writer)

                    match backingObj.``filterText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("filterText")
                        value.WriteTo(writer)

                    match backingObj.``range`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("range")
                        value.WriteTo(writer)

                    match backingObj.``command`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("command")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineCompletionItem.FromElement(element))

/// Inline completion options used during static or dynamic registration.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``id``: global.Amongonz.LspTypes.LspString) =
        InlineCompletionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlineCompletionRegistrationOptions.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RegistrationParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``registrations``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RegistrationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Registrations =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``registrations``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("registrations")
            LspJsonBacking.Element prop

    static member Create(``registrations``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        RegistrationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``registrations`` = ``registrations``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``registrations``
                    writer.WritePropertyName("registrations")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RegistrationParams.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type UnregistrationParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``unregisterations``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        UnregistrationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Unregisterations =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``unregisterations``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("unregisterations")
            LspJsonBacking.Element prop

    static member Create(``unregisterations``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        UnregistrationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``unregisterations`` = ``unregisterations``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``unregisterations``
                    writer.WritePropertyName("unregisterations")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(UnregistrationParams.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializeParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``processId``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``locale``: global.Amongonz.LspTypes.LspString option
                ``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``capabilities``: ClientCapabilities
                ``initializationOptions``: LSPAny option
                ``trace``: TraceValues option
                ``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The process Id of the parent process that started
    /// the server.
    ///
    /// Is `null` if the process has not been started by another process.
    /// If the parent process is not alive then the server should exit.
    member _.ProcessId =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``processId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("processId")
            LspJsonBacking.Element prop

    /// Information about the client
    ///
    /// @since 3.15.0
    member _.ClientInfo =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``clientInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("clientInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The locale the client is currently showing the user interface
    /// in. This must not necessarily be the locale of the operating
    /// system.
    ///
    /// Uses IETF language tags as the value&apos;s syntax
    /// (See https://en.wikipedia.org/wiki/IETF_language_tag)
    ///
    /// @since 3.16.0
    member _.Locale =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``locale`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("locale") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The rootPath of the workspace. Is null
    /// if no folder is open.
    ///
    /// @deprecated in favour of rootUri.
    [<global.System.Obsolete("in favour of rootUri.")>]
    member _.RootPath =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rootPath`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rootPath") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The rootUri of the workspace. Is null if no
    /// folder is open. If both `rootPath` and `rootUri` are set
    /// `rootUri` wins.
    ///
    /// @deprecated in favour of workspaceFolders.
    [<global.System.Obsolete("in favour of workspaceFolders.")>]
    member _.RootUri =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``rootUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("rootUri")
            LspJsonBacking.Element prop

    /// The capabilities provided by the client (editor or tool)
    member _.Capabilities =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``capabilities``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("capabilities")
            ClientCapabilities.FromElement(prop)

    /// User provided initialization options.
    member _.InitializationOptions =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``initializationOptions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("initializationOptions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    /// The initial trace setting. If omitted trace is disabled (&apos;off&apos;).
    member _.Trace =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``trace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TraceValues.FromElement(prop))

    /// The workspace folders configured in the client when the server starts.
    ///
    /// This property is only available if the client supports workspace folders.
    /// It can be `null` if the client supports workspace folders but none are
    /// configured.
    ///
    /// @since 3.6.0
    member _.WorkspaceFolders =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workspaceFolders`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceFolders") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``processId``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``capabilities``: ClientCapabilities,
            ?``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``locale``: global.Amongonz.LspTypes.LspString,
            ?``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``initializationOptions``: LSPAny,
            ?``trace``: TraceValues,
            ?``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        InitializeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``processId`` = ``processId``
                    ``clientInfo`` = ``clientInfo``
                    ``locale`` = ``locale``
                    ``rootPath`` = ``rootPath``
                    ``rootUri`` = ``rootUri``
                    ``capabilities`` = ``capabilities``
                    ``initializationOptions`` = ``initializationOptions``
                    ``trace`` = ``trace``
                    ``workspaceFolders`` = ``workspaceFolders``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``processId``
                    writer.WritePropertyName("processId")
                    value.WriteTo(writer)

                    match backingObj.``clientInfo`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("clientInfo")
                        value.WriteTo(writer)

                    match backingObj.``locale`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("locale")
                        value.WriteTo(writer)

                    match backingObj.``rootPath`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("rootPath")
                        value.WriteTo(writer)

                    let value = backingObj.``rootUri``
                    writer.WritePropertyName("rootUri")
                    value.WriteTo(writer)
                    let value = backingObj.``capabilities``
                    writer.WritePropertyName("capabilities")
                    value.WriteTo(writer)

                    match backingObj.``initializationOptions`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("initializationOptions")
                        value.WriteTo(writer)

                    match backingObj.``trace`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("trace")
                        value.WriteTo(writer)

                    match backingObj.``workspaceFolders`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workspaceFolders")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InitializeParams.FromElement(element))

/// The result returned from an initialize request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializeResult
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``capabilities``: ServerCapabilities
                ``serverInfo``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializeResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The capabilities the language server provides.
    member _.Capabilities =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``capabilities``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("capabilities")
            ServerCapabilities.FromElement(prop)

    /// Information about the server.
    ///
    /// @since 3.15.0
    member _.ServerInfo =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``serverInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("serverInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (``capabilities``: ServerCapabilities, ?``serverInfo``: global.Amongonz.LspTypes.LspJsonBacking<obj>)
        =
        InitializeResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``capabilities`` = ``capabilities``
                    ``serverInfo`` = ``serverInfo``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``capabilities``
                    writer.WritePropertyName("capabilities")
                    value.WriteTo(writer)

                    match backingObj.``serverInfo`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("serverInfo")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InitializeResult.FromElement(element))

/// The data type of the ResponseError if the
/// initialize request fails.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializeError
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``retry``: global.FSharp.Core.bool |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializeError(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Indicates whether the client execute the following retry logic:
    /// (1) show the message provided by the ResponseError to the user
    /// (2) user selects retry or cancel
    /// (3) if user selected retry the initialize method is sent again.
    member _.Retry =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``retry``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("retry")
            prop.GetBoolean()

    static member Create(``retry``: global.FSharp.Core.bool) =
        InitializeError(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``retry`` = ``retry`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``retry``
                    writer.WriteBoolean("retry", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "retry" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InitializeError.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InitializedParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<global.FSharp.Core.obj>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InitializedParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Create() =
        InitializedParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                obj (),
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if true then
            global.FSharp.Core.Ok(InitializedParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameters of a change configuration notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeConfigurationParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``settings``: LSPAny |}>)
    =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeConfigurationParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual changed settings
    member _.Settings =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``settings``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("settings")
            LSPAny.FromElement(prop)

    static member Create(``settings``: LSPAny) =
        DidChangeConfigurationParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``settings`` = ``settings`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``settings``
                    writer.WritePropertyName("settings")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "settings" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidChangeConfigurationParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeConfigurationRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``section``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeConfigurationRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Section =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``section`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("section") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create(?``section``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DidChangeConfigurationRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``section`` = ``section`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``section`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("section")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeConfigurationRegistrationOptions.FromElement(element))

/// The parameters of a notification message.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowMessageParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``type``: MessageType
                ``message``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowMessageParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The message type. See {@link MessageType}
    member _.Type =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            MessageType.FromElement(prop)

    /// The actual message.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``type``: MessageType, ``message``: global.Amongonz.LspTypes.LspString) =
        ShowMessageParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``type`` = ``type``
                    ``message`` = ``message``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``type``
                    writer.WriteNumber("type", int value)
                    let value = backingObj.``message``
                    writer.WritePropertyName("message")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "type" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ShowMessageParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowMessageRequestParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``type``: MessageType
                ``message``: global.Amongonz.LspTypes.LspString
                ``actions``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowMessageRequestParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The message type. See {@link MessageType}
    member _.Type =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            MessageType.FromElement(prop)

    /// The actual message.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The message action items to present.
    member _.Actions =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``actions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("actions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``type``: MessageType,
            ``message``: global.Amongonz.LspTypes.LspString,
            ?``actions``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        ShowMessageRequestParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``type`` = ``type``
                    ``message`` = ``message``
                    ``actions`` = ``actions``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``type``
                    writer.WriteNumber("type", int value)
                    let value = backingObj.``message``
                    writer.WritePropertyName("message")
                    value.WriteTo(writer)

                    match backingObj.``actions`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("actions")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ShowMessageRequestParams.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MessageActionItem
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``title``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MessageActionItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A short title like &apos;Retry&apos;, &apos;Open Log&apos; etc.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``title``: global.Amongonz.LspTypes.LspString) =
        MessageActionItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``title`` = ``title`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``title``
                    writer.WritePropertyName("title")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "title" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(MessageActionItem.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The log message parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LogMessageParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``type``: MessageType
                ``message``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LogMessageParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The message type. See {@link MessageType}
    member _.Type =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            MessageType.FromElement(prop)

    /// The actual message.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``type``: MessageType, ``message``: global.Amongonz.LspTypes.LspString) =
        LogMessageParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``type`` = ``type``
                    ``message`` = ``message``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``type``
                    writer.WriteNumber("type", int value)
                    let value = backingObj.``message``
                    writer.WritePropertyName("message")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "type" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(LogMessageParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameters sent in an open text document notification
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidOpenTextDocumentParams
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``textDocument``: TextDocumentItem |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidOpenTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that was opened.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentItem.FromElement(prop)

    static member Create(``textDocument``: TextDocumentItem) =
        DidOpenTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentItem.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidOpenTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The change text document notification&apos;s parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeTextDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: VersionedTextDocumentIdentifier
                ``contentChanges``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that did change. The version number points
    /// to the version after all provided content changes have
    /// been applied.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            VersionedTextDocumentIdentifier.FromElement(prop)

    /// The actual content changes. The content changes describe single state changes
    /// to the document. So if there are two content changes c1 (at array index 0) and
    /// c2 (at array index 1) for a document in state S then c1 moves the document from
    /// S to S&apos; and c2 from S&apos; to S&apos;&apos;. So c1 is computed on the state S and c2 is computed
    /// on the state S&apos;.
    ///
    /// To mirror the content of a document using change events use the following approach:
    /// - start with the same initial content
    /// - apply the &apos;textDocument/didChange&apos; notifications in the order you receive them.
    /// - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
    ///   you receive them.
    member _.ContentChanges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``contentChanges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("contentChanges")
            LspJsonBacking.Element prop

    static member Create
        (
            ``textDocument``: VersionedTextDocumentIdentifier,
            ``contentChanges``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        DidChangeTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``contentChanges`` = ``contentChanges``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``contentChanges``
                    writer.WritePropertyName("contentChanges")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeTextDocumentParams.FromElement(element))

/// Describe options to be used when registered for text document change events.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentChangeRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``syncKind``: TextDocumentSyncKind
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentChangeRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// How documents are synced to the server.
    member _.SyncKind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``syncKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("syncKind")
            TextDocumentSyncKind.FromElement(prop)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create
        (``syncKind``: TextDocumentSyncKind, ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        TextDocumentChangeRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``syncKind`` = ``syncKind``
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``syncKind``
                    writer.WriteNumber("syncKind", int value)
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentChangeRegistrationOptions.FromElement(element))

/// The parameters sent in a close text document notification
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidCloseTextDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidCloseTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that was closed.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    static member Create(``textDocument``: TextDocumentIdentifier) =
        DidCloseTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidCloseTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameters sent in a save text document notification
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidSaveTextDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``text``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidSaveTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that was saved.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// Optional the content when saved. Depends on the includeText value
    /// when the save notification was requested.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``text`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("text") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(``textDocument``: TextDocumentIdentifier, ?``text``: global.Amongonz.LspTypes.LspString) =
        DidSaveTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``text`` = ``text``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``text`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("text")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(DidSaveTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Save registration options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentSaveRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``includeText``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentSaveRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// The client is supposed to include the content on save.
    member _.IncludeText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``includeText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("includeText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``includeText``: global.FSharp.Core.bool) =
        TextDocumentSaveRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``includeText`` = ``includeText``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``includeText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("includeText", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentSaveRegistrationOptions.FromElement(element))

/// The parameters sent in a will save text document notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WillSaveTextDocumentParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``reason``: TextDocumentSaveReason
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WillSaveTextDocumentParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document that will be saved.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The &apos;TextDocumentSaveReason&apos;.
    member _.Reason =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``reason``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("reason")
            TextDocumentSaveReason.FromElement(prop)

    static member Create(``textDocument``: TextDocumentIdentifier, ``reason``: TextDocumentSaveReason) =
        WillSaveTextDocumentParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``reason`` = ``reason``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``reason``
                    writer.WriteNumber("reason", int value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "reason" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
        then
            global.FSharp.Core.Ok(WillSaveTextDocumentParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A text edit applicable to a text document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextEdit
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``newText``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range of the text document to be manipulated. To insert
    /// text into a document create a range where start === end.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The string to be inserted. For delete operations use an
    /// empty string.
    member _.NewText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``newText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newText")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``range``: Range, ``newText``: global.Amongonz.LspTypes.LspString) =
        TextEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``newText`` = ``newText``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``newText``
                    writer.WritePropertyName("newText")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newText" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextEdit.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The watched files change notification&apos;s parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWatchedFilesParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``changes``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWatchedFilesParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual file events.
    member _.Changes =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``changes``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("changes")
            LspJsonBacking.Element prop

    static member Create(``changes``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DidChangeWatchedFilesParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``changes`` = ``changes`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``changes``
                    writer.WritePropertyName("changes")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeWatchedFilesParams.FromElement(element))

/// Describe options to be used when registered for text document change events.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWatchedFilesRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``watchers``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWatchedFilesRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The watchers to register.
    member _.Watchers =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``watchers``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("watchers")
            LspJsonBacking.Element prop

    static member Create(``watchers``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DidChangeWatchedFilesRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``watchers`` = ``watchers`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``watchers``
                    writer.WritePropertyName("watchers")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DidChangeWatchedFilesRegistrationOptions.FromElement(element))

/// The publish diagnostic notification&apos;s parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PublishDiagnosticsParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``version``: global.FSharp.Core.int option
                ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PublishDiagnosticsParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which diagnostic information is reported.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Optional the version number of the document the diagnostics are published for.
    ///
    /// @since 3.15.0
    member _.Version =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``version`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("version") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// An array of diagnostic information items.
    member _.Diagnostics =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``diagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("diagnostics")
            LspJsonBacking.Element prop

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``version``: global.FSharp.Core.int
        ) =
        PublishDiagnosticsParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``version`` = ``version``
                    ``diagnostics`` = ``diagnostics``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)

                    match backingObj.``version`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("version", value)

                    let value = backingObj.``diagnostics``
                    writer.WritePropertyName("diagnostics")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(PublishDiagnosticsParams.FromElement(element))

/// Completion parameters
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``context``: CompletionContext option
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The completion context. This is only available it the client specifies
    /// to send this using the client capability `textDocument.completion.contextSupport === true`
    member _.Context =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``context`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("context") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionContext.FromElement(prop))

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``context``: CompletionContext,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        CompletionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``context`` = ``context``
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``context`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("context")
                        value.WriteTo(writer)

                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CompletionContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CompletionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A completion item represents a text snippet that is
/// proposed to complete text that is being typed.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionItem
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``label``: global.Amongonz.LspTypes.LspString
                ``labelDetails``: CompletionItemLabelDetails option
                ``kind``: CompletionItemKind option
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``detail``: global.Amongonz.LspTypes.LspString option
                ``documentation``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``deprecated``: global.FSharp.Core.bool option
                ``preselect``: global.FSharp.Core.bool option
                ``sortText``: global.Amongonz.LspTypes.LspString option
                ``filterText``: global.Amongonz.LspTypes.LspString option
                ``insertText``: global.Amongonz.LspTypes.LspString option
                ``insertTextFormat``: InsertTextFormat option
                ``insertTextMode``: InsertTextMode option
                ``textEdit``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``textEditText``: global.Amongonz.LspTypes.LspString option
                ``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``commitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``command``: Command option
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this completion item.
    ///
    /// The label property is also by default the text that
    /// is inserted when selecting this completion.
    ///
    /// If label details are provided the label itself should
    /// be an unqualified name of the completion item.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Additional details for the label
    ///
    /// @since 3.17.0
    member _.LabelDetails =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``labelDetails`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("labelDetails") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionItemLabelDetails.FromElement(prop))

    /// The kind of this completion item. Based of the kind
    /// an icon is chosen by the editor.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionItemKind.FromElement(prop))

    /// Tags for this completion item.
    ///
    /// @since 3.15.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A human-readable string with additional information
    /// about this item, like type or symbol information.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A human-readable string that represents a doc-comment.
    member _.Documentation =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Indicates if this item is deprecated.
    /// @deprecated Use `tags` instead.
    [<global.System.Obsolete("Use `tags` instead.")>]
    member _.Deprecated =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``deprecated`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("deprecated") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Select this item when showing.
    ///
    /// *Note* that only one completion item can be selected and that the
    /// tool / client decides which item that is. The rule is that the *first*
    /// item of those that match best is selected.
    member _.Preselect =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``preselect`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("preselect") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A string that should be used when comparing this item
    /// with other items. When `falsy` the {@link CompletionItem.label label}
    /// is used.
    member _.SortText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``sortText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("sortText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A string that should be used when filtering a set of
    /// completion items. When `falsy` the {@link CompletionItem.label label}
    /// is used.
    member _.FilterText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``filterText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("filterText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A string that should be inserted into a document when selecting
    /// this completion. When `falsy` the {@link CompletionItem.label label}
    /// is used.
    ///
    /// The `insertText` is subject to interpretation by the client side.
    /// Some tools might not take the string literally. For example
    /// VS Code when code complete is requested in this example
    /// `con&lt;cursor position&gt;` and a completion item with an `insertText` of
    /// `console` is provided it will only insert `sole`. Therefore it is
    /// recommended to use `textEdit` instead since it avoids additional client
    /// side interpretation.
    member _.InsertText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``insertText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The format of the insert text. The format applies to both the
    /// `insertText` property and the `newText` property of a provided
    /// `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
    ///
    /// Please note that the insertTextFormat doesn&apos;t apply to
    /// `additionalTextEdits`.
    member _.InsertTextFormat =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``insertTextFormat`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertTextFormat") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InsertTextFormat.FromElement(prop))

    /// How whitespace and indentation is handled during completion
    /// item insertion. If not provided the clients default value depends on
    /// the `textDocument.completion.insertTextMode` client capability.
    ///
    /// @since 3.16.0
    member _.InsertTextMode =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``insertTextMode`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertTextMode") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InsertTextMode.FromElement(prop))

    /// An {@link TextEdit edit} which is applied to a document when selecting
    /// this completion. When an edit is provided the value of
    /// {@link CompletionItem.insertText insertText} is ignored.
    ///
    /// Most editors support two different operations when accepting a completion
    /// item. One is to insert a completion text and the other is to replace an
    /// existing text with a completion text. Since this can usually not be
    /// predetermined by a server it can report both ranges. Clients need to
    /// signal support for `InsertReplaceEdits` via the
    /// `textDocument.completion.insertReplaceSupport` client capability
    /// property.
    ///
    /// *Note 1:* The text edit&apos;s range as well as both ranges from an insert
    /// replace edit must be a [single line] and they must contain the position
    /// at which completion has been requested.
    /// *Note 2:* If an `InsertReplaceEdit` is returned the edit&apos;s insert range
    /// must be a prefix of the edit&apos;s replace range, that means it must be
    /// contained and starting at the same position.
    ///
    /// @since 3.16.0 additional type `InsertReplaceEdit`
    member _.TextEdit =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``textEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The edit text used if the completion item is part of a CompletionList and
    /// CompletionList defines an item default for the text edit range.
    ///
    /// Clients will only honor this property if they opt into completion list
    /// item defaults using the capability `completionList.itemDefaults`.
    ///
    /// If not provided and a list&apos;s default range is provided the label
    /// property is used as a text.
    ///
    /// @since 3.17.0
    member _.TextEditText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``textEditText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textEditText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// An optional array of additional {@link TextEdit text edits} that are applied when
    /// selecting this completion. Edits must not overlap (including the same insert position)
    /// with the main {@link CompletionItem.textEdit edit} nor with themselves.
    ///
    /// Additional text edits should be used to change text unrelated to the current cursor position
    /// (for example adding an import statement at the top of the file if the completion item will
    /// insert an unqualified type).
    member _.AdditionalTextEdits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``additionalTextEdits`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("additionalTextEdits") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional set of characters that when pressed while this completion is active will accept it first and
    /// then type that character. *Note* that all commit characters should have `length=1` and that superfluous
    /// characters will be ignored.
    member _.CommitCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``commitCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("commitCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional {@link Command command} that is executed *after* inserting this completion. *Note* that
    /// additional modifications to the current document should be described with the
    /// {@link CompletionItem.additionalTextEdits additionalTextEdits}-property.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    /// A data entry field that is preserved on a completion item between a
    /// {@link CompletionRequest} and a {@link CompletionResolveRequest}.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``labelDetails``: CompletionItemLabelDetails,
            ?``kind``: CompletionItemKind,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``documentation``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``deprecated``: global.FSharp.Core.bool,
            ?``preselect``: global.FSharp.Core.bool,
            ?``sortText``: global.Amongonz.LspTypes.LspString,
            ?``filterText``: global.Amongonz.LspTypes.LspString,
            ?``insertText``: global.Amongonz.LspTypes.LspString,
            ?``insertTextFormat``: InsertTextFormat,
            ?``insertTextMode``: InsertTextMode,
            ?``textEdit``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``textEditText``: global.Amongonz.LspTypes.LspString,
            ?``additionalTextEdits``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``commitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``command``: Command,
            ?``data``: LSPAny
        ) =
        CompletionItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``label`` = ``label``
                    ``labelDetails`` = ``labelDetails``
                    ``kind`` = ``kind``
                    ``tags`` = ``tags``
                    ``detail`` = ``detail``
                    ``documentation`` = ``documentation``
                    ``deprecated`` = ``deprecated``
                    ``preselect`` = ``preselect``
                    ``sortText`` = ``sortText``
                    ``filterText`` = ``filterText``
                    ``insertText`` = ``insertText``
                    ``insertTextFormat`` = ``insertTextFormat``
                    ``insertTextMode`` = ``insertTextMode``
                    ``textEdit`` = ``textEdit``
                    ``textEditText`` = ``textEditText``
                    ``additionalTextEdits`` = ``additionalTextEdits``
                    ``commitCharacters`` = ``commitCharacters``
                    ``command`` = ``command``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``label``
                    writer.WritePropertyName("label")
                    value.WriteTo(writer)

                    match backingObj.``labelDetails`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("labelDetails")
                        value.WriteTo(writer)

                    match backingObj.``kind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("kind", int value)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``detail`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("detail")
                        value.WriteTo(writer)

                    match backingObj.``documentation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentation")
                        value.WriteTo(writer)

                    match backingObj.``deprecated`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("deprecated", value)

                    match backingObj.``preselect`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("preselect", value)

                    match backingObj.``sortText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("sortText")
                        value.WriteTo(writer)

                    match backingObj.``filterText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("filterText")
                        value.WriteTo(writer)

                    match backingObj.``insertText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("insertText")
                        value.WriteTo(writer)

                    match backingObj.``insertTextFormat`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("insertTextFormat", int value)

                    match backingObj.``insertTextMode`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("insertTextMode", int value)

                    match backingObj.``textEdit`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("textEdit")
                        value.WriteTo(writer)

                    match backingObj.``textEditText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("textEditText")
                        value.WriteTo(writer)

                    match backingObj.``additionalTextEdits`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("additionalTextEdits")
                        value.WriteTo(writer)

                    match backingObj.``commitCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("commitCharacters")
                        value.WriteTo(writer)

                    match backingObj.``command`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("command")
                        value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionItem.FromElement(element))

/// Represents a collection of {@link CompletionItem completion items} to be presented
/// in the editor.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionList
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``isIncomplete``: global.FSharp.Core.bool
                ``itemDefaults``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionList(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// This list it not complete. Further typing results in recomputing this list.
    ///
    /// Recomputed lists have all their items replaced (not appended) in the
    /// incomplete completion sessions.
    member _.IsIncomplete =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``isIncomplete``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("isIncomplete")
            prop.GetBoolean()

    /// In many cases the items of an actual completion result share the same
    /// value for properties like `commitCharacters` or the range of a text
    /// edit. A completion list can therefore define item defaults which will
    /// be used if a completion item itself doesn&apos;t specify the value.
    ///
    /// If a completion list specifies a default value and a completion item
    /// also specifies a corresponding value the one from the item is used.
    ///
    /// Servers are only allowed to return default values if the client
    /// signals support for this via the `completionList.itemDefaults`
    /// capability.
    ///
    /// @since 3.17.0
    member _.ItemDefaults =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``itemDefaults`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("itemDefaults") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The completion items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``isIncomplete``: global.FSharp.Core.bool,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``itemDefaults``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        CompletionList(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``isIncomplete`` = ``isIncomplete``
                    ``itemDefaults`` = ``itemDefaults``
                    ``items`` = ``items``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``isIncomplete``
                    writer.WriteBoolean("isIncomplete", value)

                    match backingObj.``itemDefaults`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("itemDefaults")
                        value.WriteTo(writer)

                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionList.FromElement(element))

/// Registration options for a {@link CompletionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``resolveProvider``: global.FSharp.Core.bool option
                ``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Most tools trigger completion request automatically without explicitly requesting
    /// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
    /// starts to type an identifier. For example if the user types `c` in a JavaScript file
    /// code complete will automatically pop up present `console` besides others as a
    /// completion item. Characters that make up identifiers don&apos;t need to be listed here.
    ///
    /// If code complete should automatically be trigger on characters not being valid inside
    /// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The list of all possible characters that commit a completion. This field can be used
    /// if clients don&apos;t support individual commit characters per completion item. See
    /// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
    ///
    /// If a server provides both `allCommitCharacters` and commit characters on an individual
    /// completion item the ones on the completion item win.
    ///
    /// @since 3.2.0
    member _.AllCommitCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``allCommitCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("allCommitCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a completion item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The server supports the following `CompletionItem` specific
    /// capabilities.
    ///
    /// @since 3.17.0
    member _.CompletionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``completionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        CompletionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``triggerCharacters`` = ``triggerCharacters``
                    ``allCommitCharacters`` = ``allCommitCharacters``
                    ``resolveProvider`` = ``resolveProvider``
                    ``completionItem`` = ``completionItem``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``triggerCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("triggerCharacters")
                        value.WriteTo(writer)

                    match backingObj.``allCommitCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("allCommitCharacters")
                        value.WriteTo(writer)

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    match backingObj.``completionItem`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("completionItem")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionRegistrationOptions.FromElement(element))

/// Parameters for a {@link HoverRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        HoverParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(HoverParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The result of a hover request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Hover
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``contents``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``range``: Range option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Hover(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The hover&apos;s content
    member _.Contents =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``contents``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("contents")
            LspJsonBacking.Element prop

    /// An optional range inside the text document that is used to
    /// visualize the hover, e.g. by changing the background color.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    static member Create(``contents``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``range``: Range) =
        Hover(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``contents`` = ``contents``
                    ``range`` = ``range``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``contents``
                    writer.WritePropertyName("contents")
                    value.WriteTo(writer)

                    match backingObj.``range`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("range")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(Hover.FromElement(element))

/// Registration options for a {@link HoverRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        HoverRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(HoverRegistrationOptions.FromElement(element))

/// Parameters for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``context``: SignatureHelpContext option
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The signature help context. This is only available if the client specifies
    /// to send this using the client capability `textDocument.signatureHelp.contextSupport === true`
    ///
    /// @since 3.15.0
    member _.Context =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``context`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("context") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelpContext.FromElement(prop))

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``context``: SignatureHelpContext,
            ?``workDoneToken``: ProgressToken
        ) =
        SignatureHelpParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``context`` = ``context``
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``context`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("context")
                        value.WriteTo(writer)

                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SignatureHelpContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(SignatureHelpParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Signature help represents the signature of something
/// callable. There can be multiple signature but only one
/// active and only one active parameter.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelp
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``signatures``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``activeSignature``: global.FSharp.Core.int option
                ``activeParameter``: global.FSharp.Core.int option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelp(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// One or more signatures.
    member _.Signatures =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``signatures``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("signatures")
            LspJsonBacking.Element prop

    /// The active signature. If omitted or the value lies outside the
    /// range of `signatures` the value defaults to zero or is ignored if
    /// the `SignatureHelp` has no signatures.
    ///
    /// Whenever possible implementors should make an active decision about
    /// the active signature and shouldn&apos;t rely on a default value.
    ///
    /// In future version of the protocol this property might become
    /// mandatory to better express this.
    member _.ActiveSignature =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``activeSignature`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeSignature") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// The active parameter of the active signature. If omitted or the value
    /// lies outside the range of `signatures[activeSignature].parameters`
    /// defaults to 0 if the active signature has parameters. If
    /// the active signature has no parameters it is ignored.
    /// In future version of the protocol this property might become
    /// mandatory to better express the active parameter if the
    /// active signature does have any.
    member _.ActiveParameter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``activeParameter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeParameter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``signatures``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``activeSignature``: global.FSharp.Core.int,
            ?``activeParameter``: global.FSharp.Core.int
        ) =
        SignatureHelp(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``signatures`` = ``signatures``
                    ``activeSignature`` = ``activeSignature``
                    ``activeParameter`` = ``activeParameter``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``signatures``
                    writer.WritePropertyName("signatures")
                    value.WriteTo(writer)

                    match backingObj.``activeSignature`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("activeSignature", value)

                    match backingObj.``activeParameter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("activeParameter", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelp.FromElement(element))

/// Registration options for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// List of characters that trigger signature help automatically.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// List of characters that re-trigger signature help.
    ///
    /// These trigger characters are only active when signature help is already showing. All trigger characters
    /// are also counted as re-trigger characters.
    ///
    /// @since 3.15.0
    member _.RetriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``retriggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("retriggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        SignatureHelpRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``triggerCharacters`` = ``triggerCharacters``
                    ``retriggerCharacters`` = ``retriggerCharacters``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``triggerCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("triggerCharacters")
                        value.WriteTo(writer)

                    match backingObj.``retriggerCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("retriggerCharacters")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelpRegistrationOptions.FromElement(element))

/// Parameters for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DefinitionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DefinitionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DefinitionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DefinitionRegistrationOptions.FromElement(element))

/// Parameters for a {@link ReferencesRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``context``: ReferenceContext
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Context =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            ReferenceContext.FromElement(prop)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``context``: ReferenceContext,
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        ReferenceParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``context`` = ``context``
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``context``
                    writer.WritePropertyName("context")
                    value.WriteTo(writer)
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ReferenceContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(ReferenceParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link ReferencesRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        ReferenceRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ReferenceRegistrationOptions.FromElement(element))

/// Parameters for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentHighlightParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentHighlightParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A document highlight is a range inside a text document which deserves
/// special attention. Usually a document highlight is visualized by changing
/// the background color of its range.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlight
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``kind``: DocumentHighlightKind option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlight(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range this highlight applies to.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The highlight kind, default is {@link DocumentHighlightKind.Text text}.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentHighlightKind.FromElement(prop))

    static member Create(``range``: Range, ?``kind``: DocumentHighlightKind) =
        DocumentHighlight(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``kind`` = ``kind``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``kind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("kind", int value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> true)
        then
            global.FSharp.Core.Ok(DocumentHighlight.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DocumentHighlightRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentHighlightRegistrationOptions.FromElement(element))

/// Parameters for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentSymbolParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentSymbolParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents information about programming constructs like variables, classes,
/// interfaces etc.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SymbolInformation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``deprecated``: global.FSharp.Core.bool option
                ``location``: Location
                ``name``: global.Amongonz.LspTypes.LspString
                ``kind``: SymbolKind
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``containerName``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SymbolInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Indicates if this symbol is deprecated.
    ///
    /// @deprecated Use tags instead
    [<global.System.Obsolete("Use tags instead")>]
    member _.Deprecated =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``deprecated`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("deprecated") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The location of this symbol. The location&apos;s range is used by a tool
    /// to reveal the location in the editor. If the symbol is selected in the
    /// tool the range&apos;s start information is used to position the cursor. So
    /// the range usually spans more than the actual symbol&apos;s name and does
    /// normally include things like visibility modifiers.
    ///
    /// The range doesn&apos;t have to denote a node range in the sense of an abstract
    /// syntax tree. It can therefore not be used to re-construct a hierarchy of
    /// the symbols.
    member _.Location =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``location``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("location")
            Location.FromElement(prop)

    /// The name of this symbol.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The name of the symbol containing this symbol. This information is for
    /// user interface purposes (e.g. to render a qualifier in the user interface
    /// if necessary). It can&apos;t be used to re-infer a hierarchy for the document
    /// symbols.
    member _.ContainerName =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``containerName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("containerName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``location``: Location,
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ?``deprecated``: global.FSharp.Core.bool,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``containerName``: global.Amongonz.LspTypes.LspString
        ) =
        SymbolInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``deprecated`` = ``deprecated``
                    ``location`` = ``location``
                    ``name`` = ``name``
                    ``kind`` = ``kind``
                    ``tags`` = ``tags``
                    ``containerName`` = ``containerName``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``deprecated`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("deprecated", value)

                    let value = backingObj.``location``
                    writer.WritePropertyName("location")
                    value.WriteTo(writer)
                    let value = backingObj.``name``
                    writer.WritePropertyName("name")
                    value.WriteTo(writer)
                    let value = backingObj.``kind``
                    writer.WriteNumber("kind", int value)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``containerName`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("containerName")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SymbolInformation.FromElement(element))

/// Represents programming constructs like variables, classes, interfaces etc.
/// that appear in a document. Document symbols can be hierarchical and they
/// have two ranges: one that encloses its definition and one that points to
/// its most interesting range, e.g. the range of an identifier.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbol
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``name``: global.Amongonz.LspTypes.LspString
                ``detail``: global.Amongonz.LspTypes.LspString option
                ``kind``: SymbolKind
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``deprecated``: global.FSharp.Core.bool option
                ``range``: Range
                ``selectionRange``: Range
                ``children``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbol(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this symbol. Will be displayed in the user interface and therefore must not be
    /// an empty string or a string only consisting of white spaces.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// More detail for this symbol, e.g the signature of a function.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this document symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Indicates if this symbol is deprecated.
    ///
    /// @deprecated Use tags instead
    [<global.System.Obsolete("Use tags instead")>]
    member _.Deprecated =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``deprecated`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("deprecated") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The range enclosing this symbol not including leading/trailing whitespace but everything else
    /// like comments. This information is typically used to determine if the clients cursor is
    /// inside the symbol to reveal in the symbol in the UI.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
    /// Must be contained by the `range`.
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``selectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("selectionRange")
            Range.FromElement(prop)

    /// Children of this symbol, e.g. properties of a class.
    member _.Children =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``children`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("children") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ``range``: Range,
            ``selectionRange``: Range,
            ?``detail``: global.Amongonz.LspTypes.LspString,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``deprecated``: global.FSharp.Core.bool,
            ?``children``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        DocumentSymbol(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``name`` = ``name``
                    ``detail`` = ``detail``
                    ``kind`` = ``kind``
                    ``tags`` = ``tags``
                    ``deprecated`` = ``deprecated``
                    ``range`` = ``range``
                    ``selectionRange`` = ``selectionRange``
                    ``children`` = ``children``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``name``
                    writer.WritePropertyName("name")
                    value.WriteTo(writer)

                    match backingObj.``detail`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("detail")
                        value.WriteTo(writer)

                    let value = backingObj.``kind``
                    writer.WriteNumber("kind", int value)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``deprecated`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("deprecated", value)

                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``selectionRange``
                    writer.WritePropertyName("selectionRange")
                    value.WriteTo(writer)

                    match backingObj.``children`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("children")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentSymbol.FromElement(element))

/// Registration options for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``label``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// A human-readable string that is shown when multiple outlines trees
    /// are shown for the same document.
    ///
    /// @since 3.16.0
    member _.Label =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``label`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("label") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``label``: global.Amongonz.LspTypes.LspString
        ) =
        DocumentSymbolRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``label`` = ``label``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``label`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("label")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentSymbolRegistrationOptions.FromElement(element))

/// The parameters of a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``range``: Range
                ``context``: CodeActionContext
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document in which the command was invoked.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The range for which the command was invoked.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// Context carrying additional information.
    member _.Context =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``context``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("context")
            CodeActionContext.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ``context``: CodeActionContext,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        CodeActionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``range`` = ``range``
                    ``context`` = ``context``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``context``
                    writer.WritePropertyName("context")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "context" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeActionContext.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CodeActionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a reference to a command. Provides a title which
/// will be used to represent a command in the UI and, optionally,
/// an array of arguments which will be passed to the command handler
/// function when invoked.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Command
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``title``: global.Amongonz.LspTypes.LspString
                ``command``: global.Amongonz.LspTypes.LspString
                ``arguments``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Command(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Title of the command, like `save`.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The identifier of the actual command handler.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``command``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("command")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Arguments that the command handler should be
    /// invoked with.
    member _.Arguments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``arguments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("arguments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``title``: global.Amongonz.LspTypes.LspString,
            ``command``: global.Amongonz.LspTypes.LspString,
            ?``arguments``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        Command(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``title`` = ``title``
                    ``command`` = ``command``
                    ``arguments`` = ``arguments``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``title``
                    writer.WritePropertyName("title")
                    value.WriteTo(writer)
                    let value = backingObj.``command``
                    writer.WritePropertyName("command")
                    value.WriteTo(writer)

                    match backingObj.``arguments`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("arguments")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(Command.FromElement(element))

/// A code action represents a change that can be performed in code, e.g. to fix a problem or
/// to refactor code.
///
/// A CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeAction
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``title``: global.Amongonz.LspTypes.LspString
                ``kind``: CodeActionKind option
                ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``isPreferred``: global.FSharp.Core.bool option
                ``disabled``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``edit``: WorkspaceEdit option
                ``command``: Command option
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeAction(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A short, human-readable, title for this code action.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of the code action.
    ///
    /// Used to filter code actions.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeActionKind.FromElement(prop))

    /// The diagnostics that this code action resolves.
    member _.Diagnostics =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``diagnostics`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnostics") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
    /// by keybindings.
    ///
    /// A quick fix should be marked preferred if it properly addresses the underlying error.
    /// A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
    ///
    /// @since 3.15.0
    member _.IsPreferred =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``isPreferred`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("isPreferred") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Marks that the code action cannot currently be applied.
    ///
    /// Clients should follow the following guidelines regarding disabled code actions:
    ///
    ///   - Disabled code actions are not shown in automatic [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
    ///     code action menus.
    ///
    ///   - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
    ///     of code action, such as refactorings.
    ///
    ///   - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
    ///     that auto applies a code action and only disabled code actions are returned, the client should show the user an
    ///     error message with `reason` in the editor.
    ///
    /// @since 3.16.0
    member _.Disabled =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``disabled`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("disabled") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The workspace edit this code action performs.
    member _.Edit =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``edit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("edit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceEdit.FromElement(prop))

    /// A command this code action executes. If a code action
    /// provides an edit and a command, first the edit is
    /// executed and then the command.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    /// A data entry field that is preserved on a code action between
    /// a `textDocument/codeAction` and a `codeAction/resolve` request.
    ///
    /// @since 3.16.0
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``title``: global.Amongonz.LspTypes.LspString,
            ?``kind``: CodeActionKind,
            ?``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``isPreferred``: global.FSharp.Core.bool,
            ?``disabled``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``edit``: WorkspaceEdit,
            ?``command``: Command,
            ?``data``: LSPAny
        ) =
        CodeAction(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``title`` = ``title``
                    ``kind`` = ``kind``
                    ``diagnostics`` = ``diagnostics``
                    ``isPreferred`` = ``isPreferred``
                    ``disabled`` = ``disabled``
                    ``edit`` = ``edit``
                    ``command`` = ``command``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``title``
                    writer.WritePropertyName("title")
                    value.WriteTo(writer)

                    match backingObj.``kind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("kind")
                        value.WriteTo(writer)

                    match backingObj.``diagnostics`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("diagnostics")
                        value.WriteTo(writer)

                    match backingObj.``isPreferred`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("isPreferred", value)

                    match backingObj.``disabled`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("disabled")
                        value.WriteTo(writer)

                    match backingObj.``edit`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("edit")
                        value.WriteTo(writer)

                    match backingObj.``command`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("command")
                        value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeAction.FromElement(element))

/// Registration options for a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``resolveProvider``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// CodeActionKinds that this server may return.
    ///
    /// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
    /// may list out every specific kind they provide.
    member _.CodeActionKinds =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeActionKinds`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionKinds") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a code action.
    ///
    /// @since 3.16.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveProvider``: global.FSharp.Core.bool
        ) =
        CodeActionRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``codeActionKinds`` = ``codeActionKinds``
                    ``resolveProvider`` = ``resolveProvider``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``codeActionKinds`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeActionKinds")
                        value.WriteTo(writer)

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionRegistrationOptions.FromElement(element))

/// The parameters of a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``query``: global.Amongonz.LspTypes.LspString
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A query string to filter symbols by. Clients may send an empty
    /// string here to request all symbols.
    member _.Query =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``query``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("query")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``query``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        WorkspaceSymbolParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``query`` = ``query``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``query``
                    writer.WritePropertyName("query")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "query" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkspaceSymbolParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A special workspace symbol that supports locations without a range.
///
/// See also SymbolInformation.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbol
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``location``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``data``: LSPAny option
                ``name``: global.Amongonz.LspTypes.LspString
                ``kind``: SymbolKind
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``containerName``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbol(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The location of the symbol. Whether a server is allowed to
    /// return a location without a range depends on the client
    /// capability `workspace.symbol.resolveSupport`.
    ///
    /// See SymbolInformation#location for more details.
    member _.Location =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``location``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("location")
            LspJsonBacking.Element prop

    /// A data entry field that is preserved on a workspace symbol between a
    /// workspace symbol request and a workspace symbol resolve request.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    /// The name of this symbol.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The name of the symbol containing this symbol. This information is for
    /// user interface purposes (e.g. to render a qualifier in the user interface
    /// if necessary). It can&apos;t be used to re-infer a hierarchy for the document
    /// symbols.
    member _.ContainerName =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``containerName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("containerName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``location``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ?``data``: LSPAny,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``containerName``: global.Amongonz.LspTypes.LspString
        ) =
        WorkspaceSymbol(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``location`` = ``location``
                    ``data`` = ``data``
                    ``name`` = ``name``
                    ``kind`` = ``kind``
                    ``tags`` = ``tags``
                    ``containerName`` = ``containerName``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``location``
                    writer.WritePropertyName("location")
                    value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    let value = backingObj.``name``
                    writer.WritePropertyName("name")
                    value.WriteTo(writer)
                    let value = backingObj.``kind``
                    writer.WriteNumber("kind", int value)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``containerName`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("containerName")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceSymbol.FromElement(element))

/// Registration options for a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resolveProvider``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for a workspace symbol.
    ///
    /// @since 3.17.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``resolveProvider``: global.FSharp.Core.bool) =
        WorkspaceSymbolRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resolveProvider`` = ``resolveProvider``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(WorkspaceSymbolRegistrationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameters of a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to request code lens for.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        CodeLensParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(CodeLensParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A code lens represents a {@link Command command} that should be shown along with
/// source text, like the number of references, a way to run tests, etc.
///
/// A code lens is _unresolved_ when no command is associated to it. For performance
/// reasons the creation of a code lens and resolving should be done in two stages.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLens
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``command``: Command option
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLens(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range in which this code lens is valid. Should only span a single line.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The command this code lens represents.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    /// A data entry field that is preserved on a code lens item between
    /// a {@link CodeLensRequest} and a {@link CodeLensResolveRequest}
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create(``range``: Range, ?``command``: Command, ?``data``: LSPAny) =
        CodeLens(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``command`` = ``command``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``command`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("command")
                        value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "command" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (Command.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "data" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(CodeLens.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resolveProvider``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Code lens has a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveProvider``: global.FSharp.Core.bool
        ) =
        CodeLensRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``resolveProvider`` = ``resolveProvider``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeLensRegistrationOptions.FromElement(element))

/// The parameters of a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``workDoneToken``: ProgressToken option
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to provide document links for.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ?``workDoneToken``: ProgressToken,
            ?``partialResultToken``: ProgressToken
        ) =
        DocumentLinkParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``workDoneToken`` = ``workDoneToken``
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentLinkParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A document link is a range in a text document that links to an internal or external resource, like another
/// text document or a web site.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLink
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``target``: global.System.Uri option
                ``tooltip``: global.Amongonz.LspTypes.LspString option
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLink(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range this link applies to.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The uri this link points to. If missing a resolve request is sent later.
    member _.Target =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``target`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("target") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.System.Uri(prop.GetString()))

    /// The tooltip text when you hover over this link.
    ///
    /// If a tooltip is provided, is will be displayed in a string that includes instructions on how to
    /// trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
    /// user settings, and localization.
    ///
    /// @since 3.15.0
    member _.Tooltip =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tooltip`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltip") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A data entry field that is preserved on a document link between a
    /// DocumentLinkRequest and a DocumentLinkResolveRequest.
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``range``: Range,
            ?``target``: global.System.Uri,
            ?``tooltip``: global.Amongonz.LspTypes.LspString,
            ?``data``: LSPAny
        ) =
        DocumentLink(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``target`` = ``target``
                    ``tooltip`` = ``tooltip``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``target`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteString("target", value.OriginalString)

                    match backingObj.``tooltip`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tooltip")
                        value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "target" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "tooltip" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "data" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentLink.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resolveProvider``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Document links have a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveProvider``: global.FSharp.Core.bool
        ) =
        DocumentLinkRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``resolveProvider`` = ``resolveProvider``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentLinkRegistrationOptions.FromElement(element))

/// The parameters of a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``options``: FormattingOptions
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The format options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``options``: FormattingOptions, ?``workDoneToken``: ProgressToken) =
        DocumentFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``options`` = ``options``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``options``
                    writer.WritePropertyName("options")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FormattingOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentFormattingParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    static member Create(``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        DocumentFormattingRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentFormattingRegistrationOptions.FromElement(element))

/// The parameters of a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``range``: Range
                ``options``: FormattingOptions
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The range to format
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The format options
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``range``: Range,
            ``options``: FormattingOptions,
            ?``workDoneToken``: ProgressToken
        ) =
        DocumentRangeFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``range`` = ``range``
                    ``options`` = ``options``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``options``
                    writer.WritePropertyName("options")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FormattingOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentRangeFormattingParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``rangesSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Whether the server supports formatting multiple ranges at once.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RangesSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rangesSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangesSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``rangesSupport``: global.FSharp.Core.bool) =
        DocumentRangeFormattingRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``rangesSupport`` = ``rangesSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``rangesSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("rangesSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentRangeFormattingRegistrationOptions.FromElement(element))

/// The parameters of a {@link DocumentRangesFormattingRequest}.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangesFormattingParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``ranges``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``options``: FormattingOptions
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangesFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The ranges to format
    member _.Ranges =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``ranges``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("ranges")
            LspJsonBacking.Element prop

    /// The format options
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``ranges``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``options``: FormattingOptions,
            ?``workDoneToken``: ProgressToken
        ) =
        DocumentRangesFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``ranges`` = ``ranges``
                    ``options`` = ``options``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``ranges``
                    writer.WritePropertyName("ranges")
                    value.WriteTo(writer)
                    let value = backingObj.``options``
                    writer.WritePropertyName("options")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentRangesFormattingParams.FromElement(element))

/// The parameters of a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``ch``: global.Amongonz.LspTypes.LspString
                ``options``: FormattingOptions
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to format.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position around which the on type formatting should happen.
    /// This is not necessarily the exact position where the character denoted
    /// by the property `ch` got typed.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// The character that has been typed that triggered the formatting
    /// on type request. That is not necessarily the last character that
    /// got inserted into the document since the client could auto insert
    /// characters as well (e.g. like automatic brace completion).
    member _.Ch =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``ch``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("ch")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The formatting options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``options``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("options")
            FormattingOptions.FromElement(prop)

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ``ch``: global.Amongonz.LspTypes.LspString,
            ``options``: FormattingOptions
        ) =
        DocumentOnTypeFormattingParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``ch`` = ``ch``
                    ``options`` = ``options``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)
                    let value = backingObj.``ch``
                    writer.WritePropertyName("ch")
                    value.WriteTo(writer)
                    let value = backingObj.``options``
                    writer.WritePropertyName("options")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "ch" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FormattingOptions.Parse(prop)))
        then
            global.FSharp.Core.Ok(DocumentOnTypeFormattingParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString
                ``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// A character on which formatting should be triggered, like `{`.
    member _.FirstTriggerCharacter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``firstTriggerCharacter``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("firstTriggerCharacter")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// More trigger characters.
    member _.MoreTriggerCharacter =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``moreTriggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("moreTriggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString,
            ?``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        DocumentOnTypeFormattingRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``firstTriggerCharacter`` = ``firstTriggerCharacter``
                    ``moreTriggerCharacter`` = ``moreTriggerCharacter``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)
                    let value = backingObj.``firstTriggerCharacter``
                    writer.WritePropertyName("firstTriggerCharacter")
                    value.WriteTo(writer)

                    match backingObj.``moreTriggerCharacter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("moreTriggerCharacter")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentOnTypeFormattingRegistrationOptions.FromElement(element))

/// The parameters of a {@link RenameRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``newName``: global.Amongonz.LspTypes.LspString
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document to rename.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position at which this request was sent.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// The new name of the symbol. If the given name is not valid the
    /// request must return a {@link ResponseError} with an
    /// appropriate message set.
    member _.NewName =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``newName``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newName")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``textDocument``: TextDocumentIdentifier,
            ``position``: Position,
            ``newName``: global.Amongonz.LspTypes.LspString,
            ?``workDoneToken``: ProgressToken
        ) =
        RenameParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``newName`` = ``newName``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)
                    let value = backingObj.``newName``
                    writer.WritePropertyName("newName")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newName" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(RenameParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Registration options for a {@link RenameRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``prepareProvider``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document selector to identify the scope of the registration. If set to null
    /// the document selector provided on the client side will be used.
    member _.DocumentSelector =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``documentSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("documentSelector")
            LspJsonBacking.Element prop

    /// Renames should be checked and tested before being executed.
    ///
    /// @since version 3.12.0
    member _.PrepareProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``prepareProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``documentSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``prepareProvider``: global.FSharp.Core.bool
        ) =
        RenameRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentSelector`` = ``documentSelector``
                    ``prepareProvider`` = ``prepareProvider``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``documentSelector``
                    writer.WritePropertyName("documentSelector")
                    value.WriteTo(writer)

                    match backingObj.``prepareProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("prepareProvider", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RenameRegistrationOptions.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PrepareRenameParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PrepareRenameParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (``textDocument``: TextDocumentIdentifier, ``position``: Position, ?``workDoneToken``: ProgressToken)
        =
        PrepareRenameParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(PrepareRenameParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The parameters of a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``command``: global.Amongonz.LspTypes.LspString
                ``arguments``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The identifier of the actual command handler.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``command``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("command")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Arguments that the command should be invoked with.
    member _.Arguments =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``arguments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("arguments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``command``: global.Amongonz.LspTypes.LspString,
            ?``arguments``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``workDoneToken``: ProgressToken
        ) =
        ExecuteCommandParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``command`` = ``command``
                    ``arguments`` = ``arguments``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``command``
                    writer.WritePropertyName("command")
                    value.WriteTo(writer)

                    match backingObj.``arguments`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("arguments")
                        value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ExecuteCommandParams.FromElement(element))

/// Registration options for a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``commands``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The commands to be executed on the server
    member _.Commands =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``commands``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("commands")
            LspJsonBacking.Element prop

    static member Create(``commands``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        ExecuteCommandRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``commands`` = ``commands`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``commands``
                    writer.WritePropertyName("commands")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ExecuteCommandRegistrationOptions.FromElement(element))

/// The parameters passed via an apply workspace edit request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ApplyWorkspaceEditParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``label``: global.Amongonz.LspTypes.LspString option
                ``edit``: WorkspaceEdit
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ApplyWorkspaceEditParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional label of the workspace edit. This label is
    /// presented in the user interface for example on an undo
    /// stack to undo the workspace edit.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``label`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("label") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The edits to apply.
    member _.Edit =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``edit``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edit")
            WorkspaceEdit.FromElement(prop)

    static member Create(``edit``: WorkspaceEdit, ?``label``: global.Amongonz.LspTypes.LspString) =
        ApplyWorkspaceEditParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``label`` = ``label``
                    ``edit`` = ``edit``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``label`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("label")
                        value.WriteTo(writer)

                    let value = backingObj.``edit``
                    writer.WritePropertyName("edit")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "label" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "edit" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceEdit.Parse(prop)))
        then
            global.FSharp.Core.Ok(ApplyWorkspaceEditParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The result returned from the apply workspace edit request.
///
/// @since 3.17 renamed from ApplyWorkspaceEditResponse
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ApplyWorkspaceEditResult
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``applied``: global.FSharp.Core.bool
                ``failureReason``: global.Amongonz.LspTypes.LspString option
                ``failedChange``: global.FSharp.Core.int option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ApplyWorkspaceEditResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Indicates whether the edit was applied or not.
    member _.Applied =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``applied``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("applied")
            prop.GetBoolean()

    /// An optional textual description for why the edit was not applied.
    /// This may be used by the server for diagnostic logging or to provide
    /// a suitable error for a request that triggered the edit.
    member _.FailureReason =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``failureReason`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("failureReason") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Depending on the client&apos;s failure handling strategy `failedChange` might
    /// contain the index of the change that failed. This property is only available
    /// if the client signals a `failureHandlingStrategy` in its client capabilities.
    member _.FailedChange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``failedChange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("failedChange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``applied``: global.FSharp.Core.bool,
            ?``failureReason``: global.Amongonz.LspTypes.LspString,
            ?``failedChange``: global.FSharp.Core.int
        ) =
        ApplyWorkspaceEditResult(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``applied`` = ``applied``
                    ``failureReason`` = ``failureReason``
                    ``failedChange`` = ``failedChange``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``applied``
                    writer.WriteBoolean("applied", value)

                    match backingObj.``failureReason`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("failureReason")
                        value.WriteTo(writer)

                    match backingObj.``failedChange`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("failedChange", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "applied" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "failureReason" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "failedChange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
        then
            global.FSharp.Core.Ok(ApplyWorkspaceEditResult.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressBegin
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``title``: global.Amongonz.LspTypes.LspString
                ``cancellable``: global.FSharp.Core.bool option
                ``message``: global.Amongonz.LspTypes.LspString option
                ``percentage``: global.FSharp.Core.int option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressBegin(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// Mandatory title of the progress operation. Used to briefly inform about
    /// the kind of operation being performed.
    ///
    /// Examples: &quot;Indexing&quot; or &quot;Linking dependencies&quot;.
    member _.Title =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``title``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("title")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Controls if a cancel button should show to allow the user to cancel the
    /// long running operation. Clients that don&apos;t support cancellation are allowed
    /// to ignore the setting.
    member _.Cancellable =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``cancellable`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cancellable") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Optional, more detailed associated progress message. Contains
    /// complementary information to the `title`.
    ///
    /// Examples: &quot;3/25 files&quot;, &quot;project/src/module2&quot;, &quot;node_modules/some_dep&quot;.
    /// If unset, the previous progress message (if any) is still valid.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``message`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("message") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Optional progress percentage to display (value 100 is considered 100%).
    /// If not provided infinite progress is assumed and clients are allowed
    /// to ignore the `percentage` value in subsequent in report notifications.
    ///
    /// The value should be steadily rising. Clients are free to ignore values
    /// that are not following this rule. The value range is [0, 100].
    member _.Percentage =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``percentage`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("percentage") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``title``: global.Amongonz.LspTypes.LspString,
            ?``cancellable``: global.FSharp.Core.bool,
            ?``message``: global.Amongonz.LspTypes.LspString,
            ?``percentage``: global.FSharp.Core.int
        ) =
        WorkDoneProgressBegin(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``title`` = ``title``
                    ``cancellable`` = ``cancellable``
                    ``message`` = ``message``
                    ``percentage`` = ``percentage``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``title``
                    writer.WritePropertyName("title")
                    value.WriteTo(writer)

                    match backingObj.``cancellable`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("cancellable", value)

                    match backingObj.``message`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("message")
                        value.WriteTo(writer)

                    match backingObj.``percentage`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("percentage", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkDoneProgressBegin.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``cancellable``: global.FSharp.Core.bool option
                ``message``: global.Amongonz.LspTypes.LspString option
                ``percentage``: global.FSharp.Core.int option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// Controls enablement state of a cancel button.
    ///
    /// Clients that don&apos;t support cancellation or don&apos;t support controlling the button&apos;s
    /// enablement state are allowed to ignore the property.
    member _.Cancellable =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``cancellable`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cancellable") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Optional, more detailed associated progress message. Contains
    /// complementary information to the `title`.
    ///
    /// Examples: &quot;3/25 files&quot;, &quot;project/src/module2&quot;, &quot;node_modules/some_dep&quot;.
    /// If unset, the previous progress message (if any) is still valid.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``message`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("message") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Optional progress percentage to display (value 100 is considered 100%).
    /// If not provided infinite progress is assumed and clients are allowed
    /// to ignore the `percentage` value in subsequent in report notifications.
    ///
    /// The value should be steadily rising. Clients are free to ignore values
    /// that are not following this rule. The value range is [0, 100]
    member _.Percentage =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``percentage`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("percentage") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``cancellable``: global.FSharp.Core.bool,
            ?``message``: global.Amongonz.LspTypes.LspString,
            ?``percentage``: global.FSharp.Core.int
        ) =
        WorkDoneProgressReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``cancellable`` = ``cancellable``
                    ``message`` = ``message``
                    ``percentage`` = ``percentage``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)

                    match backingObj.``cancellable`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("cancellable", value)

                    match backingObj.``message`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("message")
                        value.WriteTo(writer)

                    match backingObj.``percentage`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("percentage", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkDoneProgressReport.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressEnd
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``message``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressEnd(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// Optional, a final message indicating to for example indicate the outcome
    /// of the operation.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``message`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("message") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``message``: global.Amongonz.LspTypes.LspString) =
        WorkDoneProgressEnd(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``message`` = ``message``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)

                    match backingObj.``message`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("message")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkDoneProgressEnd.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SetTraceParams private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``value``: TraceValues |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SetTraceParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Value =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            TraceValues.FromElement(prop)

    static member Create(``value``: TraceValues) =
        SetTraceParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``value`` = ``value`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``value``
                    writer.WritePropertyName("value")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TraceValues.Parse(prop)))
        then
            global.FSharp.Core.Ok(SetTraceParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LogTraceParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``message``: global.Amongonz.LspTypes.LspString
                ``verbose``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LogTraceParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    member _.Verbose =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``verbose`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("verbose") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``message``: global.Amongonz.LspTypes.LspString, ?``verbose``: global.Amongonz.LspTypes.LspString)
        =
        LogTraceParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``message`` = ``message``
                    ``verbose`` = ``verbose``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``message``
                    writer.WritePropertyName("message")
                    value.WriteTo(writer)

                    match backingObj.``verbose`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("verbose")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "verbose" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(LogTraceParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CancelParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``id``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CancelParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The request id to cancel.
    member _.Id =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``id``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("id")
            LspJsonBacking.Element prop

    static member Create(``id``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        CancelParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``id`` = ``id`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``id``
                    writer.WritePropertyName("id")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CancelParams.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ProgressParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``token``: ProgressToken
                ``value``: LSPAny
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ProgressParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The progress token provided by the client or server.
    member _.Token =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``token``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("token")
            ProgressToken.FromElement(prop)

    /// The progress data.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            LSPAny.FromElement(prop)

    static member Create(``token``: ProgressToken, ``value``: LSPAny) =
        ProgressParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``token`` = ``token``
                    ``value`` = ``value``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``token``
                    writer.WritePropertyName("token")
                    value.WriteTo(writer)
                    let value = backingObj.``value``
                    writer.WritePropertyName("value")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "token" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(ProgressParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A parameter literal used in requests to pass a text document and a position inside that
/// document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentPositionParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: TextDocumentIdentifier
                ``position``: Position
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentPositionParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            TextDocumentIdentifier.FromElement(prop)

    /// The position inside the text document.
    member _.Position =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``position``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("position")
            Position.FromElement(prop)

    static member Create(``textDocument``: TextDocumentIdentifier, ``position``: Position) =
        TextDocumentPositionParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``position`` = ``position``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``position``
                    writer.WritePropertyName("position")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentIdentifier.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "position" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextDocumentPositionParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkDoneProgressParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkDoneProgressParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create(?``workDoneToken``: ProgressToken) =
        WorkDoneProgressParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkDoneProgressParams.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PartialResultParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``partialResultToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PartialResultParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional token that a server can use to report partial results (e.g. streaming) to
    /// the client.
    member _.PartialResultToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``partialResultToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("partialResultToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create(?``partialResultToken``: ProgressToken) =
        PartialResultParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``partialResultToken`` = ``partialResultToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``partialResultToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("partialResultToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "partialResultToken" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ProgressToken.Parse(prop)))
        then
            global.FSharp.Core.Ok(PartialResultParams.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents the connection of two locations. Provides additional metadata over normal {@link Location locations},
/// including an origin range.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LocationLink
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``originSelectionRange``: Range option
                ``targetUri``: global.Amongonz.LspTypes.LspDocumentUri
                ``targetRange``: Range
                ``targetSelectionRange``: Range
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LocationLink(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Span of the origin of this link.
    ///
    /// Used as the underlined span for mouse interaction. Defaults to the word range at
    /// the definition position.
    member _.OriginSelectionRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``originSelectionRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("originSelectionRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Range.FromElement(prop))

    /// The target resource identifier of this link.
    member _.TargetUri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``targetUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("targetUri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The full target range of this link. If the target for example is a symbol then target range is the
    /// range enclosing this symbol not including leading/trailing whitespace but everything else
    /// like comments. This information is typically used to highlight the range in the editor.
    member _.TargetRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``targetRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("targetRange")
            Range.FromElement(prop)

    /// The range that should be selected and revealed when this link is being followed, e.g the name of a function.
    /// Must be contained by the `targetRange`. See also `DocumentSymbol#range`
    member _.TargetSelectionRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``targetSelectionRange``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("targetSelectionRange")
            Range.FromElement(prop)

    static member Create
        (
            ``targetUri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``targetRange``: Range,
            ``targetSelectionRange``: Range,
            ?``originSelectionRange``: Range
        ) =
        LocationLink(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``originSelectionRange`` = ``originSelectionRange``
                    ``targetUri`` = ``targetUri``
                    ``targetRange`` = ``targetRange``
                    ``targetSelectionRange`` = ``targetSelectionRange``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``originSelectionRange`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("originSelectionRange")
                        value.WriteTo(writer)

                    let value = backingObj.``targetUri``
                    writer.WriteString("targetUri", value.OriginalString)
                    let value = backingObj.``targetRange``
                    writer.WritePropertyName("targetRange")
                    value.WriteTo(writer)
                    let value = backingObj.``targetSelectionRange``
                    writer.WritePropertyName("targetSelectionRange")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "originSelectionRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "targetUri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "targetRange" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "targetSelectionRange" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(LocationLink.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A range in a text document expressed as (zero-based) start and end positions.
///
/// If you want to specify a range that contains a line including the line ending
/// character(s) then use an end position denoting the start of the next line.
/// For example:
/// ```ts
/// {
///     start: { line: 5, character: 23 }
///     end : { line 6, character : 0 }
/// }
/// ```
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Range
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``start``: Position
                ``end``: Position
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Range(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range&apos;s start position.
    member _.Start =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``start``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("start")
            Position.FromElement(prop)

    /// The range&apos;s end position.
    member _.End =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``end``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("end")
            Position.FromElement(prop)

    static member Create(``start``: Position, ``end``: Position) =
        Range(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``start`` = ``start``
                    ``end`` = ``end``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``start``
                    writer.WritePropertyName("start")
                    value.WriteTo(writer)
                    let value = backingObj.``end``
                    writer.WritePropertyName("end")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "start" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "end" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Position.Parse(prop)))
        then
            global.FSharp.Core.Ok(Range.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        ImplementationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ImplementationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Static registration options to be returned in the initialize
/// request.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type StaticRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        StaticRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(?``id``: global.Amongonz.LspTypes.LspString) =
        StaticRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``id`` = ``id`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "id" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(StaticRegistrationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        TypeDefinitionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeDefinitionOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The workspace folder change event.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFoldersChangeEvent
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``added``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``removed``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFoldersChangeEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The array of added workspace folders
    member _.Added =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``added``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("added")
            LspJsonBacking.Element prop

    /// The array of the removed workspace folders
    member _.Removed =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``removed``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("removed")
            LspJsonBacking.Element prop

    static member Create
        (
            ``added``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``removed``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        WorkspaceFoldersChangeEvent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``added`` = ``added``
                    ``removed`` = ``removed``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``added``
                    writer.WritePropertyName("added")
                    value.WriteTo(writer)
                    let value = backingObj.``removed``
                    writer.WritePropertyName("removed")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFoldersChangeEvent.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ConfigurationItem
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``scopeUri``: global.System.Uri option
                ``section``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ConfigurationItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The scope to get the configuration section for.
    member _.ScopeUri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``scopeUri`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("scopeUri") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.System.Uri(prop.GetString()))

    /// The configuration section asked for.
    member _.Section =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``section`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("section") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(?``scopeUri``: global.System.Uri, ?``section``: global.Amongonz.LspTypes.LspString) =
        ConfigurationItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``scopeUri`` = ``scopeUri``
                    ``section`` = ``section``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``scopeUri`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteString("scopeUri", value.OriginalString)

                    match backingObj.``section`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("section")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "scopeUri" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "section" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ConfigurationItem.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A literal to identify a text document in the client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentIdentifier
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    static member Create(``uri``: global.Amongonz.LspTypes.LspDocumentUri) =
        TextDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``uri`` = ``uri`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(TextDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a color in RGBA space.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Color
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``red``: global.FSharp.Core.double
                ``green``: global.FSharp.Core.double
                ``blue``: global.FSharp.Core.double
                ``alpha``: global.FSharp.Core.double
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Color(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The red component of this color in the range [0-1].
    member _.Red =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``red``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("red")
            prop.GetDouble()

    /// The green component of this color in the range [0-1].
    member _.Green =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``green``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("green")
            prop.GetDouble()

    /// The blue component of this color in the range [0-1].
    member _.Blue =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``blue``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("blue")
            prop.GetDouble()

    /// The alpha component of this color in the range [0-1].
    member _.Alpha =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``alpha``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("alpha")
            prop.GetDouble()

    static member Create
        (
            ``red``: global.FSharp.Core.double,
            ``green``: global.FSharp.Core.double,
            ``blue``: global.FSharp.Core.double,
            ``alpha``: global.FSharp.Core.double
        ) =
        Color(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``red`` = ``red``
                    ``green`` = ``green``
                    ``blue`` = ``blue``
                    ``alpha`` = ``alpha``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``red``
                    writer.WriteNumber("red", value)
                    let value = backingObj.``green``
                    writer.WriteNumber("green", value)
                    let value = backingObj.``blue``
                    writer.WriteNumber("blue", value)
                    let value = backingObj.``alpha``
                    writer.WriteNumber("alpha", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "red" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "green" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "blue" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "alpha" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidDecimal prop)
        then
            global.FSharp.Core.Ok(Color.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentColorOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentColorOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        FoldingRangeOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FoldingRangeOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DeclarationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DeclarationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Position in a text document expressed as zero-based line and character
/// offset. Prior to 3.17 the offsets were always based on a UTF-16 string
/// representation. So a string of the form `ab` the character offset of the
/// character `a` is 0, the character offset of `` is 1 and the character
/// offset of b is 3 since `` is represented using two code units in UTF-16.
/// Since 3.17 clients and servers can agree on a different string encoding
/// representation (e.g. UTF-8). The client announces it&apos;s supported encoding
/// via the client capability [`general.positionEncodings`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#clientCapabilities).
/// The value is an array of position encodings the client supports, with
/// decreasing preference (e.g. the encoding at index `0` is the most preferred
/// one). To stay backwards compatible the only mandatory encoding is UTF-16
/// represented via the string `utf-16`. The server can pick one of the
/// encodings offered by the client and signals that encoding back to the
/// client via the initialize result&apos;s property
/// [`capabilities.positionEncoding`](https://microsoft.github.io/language-server-protocol/specifications/specification-current/#serverCapabilities). If the string value
/// `utf-16` is missing from the client&apos;s capability `general.positionEncodings`
/// servers can safely assume that the client supports UTF-16. If the server
/// omits the position encoding in its initialize result the encoding defaults
/// to the string value `utf-16`. Implementation considerations: since the
/// conversion from one encoding into another requires the content of the
/// file / line the conversion is best done where the file is read which is
/// usually on the server side.
///
/// Positions are line end character agnostic. So you can not specify a position
/// that denotes `\r|\n` or `\n|` where `|` represents the character offset.
///
/// @since 3.17.0 - support for negotiated position encoding.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Position
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``line``: global.FSharp.Core.int
                ``character``: global.FSharp.Core.int
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Position(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Line position in a document (zero-based).
    ///
    /// If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the document.
    /// If a line number is negative, it defaults to 0.
    member _.Line =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``line``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("line")
            prop.GetInt32()

    /// Character offset on a line in a document (zero-based).
    ///
    /// The meaning of this offset is determined by the negotiated
    /// `PositionEncodingKind`.
    ///
    /// If the character value is greater than the line length it defaults back to the
    /// line length.
    member _.Character =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``character``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("character")
            prop.GetInt32()

    static member Create(``line``: global.FSharp.Core.int, ``character``: global.FSharp.Core.int) =
        Position(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``line`` = ``line``
                    ``character`` = ``character``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``line``
                    writer.WriteNumber("line", value)
                    let value = backingObj.``character``
                    writer.WriteNumber("character", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "line" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "character" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
        then
            global.FSharp.Core.Ok(Position.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        SelectionRangeOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SelectionRangeOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Call hierarchy options used during static registration.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        CallHierarchyOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CallHierarchyOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``legend``: SemanticTokensLegend
                ``range``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``full``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The legend used by the server
    member _.Legend =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``legend``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("legend")
            SemanticTokensLegend.FromElement(prop)

    /// Server supports providing semantic tokens for a specific range
    /// of a document.
    member _.Range =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``range`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("range") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Server supports providing semantic tokens for a full document.
    member _.Full =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``full`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("full") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``legend``: SemanticTokensLegend,
            ?``range``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``full``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        SemanticTokensOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``legend`` = ``legend``
                    ``range`` = ``range``
                    ``full`` = ``full``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``legend``
                    writer.WritePropertyName("legend")
                    value.WriteTo(writer)

                    match backingObj.``range`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("range")
                        value.WriteTo(writer)

                    match backingObj.``full`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("full")
                        value.WriteTo(writer)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensOptions.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensEdit
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``start``: global.FSharp.Core.int
                ``deleteCount``: global.FSharp.Core.int
                ``data``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The start offset of the edit.
    member _.Start =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``start``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("start")
            prop.GetInt32()

    /// The count of elements to remove.
    member _.DeleteCount =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``deleteCount``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("deleteCount")
            prop.GetInt32()

    /// The elements to insert.
    member _.Data =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``start``: global.FSharp.Core.int,
            ``deleteCount``: global.FSharp.Core.int,
            ?``data``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        SemanticTokensEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``start`` = ``start``
                    ``deleteCount`` = ``deleteCount``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``start``
                    writer.WriteNumber("start", value)
                    let value = backingObj.``deleteCount``
                    writer.WriteNumber("deleteCount", value)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensEdit.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        LinkedEditingRangeOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(LinkedEditingRangeOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents information on a file/folder create.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileCreate
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileCreate(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A file:// URI for the location of the file/folder being created.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspString) =
        FileCreate(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``uri`` = ``uri`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WritePropertyName("uri")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileCreate.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Describes textual changes on a text document. A TextDocumentEdit describes all changes
/// on a document version Si and after they are applied move the document to version Si+1.
/// So the creator of a TextDocumentEdit doesn&apos;t need to sort the array of edits or do any
/// kind of ordering. However the edits must be non overlapping.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentEdit
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``textDocument``: OptionalVersionedTextDocumentIdentifier
                ``edits``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document to change.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``textDocument``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("textDocument")
            OptionalVersionedTextDocumentIdentifier.FromElement(prop)

    /// The edits to be applied.
    ///
    /// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
    /// client capability.
    member _.Edits =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``edits``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("edits")
            LspJsonBacking.Element prop

    static member Create
        (
            ``textDocument``: OptionalVersionedTextDocumentIdentifier,
            ``edits``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        TextDocumentEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``textDocument`` = ``textDocument``
                    ``edits`` = ``edits``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``textDocument``
                    writer.WritePropertyName("textDocument")
                    value.WriteTo(writer)
                    let value = backingObj.``edits``
                    writer.WritePropertyName("edits")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentEdit.FromElement(element))

/// Create file operation.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CreateFile
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``options``: CreateFileOptions option
                ``annotationId``: ChangeAnnotationIdentifier option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CreateFile(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A create
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The resource to create.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Additional options
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CreateFileOptions.FromElement(prop))

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``options``: CreateFileOptions,
            ?``annotationId``: ChangeAnnotationIdentifier
        ) =
        CreateFile(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``uri`` = ``uri``
                    ``options`` = ``options``
                    ``annotationId`` = ``annotationId``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)

                    match backingObj.``options`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("options")
                        value.WriteTo(writer)

                    match backingObj.``annotationId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("annotationId")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CreateFile.FromElement(element))

/// Rename file operation
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameFile
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``oldUri``: global.Amongonz.LspTypes.LspDocumentUri
                ``newUri``: global.Amongonz.LspTypes.LspDocumentUri
                ``options``: RenameFileOptions option
                ``annotationId``: ChangeAnnotationIdentifier option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameFile(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A rename
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The old (existing) location.
    member _.OldUri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``oldUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("oldUri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The new location.
    member _.NewUri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``newUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newUri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Rename options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(RenameFileOptions.FromElement(prop))

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``oldUri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``newUri``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``options``: RenameFileOptions,
            ?``annotationId``: ChangeAnnotationIdentifier
        ) =
        RenameFile(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``oldUri`` = ``oldUri``
                    ``newUri`` = ``newUri``
                    ``options`` = ``options``
                    ``annotationId`` = ``annotationId``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``oldUri``
                    writer.WriteString("oldUri", value.OriginalString)
                    let value = backingObj.``newUri``
                    writer.WriteString("newUri", value.OriginalString)

                    match backingObj.``options`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("options")
                        value.WriteTo(writer)

                    match backingObj.``annotationId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("annotationId")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RenameFile.FromElement(element))

/// Delete file operation
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeleteFile
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``options``: DeleteFileOptions option
                ``annotationId``: ChangeAnnotationIdentifier option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeleteFile(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A delete
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The file to delete.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Delete options.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DeleteFileOptions.FromElement(prop))

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``options``: DeleteFileOptions,
            ?``annotationId``: ChangeAnnotationIdentifier
        ) =
        DeleteFile(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``uri`` = ``uri``
                    ``options`` = ``options``
                    ``annotationId`` = ``annotationId``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)

                    match backingObj.``options`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("options")
                        value.WriteTo(writer)

                    match backingObj.``annotationId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("annotationId")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DeleteFile.FromElement(element))

/// Additional information that describes document changes.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ChangeAnnotation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``label``: global.Amongonz.LspTypes.LspString
                ``needsConfirmation``: global.FSharp.Core.bool option
                ``description``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ChangeAnnotation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A human-readable string describing the actual change. The string
    /// is rendered prominent in the user interface.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// A flag which indicates that user confirmation is needed
    /// before applying the change.
    member _.NeedsConfirmation =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``needsConfirmation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("needsConfirmation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// A human-readable string which is rendered less prominent in
    /// the user interface.
    member _.Description =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``description`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("description") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``needsConfirmation``: global.FSharp.Core.bool,
            ?``description``: global.Amongonz.LspTypes.LspString
        ) =
        ChangeAnnotation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``label`` = ``label``
                    ``needsConfirmation`` = ``needsConfirmation``
                    ``description`` = ``description``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``label``
                    writer.WritePropertyName("label")
                    value.WriteTo(writer)

                    match backingObj.``needsConfirmation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("needsConfirmation", value)

                    match backingObj.``description`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("description")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "label" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "needsConfirmation" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "description" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ChangeAnnotation.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A filter to describe in which file operation requests or notifications
/// the server is interested in receiving.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationFilter
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``scheme``: global.Amongonz.LspTypes.LspString option
                ``pattern``: FileOperationPattern
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A Uri scheme like `file` or `untitled`.
    member _.Scheme =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``scheme`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("scheme") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual file operation pattern.
    member _.Pattern =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``pattern``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("pattern")
            FileOperationPattern.FromElement(prop)

    static member Create(``pattern``: FileOperationPattern, ?``scheme``: global.Amongonz.LspTypes.LspString) =
        FileOperationFilter(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``scheme`` = ``scheme``
                    ``pattern`` = ``pattern``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``scheme`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("scheme")
                        value.WriteTo(writer)

                    let value = backingObj.``pattern``
                    writer.WritePropertyName("pattern")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "scheme" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "pattern" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationPattern.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileOperationFilter.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents information on a file/folder rename.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileRename
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``oldUri``: global.Amongonz.LspTypes.LspString
                ``newUri``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileRename(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A file:// URI for the original location of the file/folder being renamed.
    member _.OldUri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``oldUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("oldUri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// A file:// URI for the new location of the file/folder being renamed.
    member _.NewUri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``newUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newUri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``oldUri``: global.Amongonz.LspTypes.LspString, ``newUri``: global.Amongonz.LspTypes.LspString)
        =
        FileRename(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``oldUri`` = ``oldUri``
                    ``newUri`` = ``newUri``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``oldUri``
                    writer.WritePropertyName("oldUri")
                    value.WriteTo(writer)
                    let value = backingObj.``newUri``
                    writer.WritePropertyName("newUri")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "oldUri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newUri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileRename.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents information on a file/folder delete.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileDelete
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileDelete(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A file:// URI for the location of the file/folder being deleted.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspString) =
        FileDelete(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``uri`` = ``uri`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WritePropertyName("uri")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileDelete.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        MonikerOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(MonikerOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Type hierarchy options used during static registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        TypeHierarchyOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeHierarchyOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueContext
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``frameId``: global.FSharp.Core.int
                ``stoppedLocation``: Range
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The stack frame (as a DAP Id) where the execution has stopped.
    member _.FrameId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``frameId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("frameId")
            prop.GetInt32()

    /// The document range where execution has stopped.
    /// Typically the end position of the range denotes the line where the inline values are shown.
    member _.StoppedLocation =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``stoppedLocation``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("stoppedLocation")
            Range.FromElement(prop)

    static member Create(``frameId``: global.FSharp.Core.int, ``stoppedLocation``: Range) =
        InlineValueContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``frameId`` = ``frameId``
                    ``stoppedLocation`` = ``stoppedLocation``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``frameId``
                    writer.WriteNumber("frameId", value)
                    let value = backingObj.``stoppedLocation``
                    writer.WritePropertyName("stoppedLocation")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "frameId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "stoppedLocation" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueContext.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provide inline value as text.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueText
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``text``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueText(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document range for which the inline value applies.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The text of the inline value.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``text``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("text")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``range``: Range, ``text``: global.Amongonz.LspTypes.LspString) =
        InlineValueText(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``text`` = ``text``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``text``
                    writer.WritePropertyName("text")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueText.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provide inline value through a variable lookup.
/// If only a range is specified, the variable name will be extracted from the underlying document.
/// An optional variable name can be used to override the extracted name.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueVariableLookup
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``variableName``: global.Amongonz.LspTypes.LspString option
                ``caseSensitiveLookup``: global.FSharp.Core.bool
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueVariableLookup(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document range for which the inline value applies.
    /// The range is used to extract the variable name from the underlying document.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// If specified the name of the variable to look up.
    member _.VariableName =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``variableName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("variableName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// How to perform the lookup.
    member _.CaseSensitiveLookup =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``caseSensitiveLookup``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("caseSensitiveLookup")
            prop.GetBoolean()

    static member Create
        (
            ``range``: Range,
            ``caseSensitiveLookup``: global.FSharp.Core.bool,
            ?``variableName``: global.Amongonz.LspTypes.LspString
        ) =
        InlineValueVariableLookup(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``variableName`` = ``variableName``
                    ``caseSensitiveLookup`` = ``caseSensitiveLookup``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``variableName`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("variableName")
                        value.WriteTo(writer)

                    let value = backingObj.``caseSensitiveLookup``
                    writer.WriteBoolean("caseSensitiveLookup", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "variableName" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "caseSensitiveLookup" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueVariableLookup.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provide an inline value through an expression evaluation.
/// If only a range is specified, the expression will be extracted from the underlying document.
/// An optional expression can be used to override the extracted expression.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueEvaluatableExpression
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``expression``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueEvaluatableExpression(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The document range for which the inline value applies.
    /// The range is used to extract the evaluatable expression from the underlying document.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// If specified the expression overrides the extracted expression.
    member _.Expression =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``expression`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("expression") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create(``range``: Range, ?``expression``: global.Amongonz.LspTypes.LspString) =
        InlineValueEvaluatableExpression(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``expression`` = ``expression``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``expression`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("expression")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "expression" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineValueEvaluatableExpression.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Inline value options used during static registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        InlineValueOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// An inlay hint label part allows for interactive and composite labels
/// of inlay hints.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintLabelPart
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``value``: global.Amongonz.LspTypes.LspString
                ``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``location``: Location option
                ``command``: Command option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintLabelPart(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The value of this label part.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The tooltip text when you hover over this label part. Depending on
    /// the client capability `inlayHint.resolveSupport` clients might resolve
    /// this property late using the resolve request.
    member _.Tooltip =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tooltip`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltip") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional source code location that represents this
    /// label part.
    ///
    /// The editor will use this location for the hover and for code navigation
    /// features: This part will become a clickable link that resolves to the
    /// definition of the symbol at the given location (not necessarily the
    /// location itself), it shows the hover that shows at the given location,
    /// and it shows a context menu with further code navigation commands.
    ///
    /// Depending on the client capability `inlayHint.resolveSupport` clients
    /// might resolve this property late using the resolve request.
    member _.Location =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``location`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("location") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Location.FromElement(prop))

    /// An optional command for this label part.
    ///
    /// Depending on the client capability `inlayHint.resolveSupport` clients
    /// might resolve this property late using the resolve request.
    member _.Command =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``command`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("command") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(Command.FromElement(prop))

    static member Create
        (
            ``value``: global.Amongonz.LspTypes.LspString,
            ?``tooltip``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``location``: Location,
            ?``command``: Command
        ) =
        InlayHintLabelPart(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``value`` = ``value``
                    ``tooltip`` = ``tooltip``
                    ``location`` = ``location``
                    ``command`` = ``command``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``value``
                    writer.WritePropertyName("value")
                    value.WriteTo(writer)

                    match backingObj.``tooltip`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tooltip")
                        value.WriteTo(writer)

                    match backingObj.``location`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("location")
                        value.WriteTo(writer)

                    match backingObj.``command`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("command")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHintLabelPart.FromElement(element))

/// A `MarkupContent` literal represents a string value which content is interpreted base on its
/// kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.
///
/// If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
/// See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
///
/// Here is an example how such a string can be constructed using JavaScript / TypeScript:
/// ```ts
/// let markdown: MarkdownContent = {
///  kind: MarkupKind.Markdown,
///  value: [
///    &apos;# Header&apos;,
///    &apos;Some text&apos;,
///    &apos;```typescript&apos;,
///    &apos;someCode();&apos;,
///    &apos;```&apos;
///  ].join(&apos;\n&apos;)
/// };
/// ```
///
/// *Please Note* that clients might sanitize the return markdown. A client could decide to
/// remove HTML from the markdown to avoid script execution.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkupContent
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: MarkupKind
                ``value``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MarkupContent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The type of the Markup
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            MarkupKind.FromElement(prop)

    /// The content itself
    member _.Value =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``kind``: MarkupKind, ``value``: global.Amongonz.LspTypes.LspString) =
        MarkupContent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``value`` = ``value``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``value``
                    writer.WritePropertyName("value")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (MarkupKind.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(MarkupContent.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Inlay hint options used during static registration.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resolveProvider``: global.FSharp.Core.bool option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for an inlay hint item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        InlayHintOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resolveProvider`` = ``resolveProvider``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlayHintOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A full diagnostic report with a set of related documents.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RelatedFullDocumentDiagnosticReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resultId``: global.Amongonz.LspTypes.LspString option
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RelatedFullDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Diagnostics of related documents. This information is useful
    /// in programming languages where code in a file A can generate
    /// diagnostics in a file B which A depends on. An example of
    /// such a language is C/C++ where marco definitions in a file
    /// a.cpp and result in errors in a header file b.hpp.
    ///
    /// @since 3.17.0
    member _.RelatedDocuments =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``relatedDocuments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedDocuments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A full document diagnostic report.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// An optional result id. If provided it will
    /// be sent on the next diagnostic request for the
    /// same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        RelatedFullDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``relatedDocuments`` = ``relatedDocuments``
                    ``kind`` = ``kind``
                    ``resultId`` = ``resultId``
                    ``items`` = ``items``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``relatedDocuments`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("relatedDocuments")
                        value.WriteTo(writer)

                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)

                    match backingObj.``resultId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resultId")
                        value.WriteTo(writer)

                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RelatedFullDocumentDiagnosticReport.FromElement(element))

/// An unchanged diagnostic report with a set of related documents.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RelatedUnchangedDocumentDiagnosticReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resultId``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RelatedUnchangedDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Diagnostics of related documents. This information is useful
    /// in programming languages where code in a file A can generate
    /// diagnostics in a file B which A depends on. An example of
    /// such a language is C/C++ where marco definitions in a file
    /// a.cpp and result in errors in a header file b.hpp.
    ///
    /// @since 3.17.0
    member _.RelatedDocuments =
        // Complex type kind: map.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``relatedDocuments`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedDocuments") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A document diagnostic report indicating
    /// no changes to the last result. A server can
    /// only return `unchanged` if result ids are
    /// provided.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// A result id which will be sent on the next
    /// diagnostic request for the same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``resultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("resultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``resultId``: global.Amongonz.LspTypes.LspString,
            ?``relatedDocuments``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        RelatedUnchangedDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``relatedDocuments`` = ``relatedDocuments``
                    ``kind`` = ``kind``
                    ``resultId`` = ``resultId``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``relatedDocuments`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("relatedDocuments")
                        value.WriteTo(writer)

                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``resultId``
                    writer.WritePropertyName("resultId")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RelatedUnchangedDocumentDiagnosticReport.FromElement(element))

/// A diagnostic report with a full set of problems.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FullDocumentDiagnosticReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resultId``: global.Amongonz.LspTypes.LspString option
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FullDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A full document diagnostic report.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// An optional result id. If provided it will
    /// be sent on the next diagnostic request for the
    /// same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        FullDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``resultId`` = ``resultId``
                    ``items`` = ``items``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)

                    match backingObj.``resultId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resultId")
                        value.WriteTo(writer)

                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FullDocumentDiagnosticReport.FromElement(element))

/// A diagnostic report indicating that the last returned
/// report is still accurate.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type UnchangedDocumentDiagnosticReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resultId``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        UnchangedDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A document diagnostic report indicating
    /// no changes to the last result. A server can
    /// only return `unchanged` if result ids are
    /// provided.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// A result id which will be sent on the next
    /// diagnostic request for the same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``resultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("resultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ``resultId``: global.Amongonz.LspTypes.LspString) =
        UnchangedDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``resultId`` = ``resultId``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``resultId``
                    writer.WritePropertyName("resultId")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(UnchangedDocumentDiagnosticReport.FromElement(element))

/// Diagnostic options.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``identifier``: global.Amongonz.LspTypes.LspString option
                ``interFileDependencies``: global.FSharp.Core.bool
                ``workspaceDiagnostics``: global.FSharp.Core.bool
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional identifier under which the diagnostics are
    /// managed by the client.
    member _.Identifier =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``identifier`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("identifier") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// Whether the language has inter file dependencies meaning that
    /// editing code in one file can result in a different diagnostic
    /// set in another file. Inter file dependencies are common for
    /// most programming languages and typically uncommon for linters.
    member _.InterFileDependencies =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``interFileDependencies``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("interFileDependencies")
            prop.GetBoolean()

    /// The server provides support for workspace diagnostics as well.
    member _.WorkspaceDiagnostics =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``workspaceDiagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("workspaceDiagnostics")
            prop.GetBoolean()

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``interFileDependencies``: global.FSharp.Core.bool,
            ``workspaceDiagnostics``: global.FSharp.Core.bool,
            ?``identifier``: global.Amongonz.LspTypes.LspString,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        DiagnosticOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``identifier`` = ``identifier``
                    ``interFileDependencies`` = ``interFileDependencies``
                    ``workspaceDiagnostics`` = ``workspaceDiagnostics``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``identifier`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("identifier")
                        value.WriteTo(writer)

                    let value = backingObj.``interFileDependencies``
                    writer.WriteBoolean("interFileDependencies", value)
                    let value = backingObj.``workspaceDiagnostics``
                    writer.WriteBoolean("workspaceDiagnostics", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "identifier" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "interFileDependencies" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspaceDiagnostics" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A previous result id in a workspace pull request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PreviousResultId
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``value``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PreviousResultId(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which the client knowns a
    /// result id.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The value of the previous result id.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``uri``: global.Amongonz.LspTypes.LspDocumentUri, ``value``: global.Amongonz.LspTypes.LspString)
        =
        PreviousResultId(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``value`` = ``value``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``value``
                    writer.WritePropertyName("value")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "value" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(PreviousResultId.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A notebook document.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocument
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.System.Uri
                ``notebookType``: global.Amongonz.LspTypes.LspString
                ``version``: global.FSharp.Core.int
                ``metadata``: LSPObject option
                ``cells``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocument(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    /// The type of the notebook.
    member _.NotebookType =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebookType``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookType")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The version number of this document (it will increase after each
    /// change, including undo/redo).
    member _.Version =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// Additional metadata stored with the notebook
    /// document.
    ///
    /// Note: should always be an object literal (e.g. LSPObject)
    member _.Metadata =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``metadata`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("metadata") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPObject.FromElement(prop))

    /// The cells of a notebook.
    member _.Cells =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``cells``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("cells")
            LspJsonBacking.Element prop

    static member Create
        (
            ``uri``: global.System.Uri,
            ``notebookType``: global.Amongonz.LspTypes.LspString,
            ``version``: global.FSharp.Core.int,
            ``cells``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``metadata``: LSPObject
        ) =
        NotebookDocument(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``notebookType`` = ``notebookType``
                    ``version`` = ``version``
                    ``metadata`` = ``metadata``
                    ``cells`` = ``cells``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``notebookType``
                    writer.WritePropertyName("notebookType")
                    value.WriteTo(writer)
                    let value = backingObj.``version``
                    writer.WriteNumber("version", value)

                    match backingObj.``metadata`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("metadata")
                        value.WriteTo(writer)

                    let value = backingObj.``cells``
                    writer.WritePropertyName("cells")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocument.FromElement(element))

/// An item to transfer a text document from the client to the
/// server.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentItem
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``languageId``: global.Amongonz.LspTypes.LspString
                ``version``: global.FSharp.Core.int
                ``text``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentItem(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The text document&apos;s language identifier.
    member _.LanguageId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``languageId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("languageId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The version number of this document (it will increase after each
    /// change, including undo/redo).
    member _.Version =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// The content of the opened text document.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``text``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("text")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``languageId``: global.Amongonz.LspTypes.LspString,
            ``version``: global.FSharp.Core.int,
            ``text``: global.Amongonz.LspTypes.LspString
        ) =
        TextDocumentItem(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``languageId`` = ``languageId``
                    ``version`` = ``version``
                    ``text`` = ``text``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``languageId``
                    writer.WritePropertyName("languageId")
                    value.WriteTo(writer)
                    let value = backingObj.``version``
                    writer.WriteNumber("version", value)
                    let value = backingObj.``text``
                    writer.WritePropertyName("text")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "languageId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextDocumentItem.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A versioned notebook document identifier.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type VersionedNotebookDocumentIdentifier
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``version``: global.FSharp.Core.int
                ``uri``: global.System.Uri
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        VersionedNotebookDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The version number of this notebook document.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// The notebook document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    static member Create(``version``: global.FSharp.Core.int, ``uri``: global.System.Uri) =
        VersionedNotebookDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``version`` = ``version``
                    ``uri`` = ``uri``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``version``
                    writer.WriteNumber("version", value)
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(VersionedNotebookDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A change event for a notebook document.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentChangeEvent
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``metadata``: LSPObject option
                ``cells``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentChangeEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The changed meta data if any.
    ///
    /// Note: should always be an object literal (e.g. LSPObject)
    member _.Metadata =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``metadata`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("metadata") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPObject.FromElement(prop))

    /// Changes to cells
    member _.Cells =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``cells`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cells") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create(?``metadata``: LSPObject, ?``cells``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        NotebookDocumentChangeEvent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``metadata`` = ``metadata``
                    ``cells`` = ``cells``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``metadata`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("metadata")
                        value.WriteTo(writer)

                    match backingObj.``cells`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("cells")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocumentChangeEvent.FromElement(element))

/// A literal to identify a notebook document in the client.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentIdentifier
    private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``uri``: global.System.Uri |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebook document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.System.Uri(prop.GetString())

    static member Create(``uri``: global.System.Uri) =
        NotebookDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``uri`` = ``uri`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(NotebookDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provides information about the context in which an inline completion was requested.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionContext
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``triggerKind``: InlineCompletionTriggerKind
                ``selectedCompletionInfo``: SelectedCompletionInfo option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Describes how the inline completion was triggered.
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``triggerKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("triggerKind")
            InlineCompletionTriggerKind.FromElement(prop)

    /// Provides information about the currently selected item in the autocomplete widget if it is visible.
    member _.SelectedCompletionInfo =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``selectedCompletionInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selectedCompletionInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SelectedCompletionInfo.FromElement(prop))

    static member Create
        (``triggerKind``: InlineCompletionTriggerKind, ?``selectedCompletionInfo``: SelectedCompletionInfo)
        =
        InlineCompletionContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``triggerKind`` = ``triggerKind``
                    ``selectedCompletionInfo`` = ``selectedCompletionInfo``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``triggerKind``
                    writer.WriteNumber("triggerKind", int value)

                    match backingObj.``selectedCompletionInfo`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("selectedCompletionInfo")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerKind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "selectedCompletionInfo" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SelectedCompletionInfo.Parse(prop)))
        then
            global.FSharp.Core.Ok(InlineCompletionContext.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A string value used as a snippet is a template which allows to insert text
/// and to control the editor cursor when insertion happens.
///
/// A snippet can define tab stops and placeholders with `$1`, `$2`
/// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
/// the end of the snippet. Variables are defined with `$name` and
/// `${name:default value}`.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type StringValue
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``value``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        StringValue(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The kind of string value.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// The snippet string.
    member _.Value =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``value``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("value")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ``value``: global.Amongonz.LspTypes.LspString) =
        StringValue(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``value`` = ``value``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``value``
                    writer.WritePropertyName("value")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(StringValue.FromElement(element))

/// Inline completion options used during static registration.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        InlineCompletionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineCompletionOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// General parameters to register for a notification or to register a provider.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Registration
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``id``: global.Amongonz.LspTypes.LspString
                ``method``: global.Amongonz.LspTypes.LspString
                ``registerOptions``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Registration(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The id used to register the request. The id can be used to deregister
    /// the request again.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``id``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("id")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The method / capability to register for.
    member _.Method =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``method``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("method")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Options necessary for the registration.
    member _.RegisterOptions =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``registerOptions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("registerOptions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``id``: global.Amongonz.LspTypes.LspString,
            ``method``: global.Amongonz.LspTypes.LspString,
            ?``registerOptions``: LSPAny
        ) =
        Registration(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``id`` = ``id``
                    ``method`` = ``method``
                    ``registerOptions`` = ``registerOptions``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``id``
                    writer.WritePropertyName("id")
                    value.WriteTo(writer)
                    let value = backingObj.``method``
                    writer.WritePropertyName("method")
                    value.WriteTo(writer)

                    match backingObj.``registerOptions`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("registerOptions")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "id" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "method" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "registerOptions" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(Registration.FromElement(element))
        else
            global.FSharp.Core.Error()

/// General parameters to unregister a request or notification.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Unregistration
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``id``: global.Amongonz.LspTypes.LspString
                ``method``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Unregistration(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The id used to unregister the request or notification. Usually an id
    /// provided during the register request.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``id``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("id")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The method to unregister for.
    member _.Method =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``method``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("method")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``id``: global.Amongonz.LspTypes.LspString, ``method``: global.Amongonz.LspTypes.LspString) =
        Unregistration(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``id`` = ``id``
                    ``method`` = ``method``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``id``
                    writer.WritePropertyName("id")
                    value.WriteTo(writer)
                    let value = backingObj.``method``
                    writer.WritePropertyName("method")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "id" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "method" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(Unregistration.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The initialize parameters
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type _InitializeParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``processId``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``locale``: global.Amongonz.LspTypes.LspString option
                ``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``capabilities``: ClientCapabilities
                ``initializationOptions``: LSPAny option
                ``trace``: TraceValues option
                ``workDoneToken``: ProgressToken option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        _InitializeParams (global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The process Id of the parent process that started
    /// the server.
    ///
    /// Is `null` if the process has not been started by another process.
    /// If the parent process is not alive then the server should exit.
    member _.ProcessId =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``processId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("processId")
            LspJsonBacking.Element prop

    /// Information about the client
    ///
    /// @since 3.15.0
    member _.ClientInfo =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``clientInfo`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("clientInfo") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The locale the client is currently showing the user interface
    /// in. This must not necessarily be the locale of the operating
    /// system.
    ///
    /// Uses IETF language tags as the value&apos;s syntax
    /// (See https://en.wikipedia.org/wiki/IETF_language_tag)
    ///
    /// @since 3.16.0
    member _.Locale =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``locale`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("locale") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The rootPath of the workspace. Is null
    /// if no folder is open.
    ///
    /// @deprecated in favour of rootUri.
    [<global.System.Obsolete("in favour of rootUri.")>]
    member _.RootPath =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rootPath`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rootPath") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The rootUri of the workspace. Is null if no
    /// folder is open. If both `rootPath` and `rootUri` are set
    /// `rootUri` wins.
    ///
    /// @deprecated in favour of workspaceFolders.
    [<global.System.Obsolete("in favour of workspaceFolders.")>]
    member _.RootUri =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``rootUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("rootUri")
            LspJsonBacking.Element prop

    /// The capabilities provided by the client (editor or tool)
    member _.Capabilities =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``capabilities``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("capabilities")
            ClientCapabilities.FromElement(prop)

    /// User provided initialization options.
    member _.InitializationOptions =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``initializationOptions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("initializationOptions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    /// The initial trace setting. If omitted trace is disabled (&apos;off&apos;).
    member _.Trace =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``trace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TraceValues.FromElement(prop))

    /// An optional token that a server can use to report work done progress.
    member _.WorkDoneToken =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneToken`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneToken") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ProgressToken.FromElement(prop))

    static member Create
        (
            ``processId``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``rootUri``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``capabilities``: ClientCapabilities,
            ?``clientInfo``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``locale``: global.Amongonz.LspTypes.LspString,
            ?``rootPath``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``initializationOptions``: LSPAny,
            ?``trace``: TraceValues,
            ?``workDoneToken``: ProgressToken
        ) =
        _InitializeParams (
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``processId`` = ``processId``
                    ``clientInfo`` = ``clientInfo``
                    ``locale`` = ``locale``
                    ``rootPath`` = ``rootPath``
                    ``rootUri`` = ``rootUri``
                    ``capabilities`` = ``capabilities``
                    ``initializationOptions`` = ``initializationOptions``
                    ``trace`` = ``trace``
                    ``workDoneToken`` = ``workDoneToken``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``processId``
                    writer.WritePropertyName("processId")
                    value.WriteTo(writer)

                    match backingObj.``clientInfo`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("clientInfo")
                        value.WriteTo(writer)

                    match backingObj.``locale`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("locale")
                        value.WriteTo(writer)

                    match backingObj.``rootPath`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("rootPath")
                        value.WriteTo(writer)

                    let value = backingObj.``rootUri``
                    writer.WritePropertyName("rootUri")
                    value.WriteTo(writer)
                    let value = backingObj.``capabilities``
                    writer.WritePropertyName("capabilities")
                    value.WriteTo(writer)

                    match backingObj.``initializationOptions`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("initializationOptions")
                        value.WriteTo(writer)

                    match backingObj.``trace`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("trace")
                        value.WriteTo(writer)

                    match backingObj.``workDoneToken`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workDoneToken")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(_InitializeParams.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFoldersInitializeParams
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFoldersInitializeParams(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The workspace folders configured in the client when the server starts.
    ///
    /// This property is only available if the client supports workspace folders.
    /// It can be `null` if the client supports workspace folders but none are
    /// configured.
    ///
    /// @since 3.6.0
    member _.WorkspaceFolders =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workspaceFolders`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceFolders") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create(?``workspaceFolders``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        WorkspaceFoldersInitializeParams(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workspaceFolders`` = ``workspaceFolders``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workspaceFolders`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workspaceFolders")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFoldersInitializeParams.FromElement(element))

/// Defines the capabilities provided by a language
/// server.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ServerCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``positionEncoding``: PositionEncodingKind option
                ``textDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``notebookDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``completionProvider``: CompletionOptions option
                ``hoverProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``signatureHelpProvider``: SignatureHelpOptions option
                ``declarationProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``definitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``typeDefinitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``implementationProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``referencesProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``documentHighlightProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``documentSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``codeActionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``codeLensProvider``: CodeLensOptions option
                ``documentLinkProvider``: DocumentLinkOptions option
                ``colorProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``workspaceSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``documentFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``documentRangeFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``documentOnTypeFormattingProvider``: DocumentOnTypeFormattingOptions option
                ``renameProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``foldingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``selectionRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``executeCommandProvider``: ExecuteCommandOptions option
                ``callHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``linkedEditingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``semanticTokensProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``monikerProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``typeHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``inlineValueProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``inlayHintProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``diagnosticProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``inlineCompletionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``workspace``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``experimental``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ServerCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The position encoding the server picked from the encodings offered
    /// by the client via the client capability `general.positionEncodings`.
    ///
    /// If the client didn&apos;t provide any position encodings the only valid
    /// value that a server can return is &apos;utf-16&apos;.
    ///
    /// If omitted it defaults to &apos;utf-16&apos;.
    ///
    /// @since 3.17.0
    member _.PositionEncoding =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``positionEncoding`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("positionEncoding") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(PositionEncodingKind.FromElement(prop))

    /// Defines how text documents are synced. Is either a detailed structure
    /// defining each notification or for backwards compatibility the
    /// TextDocumentSyncKind number.
    member _.TextDocumentSync =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``textDocumentSync`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textDocumentSync") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Defines how notebook documents are synced.
    ///
    /// @since 3.17.0
    member _.NotebookDocumentSync =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``notebookDocumentSync`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("notebookDocumentSync") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides completion support.
    member _.CompletionProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``completionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionOptions.FromElement(prop))

    /// The server provides hover support.
    member _.HoverProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``hoverProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("hoverProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides signature help support.
    member _.SignatureHelpProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``signatureHelpProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("signatureHelpProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelpOptions.FromElement(prop))

    /// The server provides Goto Declaration support.
    member _.DeclarationProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``declarationProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("declarationProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides goto definition support.
    member _.DefinitionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``definitionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("definitionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides Goto Type Definition support.
    member _.TypeDefinitionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``typeDefinitionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeDefinitionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides Goto Implementation support.
    member _.ImplementationProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``implementationProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("implementationProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides find references support.
    member _.ReferencesProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``referencesProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("referencesProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document highlight support.
    member _.DocumentHighlightProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentHighlightProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentHighlightProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document symbol support.
    member _.DocumentSymbolProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentSymbolProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentSymbolProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides code actions. CodeActionOptions may only be
    /// specified if the client states that it supports
    /// `codeActionLiteralSupport` in its initial `initialize` request.
    member _.CodeActionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeActionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides code lens.
    member _.CodeLensProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeLensProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeLensProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeLensOptions.FromElement(prop))

    /// The server provides document link support.
    member _.DocumentLinkProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentLinkProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentLinkProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentLinkOptions.FromElement(prop))

    /// The server provides color provider support.
    member _.ColorProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``colorProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("colorProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides workspace symbol support.
    member _.WorkspaceSymbolProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workspaceSymbolProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceSymbolProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document formatting.
    member _.DocumentFormattingProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentFormattingProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentFormattingProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document range formatting.
    member _.DocumentRangeFormattingProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentRangeFormattingProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentRangeFormattingProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides document formatting on typing.
    member _.DocumentOnTypeFormattingProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentOnTypeFormattingProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentOnTypeFormattingProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentOnTypeFormattingOptions.FromElement(prop))

    /// The server provides rename support. RenameOptions may only be
    /// specified if the client states that it supports
    /// `prepareSupport` in its initial `initialize` request.
    member _.RenameProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``renameProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("renameProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides folding provider support.
    member _.FoldingRangeProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``foldingRangeProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRangeProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides selection range support.
    member _.SelectionRangeProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``selectionRangeProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selectionRangeProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides execute command support.
    member _.ExecuteCommandProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``executeCommandProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executeCommandProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ExecuteCommandOptions.FromElement(prop))

    /// The server provides call hierarchy support.
    ///
    /// @since 3.16.0
    member _.CallHierarchyProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``callHierarchyProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("callHierarchyProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides linked editing range support.
    ///
    /// @since 3.16.0
    member _.LinkedEditingRangeProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``linkedEditingRangeProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkedEditingRangeProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides semantic tokens support.
    ///
    /// @since 3.16.0
    member _.SemanticTokensProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``semanticTokensProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("semanticTokensProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides moniker support.
    ///
    /// @since 3.16.0
    member _.MonikerProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``monikerProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("monikerProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides type hierarchy support.
    ///
    /// @since 3.17.0
    member _.TypeHierarchyProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``typeHierarchyProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeHierarchyProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides inline values.
    ///
    /// @since 3.17.0
    member _.InlineValueProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlineValueProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineValueProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides inlay hints.
    ///
    /// @since 3.17.0
    member _.InlayHintProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlayHintProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlayHintProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server has support for pull model diagnostics.
    ///
    /// @since 3.17.0
    member _.DiagnosticProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``diagnosticProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnosticProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Inline completion options used during static registration.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.InlineCompletionProvider =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlineCompletionProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineCompletionProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Workspace specific server capabilities.
    member _.Workspace =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workspace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Experimental server capabilities.
    member _.Experimental =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``experimental`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("experimental") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ?``positionEncoding``: PositionEncodingKind,
            ?``textDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``notebookDocumentSync``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``completionProvider``: CompletionOptions,
            ?``hoverProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``signatureHelpProvider``: SignatureHelpOptions,
            ?``declarationProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``definitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``typeDefinitionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``implementationProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``referencesProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``documentHighlightProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``documentSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``codeActionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``codeLensProvider``: CodeLensOptions,
            ?``documentLinkProvider``: DocumentLinkOptions,
            ?``colorProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``workspaceSymbolProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``documentFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``documentRangeFormattingProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``documentOnTypeFormattingProvider``: DocumentOnTypeFormattingOptions,
            ?``renameProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``foldingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``selectionRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``executeCommandProvider``: ExecuteCommandOptions,
            ?``callHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``linkedEditingRangeProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``semanticTokensProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``monikerProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``typeHierarchyProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``inlineValueProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``inlayHintProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``diagnosticProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``inlineCompletionProvider``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``workspace``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``experimental``: LSPAny
        ) =
        ServerCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``positionEncoding`` = ``positionEncoding``
                    ``textDocumentSync`` = ``textDocumentSync``
                    ``notebookDocumentSync`` = ``notebookDocumentSync``
                    ``completionProvider`` = ``completionProvider``
                    ``hoverProvider`` = ``hoverProvider``
                    ``signatureHelpProvider`` = ``signatureHelpProvider``
                    ``declarationProvider`` = ``declarationProvider``
                    ``definitionProvider`` = ``definitionProvider``
                    ``typeDefinitionProvider`` = ``typeDefinitionProvider``
                    ``implementationProvider`` = ``implementationProvider``
                    ``referencesProvider`` = ``referencesProvider``
                    ``documentHighlightProvider`` = ``documentHighlightProvider``
                    ``documentSymbolProvider`` = ``documentSymbolProvider``
                    ``codeActionProvider`` = ``codeActionProvider``
                    ``codeLensProvider`` = ``codeLensProvider``
                    ``documentLinkProvider`` = ``documentLinkProvider``
                    ``colorProvider`` = ``colorProvider``
                    ``workspaceSymbolProvider`` = ``workspaceSymbolProvider``
                    ``documentFormattingProvider`` = ``documentFormattingProvider``
                    ``documentRangeFormattingProvider`` = ``documentRangeFormattingProvider``
                    ``documentOnTypeFormattingProvider`` = ``documentOnTypeFormattingProvider``
                    ``renameProvider`` = ``renameProvider``
                    ``foldingRangeProvider`` = ``foldingRangeProvider``
                    ``selectionRangeProvider`` = ``selectionRangeProvider``
                    ``executeCommandProvider`` = ``executeCommandProvider``
                    ``callHierarchyProvider`` = ``callHierarchyProvider``
                    ``linkedEditingRangeProvider`` = ``linkedEditingRangeProvider``
                    ``semanticTokensProvider`` = ``semanticTokensProvider``
                    ``monikerProvider`` = ``monikerProvider``
                    ``typeHierarchyProvider`` = ``typeHierarchyProvider``
                    ``inlineValueProvider`` = ``inlineValueProvider``
                    ``inlayHintProvider`` = ``inlayHintProvider``
                    ``diagnosticProvider`` = ``diagnosticProvider``
                    ``inlineCompletionProvider`` = ``inlineCompletionProvider``
                    ``workspace`` = ``workspace``
                    ``experimental`` = ``experimental``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``positionEncoding`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("positionEncoding")
                        value.WriteTo(writer)

                    match backingObj.``textDocumentSync`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("textDocumentSync")
                        value.WriteTo(writer)

                    match backingObj.``notebookDocumentSync`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("notebookDocumentSync")
                        value.WriteTo(writer)

                    match backingObj.``completionProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("completionProvider")
                        value.WriteTo(writer)

                    match backingObj.``hoverProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("hoverProvider")
                        value.WriteTo(writer)

                    match backingObj.``signatureHelpProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("signatureHelpProvider")
                        value.WriteTo(writer)

                    match backingObj.``declarationProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("declarationProvider")
                        value.WriteTo(writer)

                    match backingObj.``definitionProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("definitionProvider")
                        value.WriteTo(writer)

                    match backingObj.``typeDefinitionProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("typeDefinitionProvider")
                        value.WriteTo(writer)

                    match backingObj.``implementationProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("implementationProvider")
                        value.WriteTo(writer)

                    match backingObj.``referencesProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("referencesProvider")
                        value.WriteTo(writer)

                    match backingObj.``documentHighlightProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentHighlightProvider")
                        value.WriteTo(writer)

                    match backingObj.``documentSymbolProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentSymbolProvider")
                        value.WriteTo(writer)

                    match backingObj.``codeActionProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeActionProvider")
                        value.WriteTo(writer)

                    match backingObj.``codeLensProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeLensProvider")
                        value.WriteTo(writer)

                    match backingObj.``documentLinkProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentLinkProvider")
                        value.WriteTo(writer)

                    match backingObj.``colorProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("colorProvider")
                        value.WriteTo(writer)

                    match backingObj.``workspaceSymbolProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workspaceSymbolProvider")
                        value.WriteTo(writer)

                    match backingObj.``documentFormattingProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentFormattingProvider")
                        value.WriteTo(writer)

                    match backingObj.``documentRangeFormattingProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentRangeFormattingProvider")
                        value.WriteTo(writer)

                    match backingObj.``documentOnTypeFormattingProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentOnTypeFormattingProvider")
                        value.WriteTo(writer)

                    match backingObj.``renameProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("renameProvider")
                        value.WriteTo(writer)

                    match backingObj.``foldingRangeProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("foldingRangeProvider")
                        value.WriteTo(writer)

                    match backingObj.``selectionRangeProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("selectionRangeProvider")
                        value.WriteTo(writer)

                    match backingObj.``executeCommandProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("executeCommandProvider")
                        value.WriteTo(writer)

                    match backingObj.``callHierarchyProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("callHierarchyProvider")
                        value.WriteTo(writer)

                    match backingObj.``linkedEditingRangeProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("linkedEditingRangeProvider")
                        value.WriteTo(writer)

                    match backingObj.``semanticTokensProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("semanticTokensProvider")
                        value.WriteTo(writer)

                    match backingObj.``monikerProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("monikerProvider")
                        value.WriteTo(writer)

                    match backingObj.``typeHierarchyProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("typeHierarchyProvider")
                        value.WriteTo(writer)

                    match backingObj.``inlineValueProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlineValueProvider")
                        value.WriteTo(writer)

                    match backingObj.``inlayHintProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlayHintProvider")
                        value.WriteTo(writer)

                    match backingObj.``diagnosticProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("diagnosticProvider")
                        value.WriteTo(writer)

                    match backingObj.``inlineCompletionProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlineCompletionProvider")
                        value.WriteTo(writer)

                    match backingObj.``workspace`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workspace")
                        value.WriteTo(writer)

                    match backingObj.``experimental`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("experimental")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ServerCapabilities.FromElement(element))

/// A text document identifier to denote a specific version of a text document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type VersionedTextDocumentIdentifier
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``version``: global.FSharp.Core.int
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        VersionedTextDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The version number of this document.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            prop.GetInt32()

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    static member Create(``version``: global.FSharp.Core.int, ``uri``: global.Amongonz.LspTypes.LspDocumentUri) =
        VersionedTextDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``version`` = ``version``
                    ``uri`` = ``uri``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``version``
                    writer.WriteNumber("version", value)
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(VersionedTextDocumentIdentifier.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Save options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SaveOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``includeText``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SaveOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client is supposed to include the content on save.
    member _.IncludeText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``includeText`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("includeText") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``includeText``: global.FSharp.Core.bool) =
        SaveOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``includeText`` = ``includeText`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``includeText`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("includeText", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "includeText" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SaveOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// An event describing a file change.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileEvent
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``type``: FileChangeType
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The file&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The change type.
    member _.Type =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``type``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("type")
            FileChangeType.FromElement(prop)

    static member Create(``uri``: global.Amongonz.LspTypes.LspDocumentUri, ``type``: FileChangeType) =
        FileEvent(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``type`` = ``type``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``type``
                    writer.WriteNumber("type", int value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "uri" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "type" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
        then
            global.FSharp.Core.Ok(FileEvent.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileSystemWatcher
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``globPattern``: GlobPattern
                ``kind``: WatchKind option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileSystemWatcher(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The glob pattern to watch. See {@link GlobPattern glob pattern} for more detail.
    ///
    /// @since 3.17.0 support for relative patterns.
    member _.GlobPattern =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``globPattern``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("globPattern")
            GlobPattern.FromElement(prop)

    /// The kind of events of interest. If omitted it defaults
    /// to WatchKind.Create | WatchKind.Change | WatchKind.Delete
    /// which is 7.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``kind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("kind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome((prop.GetInt32(): WatchKind))

    static member Create(``globPattern``: GlobPattern, ?``kind``: WatchKind) =
        FileSystemWatcher(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``globPattern`` = ``globPattern``
                    ``kind`` = ``kind``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``globPattern``
                    writer.WritePropertyName("globPattern")
                    value.WriteTo(writer)

                    match backingObj.``kind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("kind", int value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "globPattern" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (GlobPattern.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> true)
        then
            global.FSharp.Core.Ok(FileSystemWatcher.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
/// are only valid in the scope of a resource.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Diagnostic
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``severity``: DiagnosticSeverity option
                ``code``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``codeDescription``: CodeDescription option
                ``source``: global.Amongonz.LspTypes.LspString option
                ``message``: global.Amongonz.LspTypes.LspString
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``relatedInformation``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``data``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Diagnostic(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range at which the message applies
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The diagnostic&apos;s severity. Can be omitted. If omitted it is up to the
    /// client to interpret diagnostics as error, warning, info or hint.
    member _.Severity =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``severity`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("severity") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DiagnosticSeverity.FromElement(prop))

    /// The diagnostic&apos;s code, which usually appear in the user interface.
    member _.Code =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``code`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("code") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An optional property to describe the error code.
    /// Requires the code field (above) to be present/not null.
    ///
    /// @since 3.16.0
    member _.CodeDescription =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeDescription`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeDescription") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeDescription.FromElement(prop))

    /// A human-readable string describing the source of this
    /// diagnostic, e.g. &apos;typescript&apos; or &apos;super lint&apos;. It usually
    /// appears in the user interface.
    member _.Source =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``source`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("source") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The diagnostic&apos;s message. It usually appears in the user interface
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Additional metadata about the diagnostic.
    ///
    /// @since 3.15.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// An array of related diagnostic information, e.g. when symbol-names within
    /// a scope collide all definitions can be marked via this property.
    member _.RelatedInformation =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``relatedInformation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedInformation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// A data entry field that is preserved between a `textDocument/publishDiagnostics`
    /// notification and `textDocument/codeAction` request.
    ///
    /// @since 3.16.0
    member _.Data =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``data`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("data") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ``range``: Range,
            ``message``: global.Amongonz.LspTypes.LspString,
            ?``severity``: DiagnosticSeverity,
            ?``code``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``codeDescription``: CodeDescription,
            ?``source``: global.Amongonz.LspTypes.LspString,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``relatedInformation``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``data``: LSPAny
        ) =
        Diagnostic(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``severity`` = ``severity``
                    ``code`` = ``code``
                    ``codeDescription`` = ``codeDescription``
                    ``source`` = ``source``
                    ``message`` = ``message``
                    ``tags`` = ``tags``
                    ``relatedInformation`` = ``relatedInformation``
                    ``data`` = ``data``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)

                    match backingObj.``severity`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("severity", int value)

                    match backingObj.``code`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("code")
                        value.WriteTo(writer)

                    match backingObj.``codeDescription`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeDescription")
                        value.WriteTo(writer)

                    match backingObj.``source`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("source")
                        value.WriteTo(writer)

                    let value = backingObj.``message``
                    writer.WritePropertyName("message")
                    value.WriteTo(writer)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``relatedInformation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("relatedInformation")
                        value.WriteTo(writer)

                    match backingObj.``data`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("data")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(Diagnostic.FromElement(element))

/// Contains additional information about the context in which a completion request is triggered.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionContext
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``triggerKind``: CompletionTriggerKind
                ``triggerCharacter``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// How the completion was triggered.
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``triggerKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("triggerKind")
            CompletionTriggerKind.FromElement(prop)

    /// The trigger character (a single character) that has trigger code complete.
    /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
    member _.TriggerCharacter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``triggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``triggerKind``: CompletionTriggerKind, ?``triggerCharacter``: global.Amongonz.LspTypes.LspString)
        =
        CompletionContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``triggerKind`` = ``triggerKind``
                    ``triggerCharacter`` = ``triggerCharacter``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``triggerKind``
                    writer.WriteNumber("triggerKind", int value)

                    match backingObj.``triggerCharacter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("triggerCharacter")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerKind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(CompletionContext.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Additional details for a completion item label.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionItemLabelDetails
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``detail``: global.Amongonz.LspTypes.LspString option
                ``description``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionItemLabelDetails(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
    /// without any spacing. Should be used for function signatures and type annotations.
    member _.Detail =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``detail`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("detail") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
    /// for fully qualified names and file paths.
    member _.Description =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``description`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("description") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (?``detail``: global.Amongonz.LspTypes.LspString, ?``description``: global.Amongonz.LspTypes.LspString) =
        CompletionItemLabelDetails(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``detail`` = ``detail``
                    ``description`` = ``description``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``detail`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("detail")
                        value.WriteTo(writer)

                    match backingObj.``description`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("description")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "detail" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "description" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(CompletionItemLabelDetails.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A special text edit to provide an insert and a replace operation.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InsertReplaceEdit
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``newText``: global.Amongonz.LspTypes.LspString
                ``insert``: Range
                ``replace``: Range
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InsertReplaceEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The string to be inserted.
    member _.NewText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``newText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newText")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The range if the insert is requested
    member _.Insert =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``insert``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("insert")
            Range.FromElement(prop)

    /// The range if the replace is requested.
    member _.Replace =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``replace``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("replace")
            Range.FromElement(prop)

    static member Create(``newText``: global.Amongonz.LspTypes.LspString, ``insert``: Range, ``replace``: Range) =
        InsertReplaceEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``newText`` = ``newText``
                    ``insert`` = ``insert``
                    ``replace`` = ``replace``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``newText``
                    writer.WritePropertyName("newText")
                    value.WriteTo(writer)
                    let value = backingObj.``insert``
                    writer.WritePropertyName("insert")
                    value.WriteTo(writer)
                    let value = backingObj.``replace``
                    writer.WritePropertyName("replace")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "newText" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "insert" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "replace" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
        then
            global.FSharp.Core.Ok(InsertReplaceEdit.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Completion options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``resolveProvider``: global.FSharp.Core.bool option
                ``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Most tools trigger completion request automatically without explicitly requesting
    /// it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
    /// starts to type an identifier. For example if the user types `c` in a JavaScript file
    /// code complete will automatically pop up present `console` besides others as a
    /// completion item. Characters that make up identifiers don&apos;t need to be listed here.
    ///
    /// If code complete should automatically be trigger on characters not being valid inside
    /// an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The list of all possible characters that commit a completion. This field can be used
    /// if clients don&apos;t support individual commit characters per completion item. See
    /// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
    ///
    /// If a server provides both `allCommitCharacters` and commit characters on an individual
    /// completion item the ones on the completion item win.
    ///
    /// @since 3.2.0
    member _.AllCommitCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``allCommitCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("allCommitCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a completion item.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The server supports the following `CompletionItem` specific
    /// capabilities.
    ///
    /// @since 3.17.0
    member _.CompletionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``completionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``allCommitCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        CompletionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``triggerCharacters`` = ``triggerCharacters``
                    ``allCommitCharacters`` = ``allCommitCharacters``
                    ``resolveProvider`` = ``resolveProvider``
                    ``completionItem`` = ``completionItem``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``triggerCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("triggerCharacters")
                        value.WriteTo(writer)

                    match backingObj.``allCommitCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("allCommitCharacters")
                        value.WriteTo(writer)

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    match backingObj.``completionItem`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("completionItem")
                        value.WriteTo(writer)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionOptions.FromElement(element))

/// Hover options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        HoverOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(HoverOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Additional information about the context in which a signature help request was triggered.
///
/// @since 3.15.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpContext
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``triggerKind``: SignatureHelpTriggerKind
                ``triggerCharacter``: global.Amongonz.LspTypes.LspString option
                ``isRetrigger``: global.FSharp.Core.bool
                ``activeSignatureHelp``: SignatureHelp option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Action that caused signature help to be triggered.
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``triggerKind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("triggerKind")
            SignatureHelpTriggerKind.FromElement(prop)

    /// Character that caused signature help to be triggered.
    ///
    /// This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
    member _.TriggerCharacter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``triggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// `true` if signature help was already showing when it was triggered.
    ///
    /// Retriggers occurs when the signature help is already active and can be caused by actions such as
    /// typing a trigger character, a cursor move, or document content changes.
    member _.IsRetrigger =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``isRetrigger``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("isRetrigger")
            prop.GetBoolean()

    /// The currently active `SignatureHelp`.
    ///
    /// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
    /// the user navigating through available signatures.
    member _.ActiveSignatureHelp =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``activeSignatureHelp`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeSignatureHelp") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelp.FromElement(prop))

    static member Create
        (
            ``triggerKind``: SignatureHelpTriggerKind,
            ``isRetrigger``: global.FSharp.Core.bool,
            ?``triggerCharacter``: global.Amongonz.LspTypes.LspString,
            ?``activeSignatureHelp``: SignatureHelp
        ) =
        SignatureHelpContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``triggerKind`` = ``triggerKind``
                    ``triggerCharacter`` = ``triggerCharacter``
                    ``isRetrigger`` = ``isRetrigger``
                    ``activeSignatureHelp`` = ``activeSignatureHelp``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``triggerKind``
                    writer.WriteNumber("triggerKind", int value)

                    match backingObj.``triggerCharacter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("triggerCharacter")
                        value.WriteTo(writer)

                    let value = backingObj.``isRetrigger``
                    writer.WriteBoolean("isRetrigger", value)

                    match backingObj.``activeSignatureHelp`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("activeSignatureHelp")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerKind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "triggerCharacter" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "isRetrigger" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "activeSignatureHelp" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SignatureHelp.Parse(prop)))
        then
            global.FSharp.Core.Ok(SignatureHelpContext.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents the signature of something callable. A signature
/// can have a label, like a function-name, a doc-comment, and
/// a set of parameters.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureInformation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``label``: global.Amongonz.LspTypes.LspString
                ``documentation``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``parameters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``activeParameter``: global.FSharp.Core.int option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this signature. Will be shown in
    /// the UI.
    member _.Label =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The human-readable doc-comment of this signature. Will be shown
    /// in the UI but can be omitted.
    member _.Documentation =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The parameters of this signature.
    member _.Parameters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``parameters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("parameters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The index of the active parameter.
    ///
    /// If provided, this is used in place of `SignatureHelp.activeParameter`.
    ///
    /// @since 3.16.0
    member _.ActiveParameter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``activeParameter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("activeParameter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspString,
            ?``documentation``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``parameters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``activeParameter``: global.FSharp.Core.int
        ) =
        SignatureInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``label`` = ``label``
                    ``documentation`` = ``documentation``
                    ``parameters`` = ``parameters``
                    ``activeParameter`` = ``activeParameter``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``label``
                    writer.WritePropertyName("label")
                    value.WriteTo(writer)

                    match backingObj.``documentation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentation")
                        value.WriteTo(writer)

                    match backingObj.``parameters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("parameters")
                        value.WriteTo(writer)

                    match backingObj.``activeParameter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("activeParameter", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureInformation.FromElement(element))

/// Server Capabilities for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// List of characters that trigger signature help automatically.
    member _.TriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``triggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// List of characters that re-trigger signature help.
    ///
    /// These trigger characters are only active when signature help is already showing. All trigger characters
    /// are also counted as re-trigger characters.
    ///
    /// @since 3.15.0
    member _.RetriggerCharacters =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``retriggerCharacters`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("retriggerCharacters") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``triggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``retriggerCharacters``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        SignatureHelpOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``triggerCharacters`` = ``triggerCharacters``
                    ``retriggerCharacters`` = ``retriggerCharacters``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``triggerCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("triggerCharacters")
                        value.WriteTo(writer)

                    match backingObj.``retriggerCharacters`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("retriggerCharacters")
                        value.WriteTo(writer)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelpOptions.FromElement(element))

/// Server Capabilities for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DefinitionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DefinitionOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Value-object that contains additional information when
/// requesting references.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceContext
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``includeDeclaration``: global.FSharp.Core.bool
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Include the declaration of the current symbol.
    member _.IncludeDeclaration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``includeDeclaration``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("includeDeclaration")
            prop.GetBoolean()

    static member Create(``includeDeclaration``: global.FSharp.Core.bool) =
        ReferenceContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``includeDeclaration`` = ``includeDeclaration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``includeDeclaration``
                    writer.WriteBoolean("includeDeclaration", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "includeDeclaration" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ReferenceContext.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Reference options.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        ReferenceOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ReferenceOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provider options for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentHighlightOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentHighlightOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A base for all symbol information.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type BaseSymbolInformation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``name``: global.Amongonz.LspTypes.LspString
                ``kind``: SymbolKind
                ``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``containerName``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        BaseSymbolInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of this symbol.
    member _.Name =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``name``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("name")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The kind of this symbol.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            SymbolKind.FromElement(prop)

    /// Tags for this symbol.
    ///
    /// @since 3.16.0
    member _.Tags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The name of the symbol containing this symbol. This information is for
    /// user interface purposes (e.g. to render a qualifier in the user interface
    /// if necessary). It can&apos;t be used to re-infer a hierarchy for the document
    /// symbols.
    member _.ContainerName =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``containerName`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("containerName") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``name``: global.Amongonz.LspTypes.LspString,
            ``kind``: SymbolKind,
            ?``tags``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``containerName``: global.Amongonz.LspTypes.LspString
        ) =
        BaseSymbolInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``name`` = ``name``
                    ``kind`` = ``kind``
                    ``tags`` = ``tags``
                    ``containerName`` = ``containerName``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``name``
                    writer.WritePropertyName("name")
                    value.WriteTo(writer)
                    let value = backingObj.``kind``
                    writer.WriteNumber("kind", int value)

                    match backingObj.``tags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tags")
                        value.WriteTo(writer)

                    match backingObj.``containerName`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("containerName")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(BaseSymbolInformation.FromElement(element))

/// Provider options for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``label``: global.Amongonz.LspTypes.LspString option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A human-readable string that is shown when multiple outlines trees
    /// are shown for the same document.
    ///
    /// @since 3.16.0
    member _.Label =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``label`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("label") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``label``: global.Amongonz.LspTypes.LspString, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        DocumentSymbolOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``label`` = ``label``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``label`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("label")
                        value.WriteTo(writer)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "label" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentSymbolOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Contains additional diagnostic information about the context in which
/// a {@link CodeActionProvider.provideCodeActions code action} is run.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionContext
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``only``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``triggerKind``: CodeActionTriggerKind option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionContext(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An array of diagnostics known on the client side overlapping the range provided to the
    /// `textDocument/codeAction` request. They are provided so that the server knows which
    /// errors are currently presented to the user for the given range. There is no guarantee
    /// that these accurately reflect the error state of the resource. The primary parameter
    /// to compute code actions is the provided range.
    member _.Diagnostics =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``diagnostics``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("diagnostics")
            LspJsonBacking.Element prop

    /// Requested kind of actions to return.
    ///
    /// Actions not of this kind are filtered out by the client before being shown. So servers
    /// can omit computing them.
    member _.Only =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``only`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("only") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The reason why code actions were requested.
    ///
    /// @since 3.17.0
    member _.TriggerKind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``triggerKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("triggerKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeActionTriggerKind.FromElement(prop))

    static member Create
        (
            ``diagnostics``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``only``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``triggerKind``: CodeActionTriggerKind
        ) =
        CodeActionContext(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``diagnostics`` = ``diagnostics``
                    ``only`` = ``only``
                    ``triggerKind`` = ``triggerKind``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``diagnostics``
                    writer.WritePropertyName("diagnostics")
                    value.WriteTo(writer)

                    match backingObj.``only`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("only")
                        value.WriteTo(writer)

                    match backingObj.``triggerKind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("triggerKind", int value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionContext.FromElement(element))

/// Provider options for a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``resolveProvider``: global.FSharp.Core.bool option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// CodeActionKinds that this server may return.
    ///
    /// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
    /// may list out every specific kind they provide.
    member _.CodeActionKinds =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeActionKinds`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionKinds") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The server provides support to resolve additional
    /// information for a code action.
    ///
    /// @since 3.16.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``codeActionKinds``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveProvider``: global.FSharp.Core.bool,
            ?``workDoneProgress``: global.FSharp.Core.bool
        ) =
        CodeActionOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``codeActionKinds`` = ``codeActionKinds``
                    ``resolveProvider`` = ``resolveProvider``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``codeActionKinds`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeActionKinds")
                        value.WriteTo(writer)

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionOptions.FromElement(element))

/// Server capabilities for a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resolveProvider``: global.FSharp.Core.bool option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server provides support to resolve additional
    /// information for a workspace symbol.
    ///
    /// @since 3.17.0
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        WorkspaceSymbolOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resolveProvider`` = ``resolveProvider``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(WorkspaceSymbolOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Code Lens provider options of a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resolveProvider``: global.FSharp.Core.bool option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Code lens has a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        CodeLensOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resolveProvider`` = ``resolveProvider``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CodeLensOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provider options for a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``resolveProvider``: global.FSharp.Core.bool option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Document links have a resolve provider as well.
    member _.ResolveProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``resolveProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        DocumentLinkOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``resolveProvider`` = ``resolveProvider``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``resolveProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("resolveProvider", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "resolveProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentLinkOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Value-object describing what options formatting should use.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FormattingOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``tabSize``: global.FSharp.Core.int
                ``insertSpaces``: global.FSharp.Core.bool
                ``trimTrailingWhitespace``: global.FSharp.Core.bool option
                ``insertFinalNewline``: global.FSharp.Core.bool option
                ``trimFinalNewlines``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Size of a tab in spaces.
    member _.TabSize =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``tabSize``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tabSize")
            prop.GetInt32()

    /// Prefer spaces over tabs.
    member _.InsertSpaces =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``insertSpaces``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("insertSpaces")
            prop.GetBoolean()

    /// Trim trailing whitespace on a line.
    ///
    /// @since 3.15.0
    member _.TrimTrailingWhitespace =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``trimTrailingWhitespace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trimTrailingWhitespace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Insert a newline character at the end of the file if one does not exist.
    ///
    /// @since 3.15.0
    member _.InsertFinalNewline =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``insertFinalNewline`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertFinalNewline") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Trim all newlines after the final newline at the end of the file.
    ///
    /// @since 3.15.0
    member _.TrimFinalNewlines =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``trimFinalNewlines`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("trimFinalNewlines") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``tabSize``: global.FSharp.Core.int,
            ``insertSpaces``: global.FSharp.Core.bool,
            ?``trimTrailingWhitespace``: global.FSharp.Core.bool,
            ?``insertFinalNewline``: global.FSharp.Core.bool,
            ?``trimFinalNewlines``: global.FSharp.Core.bool
        ) =
        FormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``tabSize`` = ``tabSize``
                    ``insertSpaces`` = ``insertSpaces``
                    ``trimTrailingWhitespace`` = ``trimTrailingWhitespace``
                    ``insertFinalNewline`` = ``insertFinalNewline``
                    ``trimFinalNewlines`` = ``trimFinalNewlines``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``tabSize``
                    writer.WriteNumber("tabSize", value)
                    let value = backingObj.``insertSpaces``
                    writer.WriteBoolean("insertSpaces", value)

                    match backingObj.``trimTrailingWhitespace`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("trimTrailingWhitespace", value)

                    match backingObj.``insertFinalNewline`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("insertFinalNewline", value)

                    match backingObj.``trimFinalNewlines`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("trimFinalNewlines", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "tabSize" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "insertSpaces" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "trimTrailingWhitespace" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "insertFinalNewline" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "trimFinalNewlines" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FormattingOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provider options for a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentFormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentFormattingOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provider options for a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``rangesSupport``: global.FSharp.Core.bool option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the server supports formatting multiple ranges at once.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RangesSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rangesSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangesSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``rangesSupport``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool) =
        DocumentRangeFormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``rangesSupport`` = ``rangesSupport``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``rangesSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("rangesSupport", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "rangesSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentRangeFormattingOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Provider options for a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString
                ``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A character on which formatting should be triggered, like `{`.
    member _.FirstTriggerCharacter =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``firstTriggerCharacter``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("firstTriggerCharacter")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// More trigger characters.
    member _.MoreTriggerCharacter =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``moreTriggerCharacter`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("moreTriggerCharacter") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``firstTriggerCharacter``: global.Amongonz.LspTypes.LspString,
            ?``moreTriggerCharacter``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        DocumentOnTypeFormattingOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``firstTriggerCharacter`` = ``firstTriggerCharacter``
                    ``moreTriggerCharacter`` = ``moreTriggerCharacter``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``firstTriggerCharacter``
                    writer.WritePropertyName("firstTriggerCharacter")
                    value.WriteTo(writer)

                    match backingObj.``moreTriggerCharacter`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("moreTriggerCharacter")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentOnTypeFormattingOptions.FromElement(element))

/// Provider options for a {@link RenameRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``prepareProvider``: global.FSharp.Core.bool option
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Renames should be checked and tested before being executed.
    ///
    /// @since version 3.12.0
    member _.PrepareProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``prepareProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``prepareProvider``: global.FSharp.Core.bool, ?``workDoneProgress``: global.FSharp.Core.bool)
        =
        RenameOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``prepareProvider`` = ``prepareProvider``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``prepareProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("prepareProvider", value)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "prepareProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(RenameOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The server capabilities of a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``commands``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``workDoneProgress``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The commands to be executed on the server
    member _.Commands =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``commands``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("commands")
            LspJsonBacking.Element prop

    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (``commands``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``workDoneProgress``: global.FSharp.Core.bool) =
        ExecuteCommandOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``commands`` = ``commands``
                    ``workDoneProgress`` = ``workDoneProgress``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``commands``
                    writer.WritePropertyName("commands")
                    value.WriteTo(writer)

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ExecuteCommandOptions.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensLegend
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensLegend(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The token types a server uses.
    member _.TokenTypes =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``tokenTypes``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenTypes")
            LspJsonBacking.Element prop

    /// The token modifiers a server uses.
    member _.TokenModifiers =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``tokenModifiers``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenModifiers")
            LspJsonBacking.Element prop

    static member Create
        (
            ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        SemanticTokensLegend(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``tokenTypes`` = ``tokenTypes``
                    ``tokenModifiers`` = ``tokenModifiers``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``tokenTypes``
                    writer.WritePropertyName("tokenTypes")
                    value.WriteTo(writer)
                    let value = backingObj.``tokenModifiers``
                    writer.WritePropertyName("tokenModifiers")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensLegend.FromElement(element))

/// A text document identifier to optionally denote a specific version of a text document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type OptionalVersionedTextDocumentIdentifier
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``version``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        OptionalVersionedTextDocumentIdentifier(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The version number of this document. If a versioned text document identifier
    /// is sent from the server to the client and the file is not open in the editor
    /// (the server has not received an open notification before) the server can send
    /// `null` to indicate that the version is unknown and the content on disk is the
    /// truth (as specified with document content ownership).
    member _.Version =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            LspJsonBacking.Element prop

    /// The text document&apos;s uri.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    static member Create
        (``version``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ``uri``: global.Amongonz.LspTypes.LspDocumentUri) =
        OptionalVersionedTextDocumentIdentifier(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``version`` = ``version``
                    ``uri`` = ``uri``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``version``
                    writer.WritePropertyName("version")
                    value.WriteTo(writer)
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(OptionalVersionedTextDocumentIdentifier.FromElement(element))

/// A special text edit with an additional change annotation.
///
/// @since 3.16.0.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type AnnotatedTextEdit
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``annotationId``: ChangeAnnotationIdentifier
                ``range``: Range
                ``newText``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        AnnotatedTextEdit(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The actual identifier of the change annotation
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``annotationId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("annotationId")
            (global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier)

    /// The range of the text document to be manipulated. To insert
    /// text into a document create a range where start === end.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The string to be inserted. For delete operations use an
    /// empty string.
    member _.NewText =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``newText``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("newText")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (``annotationId``: ChangeAnnotationIdentifier, ``range``: Range, ``newText``: global.Amongonz.LspTypes.LspString) =
        AnnotatedTextEdit(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``annotationId`` = ``annotationId``
                    ``range`` = ``range``
                    ``newText`` = ``newText``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``annotationId``
                    writer.WritePropertyName("annotationId")
                    value.WriteTo(writer)
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``newText``
                    writer.WritePropertyName("newText")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "annotationId" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "newText" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(AnnotatedTextEdit.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A generic resource operation.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ResourceOperation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: global.Amongonz.LspTypes.LspString
                ``annotationId``: ChangeAnnotationIdentifier option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ResourceOperation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The resource operation kind.
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// An optional annotation identifier describing the operation.
    ///
    /// @since 3.16.0
    member _.AnnotationId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``annotationId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("annotationId") with
            | false, _ -> ValueNone
            | true, prop ->
                ValueSome((global.Amongonz.LspTypes.LspString.FromElement(prop): ChangeAnnotationIdentifier))

    static member Create(``kind``: global.Amongonz.LspTypes.LspString, ?``annotationId``: ChangeAnnotationIdentifier) =
        ResourceOperation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``annotationId`` = ``annotationId``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)

                    match backingObj.``annotationId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("annotationId")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "annotationId" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(ResourceOperation.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Options to create a file.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CreateFileOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``overwrite``: global.FSharp.Core.bool option
                ``ignoreIfExists``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CreateFileOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Overwrite existing file. Overwrite wins over `ignoreIfExists`
    member _.Overwrite =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``overwrite`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("overwrite") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Ignore if exists.
    member _.IgnoreIfExists =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``ignoreIfExists`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreIfExists") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``overwrite``: global.FSharp.Core.bool, ?``ignoreIfExists``: global.FSharp.Core.bool) =
        CreateFileOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``overwrite`` = ``overwrite``
                    ``ignoreIfExists`` = ``ignoreIfExists``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``overwrite`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("overwrite", value)

                    match backingObj.``ignoreIfExists`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("ignoreIfExists", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "overwrite" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreIfExists" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CreateFileOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Rename file options
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameFileOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``overwrite``: global.FSharp.Core.bool option
                ``ignoreIfExists``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameFileOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
    member _.Overwrite =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``overwrite`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("overwrite") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Ignores if target exists.
    member _.IgnoreIfExists =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``ignoreIfExists`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreIfExists") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``overwrite``: global.FSharp.Core.bool, ?``ignoreIfExists``: global.FSharp.Core.bool) =
        RenameFileOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``overwrite`` = ``overwrite``
                    ``ignoreIfExists`` = ``ignoreIfExists``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``overwrite`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("overwrite", value)

                    match backingObj.``ignoreIfExists`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("ignoreIfExists", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "overwrite" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreIfExists" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(RenameFileOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Delete file options
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeleteFileOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``recursive``: global.FSharp.Core.bool option
                ``ignoreIfNotExists``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeleteFileOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Delete the content recursively if a folder is denoted.
    member _.Recursive =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``recursive`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("recursive") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Ignore the operation if the file doesn&apos;t exist.
    member _.IgnoreIfNotExists =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``ignoreIfNotExists`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreIfNotExists") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``recursive``: global.FSharp.Core.bool, ?``ignoreIfNotExists``: global.FSharp.Core.bool) =
        DeleteFileOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``recursive`` = ``recursive``
                    ``ignoreIfNotExists`` = ``ignoreIfNotExists``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``recursive`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("recursive", value)

                    match backingObj.``ignoreIfNotExists`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("ignoreIfNotExists", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "recursive" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreIfNotExists" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DeleteFileOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A pattern to describe in which file operation requests or notifications
/// the server is interested in receiving.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationPattern
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``glob``: global.Amongonz.LspTypes.LspString
                ``matches``: FileOperationPatternKind option
                ``options``: FileOperationPatternOptions option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationPattern(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The glob pattern to match. Glob patterns can have the following syntax:
    /// - `*` to match one or more characters in a path segment
    /// - `?` to match on one character in a path segment
    /// - `**` to match any number of path segments, including none
    /// - `{}` to group sub patterns into an OR expression. (e.g. `**/*.{ts,js}` matches all TypeScript and JavaScript files)
    /// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
    /// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
    member _.Glob =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``glob``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("glob")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// Whether to match files or folders with this pattern.
    ///
    /// Matches both if undefined.
    member _.Matches =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``matches`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("matches") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationPatternKind.FromElement(prop))

    /// Additional options used during matching.
    member _.Options =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``options`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("options") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationPatternOptions.FromElement(prop))

    static member Create
        (
            ``glob``: global.Amongonz.LspTypes.LspString,
            ?``matches``: FileOperationPatternKind,
            ?``options``: FileOperationPatternOptions
        ) =
        FileOperationPattern(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``glob`` = ``glob``
                    ``matches`` = ``matches``
                    ``options`` = ``options``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``glob``
                    writer.WritePropertyName("glob")
                    value.WriteTo(writer)

                    match backingObj.``matches`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("matches")
                        value.WriteTo(writer)

                    match backingObj.``options`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("options")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "glob" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "matches" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationPatternKind.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "options" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationPatternOptions.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileOperationPattern.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A full document diagnostic report for a workspace diagnostic result.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFullDocumentDiagnosticReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``version``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resultId``: global.Amongonz.LspTypes.LspString option
                ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFullDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which diagnostic information is reported.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The version number for which the diagnostics are reported.
    /// If the document is not marked as open `null` can be provided.
    member _.Version =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            LspJsonBacking.Element prop

    /// A full document diagnostic report.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// An optional result id. If provided it will
    /// be sent on the next diagnostic request for the
    /// same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resultId`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resultId") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// The actual items.
    member _.Items =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``items``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("items")
            LspJsonBacking.Element prop

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``version``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``items``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        WorkspaceFullDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``version`` = ``version``
                    ``kind`` = ``kind``
                    ``resultId`` = ``resultId``
                    ``items`` = ``items``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``version``
                    writer.WritePropertyName("version")
                    value.WriteTo(writer)
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)

                    match backingObj.``resultId`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resultId")
                        value.WriteTo(writer)

                    let value = backingObj.``items``
                    writer.WritePropertyName("items")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFullDocumentDiagnosticReport.FromElement(element))

/// An unchanged document diagnostic report for a workspace diagnostic result.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceUnchangedDocumentDiagnosticReport
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``uri``: global.Amongonz.LspTypes.LspDocumentUri
                ``version``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``resultId``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceUnchangedDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The URI for which diagnostic information is reported.
    member _.Uri =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``uri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("uri")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// The version number for which the diagnostics are reported.
    /// If the document is not marked as open `null` can be provided.
    member _.Version =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``version``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("version")
            LspJsonBacking.Element prop

    /// A document diagnostic report indicating
    /// no changes to the last result. A server can
    /// only return `unchanged` if result ids are
    /// provided.
    member _.Kind =
        // Complex type kind: stringLiteral.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            LspJsonBacking.Element prop

    /// A result id which will be sent on the next
    /// diagnostic request for the same document.
    member _.ResultId =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``resultId``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("resultId")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create
        (
            ``uri``: global.Amongonz.LspTypes.LspDocumentUri,
            ``version``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``kind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``resultId``: global.Amongonz.LspTypes.LspString
        ) =
        WorkspaceUnchangedDocumentDiagnosticReport(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``uri`` = ``uri``
                    ``version`` = ``version``
                    ``kind`` = ``kind``
                    ``resultId`` = ``resultId``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``uri``
                    writer.WriteString("uri", value.OriginalString)
                    let value = backingObj.``version``
                    writer.WritePropertyName("version")
                    value.WriteTo(writer)
                    let value = backingObj.``kind``
                    writer.WritePropertyName("kind")
                    value.WriteTo(writer)
                    let value = backingObj.``resultId``
                    writer.WritePropertyName("resultId")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceUnchangedDocumentDiagnosticReport.FromElement(element))

/// A notebook cell.
///
/// A cell&apos;s document URI must be unique across ALL notebook
/// cells and can therefore be used to uniquely identify a
/// notebook cell or the cell&apos;s text document.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookCell
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``kind``: NotebookCellKind
                ``document``: global.Amongonz.LspTypes.LspDocumentUri
                ``metadata``: LSPObject option
                ``executionSummary``: ExecutionSummary option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookCell(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The cell&apos;s kind
    member _.Kind =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``kind``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("kind")
            NotebookCellKind.FromElement(prop)

    /// The URI of the cell&apos;s text document
    /// content.
    member _.Document =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``document``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("document")
            global.Amongonz.LspTypes.LspDocumentUri(prop.GetString())

    /// Additional metadata stored with the cell.
    ///
    /// Note: should always be an object literal (e.g. LSPObject)
    member _.Metadata =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``metadata`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("metadata") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPObject.FromElement(prop))

    /// Additional execution summary information
    /// if supported by the client.
    member _.ExecutionSummary =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``executionSummary`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executionSummary") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ExecutionSummary.FromElement(prop))

    static member Create
        (
            ``kind``: NotebookCellKind,
            ``document``: global.Amongonz.LspTypes.LspDocumentUri,
            ?``metadata``: LSPObject,
            ?``executionSummary``: ExecutionSummary
        ) =
        NotebookCell(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``kind`` = ``kind``
                    ``document`` = ``document``
                    ``metadata`` = ``metadata``
                    ``executionSummary`` = ``executionSummary``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``kind``
                    writer.WriteNumber("kind", int value)
                    let value = backingObj.``document``
                    writer.WriteString("document", value.OriginalString)

                    match backingObj.``metadata`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("metadata")
                        value.WriteTo(writer)

                    match backingObj.``executionSummary`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("executionSummary")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "kind" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "document" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "metadata" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPObject.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "executionSummary" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ExecutionSummary.Parse(prop)))
        then
            global.FSharp.Core.Ok(NotebookCell.FromElement(element))
        else
            global.FSharp.Core.Error()

/// A change describing how to move a `NotebookCell`
/// array from state S to S&apos;.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookCellArrayChange
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``start``: global.FSharp.Core.int
                ``deleteCount``: global.FSharp.Core.int
                ``cells``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookCellArrayChange(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The start oftest of the cell that changed.
    member _.Start =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``start``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("start")
            prop.GetInt32()

    /// The deleted cells
    member _.DeleteCount =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``deleteCount``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("deleteCount")
            prop.GetInt32()

    /// The new cells, if any
    member _.Cells =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``cells`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("cells") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``start``: global.FSharp.Core.int,
            ``deleteCount``: global.FSharp.Core.int,
            ?``cells``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        NotebookCellArrayChange(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``start`` = ``start``
                    ``deleteCount`` = ``deleteCount``
                    ``cells`` = ``cells``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``start``
                    writer.WriteNumber("start", value)
                    let value = backingObj.``deleteCount``
                    writer.WriteNumber("deleteCount", value)

                    match backingObj.``cells`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("cells")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookCellArrayChange.FromElement(element))

/// Describes the currently selected completion item.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectedCompletionInfo
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``range``: Range
                ``text``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectedCompletionInfo(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The range that will be replaced if this completion item is accepted.
    member _.Range =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``range``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("range")
            Range.FromElement(prop)

    /// The text the range will be replaced with if this completion is accepted.
    member _.Text =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``text``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("text")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``range``: Range, ``text``: global.Amongonz.LspTypes.LspString) =
        SelectedCompletionInfo(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``range`` = ``range``
                    ``text`` = ``text``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``range``
                    writer.WritePropertyName("range")
                    value.WriteTo(writer)
                    let value = backingObj.``text``
                    writer.WritePropertyName("text")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "range" element
               |> global.FSharp.Core.ValueOption.exists (fun prop -> global.FSharp.Core.Result.isOk (Range.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "text" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(SelectedCompletionInfo.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Defines the capabilities provided by the client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workspace``: WorkspaceClientCapabilities option
                ``textDocument``: TextDocumentClientCapabilities option
                ``notebookDocument``: NotebookDocumentClientCapabilities option
                ``window``: WindowClientCapabilities option
                ``general``: GeneralClientCapabilities option
                ``experimental``: LSPAny option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Workspace specific client capabilities.
    member _.Workspace =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workspace`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspace") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceClientCapabilities.FromElement(prop))

    /// Text document specific client capabilities.
    member _.TextDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``textDocument`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("textDocument") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextDocumentClientCapabilities.FromElement(prop))

    /// Capabilities specific to the notebook document support.
    ///
    /// @since 3.17.0
    member _.NotebookDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``notebookDocument`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("notebookDocument") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(NotebookDocumentClientCapabilities.FromElement(prop))

    /// Window specific client capabilities.
    member _.Window =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``window`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("window") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WindowClientCapabilities.FromElement(prop))

    /// General client capabilities.
    ///
    /// @since 3.16.0
    member _.General =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``general`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("general") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(GeneralClientCapabilities.FromElement(prop))

    /// Experimental client capabilities.
    member _.Experimental =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``experimental`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("experimental") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LSPAny.FromElement(prop))

    static member Create
        (
            ?``workspace``: WorkspaceClientCapabilities,
            ?``textDocument``: TextDocumentClientCapabilities,
            ?``notebookDocument``: NotebookDocumentClientCapabilities,
            ?``window``: WindowClientCapabilities,
            ?``general``: GeneralClientCapabilities,
            ?``experimental``: LSPAny
        ) =
        ClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workspace`` = ``workspace``
                    ``textDocument`` = ``textDocument``
                    ``notebookDocument`` = ``notebookDocument``
                    ``window`` = ``window``
                    ``general`` = ``general``
                    ``experimental`` = ``experimental``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workspace`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workspace")
                        value.WriteTo(writer)

                    match backingObj.``textDocument`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("textDocument")
                        value.WriteTo(writer)

                    match backingObj.``notebookDocument`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("notebookDocument")
                        value.WriteTo(writer)

                    match backingObj.``window`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("window")
                        value.WriteTo(writer)

                    match backingObj.``general`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("general")
                        value.WriteTo(writer)

                    match backingObj.``experimental`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("experimental")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspace" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "textDocument" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "notebookDocument" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "window" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WindowClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "general" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (GeneralClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "experimental" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LSPAny.Parse(prop)))
        then
            global.FSharp.Core.Ok(ClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentSyncOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``openClose``: global.FSharp.Core.bool option
                ``change``: TextDocumentSyncKind option
                ``willSave``: global.FSharp.Core.bool option
                ``willSaveWaitUntil``: global.FSharp.Core.bool option
                ``save``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentSyncOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Open and close notifications are sent to the server. If omitted open close notification should not
    /// be sent.
    member _.OpenClose =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``openClose`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("openClose") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
    /// and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
    member _.Change =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``change`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("change") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextDocumentSyncKind.FromElement(prop))

    /// If present will save notifications are sent to the server. If omitted the notification should not be
    /// sent.
    member _.WillSave =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willSave`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSave") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// If present will save wait until requests are sent to the server. If omitted the request should not be
    /// sent.
    member _.WillSaveWaitUntil =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willSaveWaitUntil`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSaveWaitUntil") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// If present save notifications are sent to the server. If omitted the notification should not be
    /// sent.
    member _.Save =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``save`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("save") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``openClose``: global.FSharp.Core.bool,
            ?``change``: TextDocumentSyncKind,
            ?``willSave``: global.FSharp.Core.bool,
            ?``willSaveWaitUntil``: global.FSharp.Core.bool,
            ?``save``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        TextDocumentSyncOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``openClose`` = ``openClose``
                    ``change`` = ``change``
                    ``willSave`` = ``willSave``
                    ``willSaveWaitUntil`` = ``willSaveWaitUntil``
                    ``save`` = ``save``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``openClose`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("openClose", value)

                    match backingObj.``change`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("change", int value)

                    match backingObj.``willSave`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("willSave", value)

                    match backingObj.``willSaveWaitUntil`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("willSaveWaitUntil", value)

                    match backingObj.``save`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("save")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(TextDocumentSyncOptions.FromElement(element))

/// Options specific to a notebook plus its cells
/// to be synced to the server.
///
/// If a selector provides a notebook document
/// filter but no cell selector all cells of a
/// matching notebook document will be synced.
///
/// If a selector provides no notebook document
/// filter but only a cell selector all notebook
/// document that contain at least one matching
/// cell will be synced.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentSyncOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``save``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentSyncOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebooks to be synced
    member _.NotebookSelector =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebookSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookSelector")
            LspJsonBacking.Element prop

    /// Whether save notification should be forwarded to
    /// the server. Will only be honored if mode === `notebook`.
    member _.Save =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``save`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("save") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``save``: global.FSharp.Core.bool) =
        NotebookDocumentSyncOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``notebookSelector`` = ``notebookSelector``
                    ``save`` = ``save``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``notebookSelector``
                    writer.WritePropertyName("notebookSelector")
                    value.WriteTo(writer)

                    match backingObj.``save`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("save", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocumentSyncOptions.FromElement(element))

/// Registration options specific to a notebook.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentSyncRegistrationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``save``: global.FSharp.Core.bool option
                ``id``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentSyncRegistrationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The notebooks to be synced
    member _.NotebookSelector =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebookSelector``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebookSelector")
            LspJsonBacking.Element prop

    /// Whether save notification should be forwarded to
    /// the server. Will only be honored if mode === `notebook`.
    member _.Save =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``save`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("save") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The id used to register the request. The id can be used to deregister
    /// the request again. See also Registration#id.
    member _.Id =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``id`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("id") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (
            ``notebookSelector``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``save``: global.FSharp.Core.bool,
            ?``id``: global.Amongonz.LspTypes.LspString
        ) =
        NotebookDocumentSyncRegistrationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``notebookSelector`` = ``notebookSelector``
                    ``save`` = ``save``
                    ``id`` = ``id``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``notebookSelector``
                    writer.WritePropertyName("notebookSelector")
                    value.WriteTo(writer)

                    match backingObj.``save`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("save", value)

                    match backingObj.``id`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("id")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookDocumentSyncRegistrationOptions.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceFoldersServerCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``supported``: global.FSharp.Core.bool option
                ``changeNotifications``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceFoldersServerCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server has support for workspace folders
    member _.Supported =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``supported`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("supported") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the server wants to receive workspace folder
    /// change notifications.
    ///
    /// If a string is provided the string is treated as an ID
    /// under which the notification is registered on the client
    /// side. The ID can be used to unregister for these events
    /// using the `client/unregisterCapability` request.
    member _.ChangeNotifications =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``changeNotifications`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changeNotifications") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (?``supported``: global.FSharp.Core.bool, ?``changeNotifications``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        WorkspaceFoldersServerCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``supported`` = ``supported``
                    ``changeNotifications`` = ``changeNotifications``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``supported`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("supported", value)

                    match backingObj.``changeNotifications`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("changeNotifications")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceFoldersServerCapabilities.FromElement(element))

/// Options for notifications/requests for user operations on files.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``didCreate``: FileOperationRegistrationOptions option
                ``willCreate``: FileOperationRegistrationOptions option
                ``didRename``: FileOperationRegistrationOptions option
                ``willRename``: FileOperationRegistrationOptions option
                ``didDelete``: FileOperationRegistrationOptions option
                ``willDelete``: FileOperationRegistrationOptions option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The server is interested in receiving didCreateFiles notifications.
    member _.DidCreate =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving willCreateFiles requests.
    member _.WillCreate =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving didRenameFiles notifications.
    member _.DidRename =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving willRenameFiles requests.
    member _.WillRename =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving didDeleteFiles file notifications.
    member _.DidDelete =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    /// The server is interested in receiving willDeleteFiles file requests.
    member _.WillDelete =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationRegistrationOptions.FromElement(prop))

    static member Create
        (
            ?``didCreate``: FileOperationRegistrationOptions,
            ?``willCreate``: FileOperationRegistrationOptions,
            ?``didRename``: FileOperationRegistrationOptions,
            ?``willRename``: FileOperationRegistrationOptions,
            ?``didDelete``: FileOperationRegistrationOptions,
            ?``willDelete``: FileOperationRegistrationOptions
        ) =
        FileOperationOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``didCreate`` = ``didCreate``
                    ``willCreate`` = ``willCreate``
                    ``didRename`` = ``didRename``
                    ``willRename`` = ``willRename``
                    ``didDelete`` = ``didDelete``
                    ``willDelete`` = ``willDelete``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``didCreate`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("didCreate")
                        value.WriteTo(writer)

                    match backingObj.``willCreate`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("willCreate")
                        value.WriteTo(writer)

                    match backingObj.``didRename`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("didRename")
                        value.WriteTo(writer)

                    match backingObj.``willRename`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("willRename")
                        value.WriteTo(writer)

                    match backingObj.``didDelete`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("didDelete")
                        value.WriteTo(writer)

                    match backingObj.``willDelete`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("willDelete")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "didCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "willCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "willRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "willDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationRegistrationOptions.Parse(prop)))
        then
            global.FSharp.Core.Ok(FileOperationOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Structure to capture a description for an error code.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeDescription private (backing: global.Amongonz.LspTypes.LspJsonBacking<{| ``href``: global.System.Uri |}>) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeDescription(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// An URI to open with more information about the diagnostic error.
    member _.Href =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``href``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("href")
            global.System.Uri(prop.GetString())

    static member Create(``href``: global.System.Uri) =
        CodeDescription(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``href`` = ``href`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``href``
                    writer.WriteString("href", value.OriginalString)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "href" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidUri prop)
        then
            global.FSharp.Core.Ok(CodeDescription.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a related message and source code location for a diagnostic. This should be
/// used to point to code locations that cause or related to a diagnostics, e.g when duplicating
/// a symbol in a scope.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticRelatedInformation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``location``: Location
                ``message``: global.Amongonz.LspTypes.LspString
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticRelatedInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The location of this related diagnostic information.
    member _.Location =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``location``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("location")
            Location.FromElement(prop)

    /// The message of this related diagnostic information.
    member _.Message =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``message``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("message")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    static member Create(``location``: Location, ``message``: global.Amongonz.LspTypes.LspString) =
        DiagnosticRelatedInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``location`` = ``location``
                    ``message`` = ``message``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``location``
                    writer.WritePropertyName("location")
                    value.WriteTo(writer)
                    let value = backingObj.``message``
                    writer.WritePropertyName("message")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "location" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (Location.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "message" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(DiagnosticRelatedInformation.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Represents a parameter of a callable-signature. A parameter can
/// have a label and a doc-comment.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ParameterInformation
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``label``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``documentation``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ParameterInformation(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The label of this parameter information.
    ///
    /// Either a string or an inclusive start and exclusive end offsets within its containing
    /// signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
    /// string representation as `Position` and `Range` does.
    ///
    /// *Note*: a label of type string should be a substring of its containing signature label.
    /// Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
    member _.Label =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``label``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("label")
            LspJsonBacking.Element prop

    /// The human-readable doc-comment of this parameter. Will be shown
    /// in the UI but can be omitted.
    member _.Documentation =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``label``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``documentation``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        ParameterInformation(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``label`` = ``label``
                    ``documentation`` = ``documentation``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``label``
                    writer.WritePropertyName("label")
                    value.WriteTo(writer)

                    match backingObj.``documentation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentation")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ParameterInformation.FromElement(element))

/// A notebook cell text document filter denotes a cell text
/// document by different properties.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookCellTextDocumentFilter
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``notebook``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``language``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookCellTextDocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A filter that matches against the notebook
    /// containing the notebook cell. If a string
    /// value is provided it matches against the
    /// notebook type. &apos;*&apos; matches every notebook.
    member _.Notebook =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``notebook``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("notebook")
            LspJsonBacking.Element prop

    /// A language id like `python`.
    ///
    /// Will be matched against the language id of the
    /// notebook cell document. &apos;*&apos; matches every language.
    member _.Language =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``language`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("language") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``notebook``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ?``language``: global.Amongonz.LspTypes.LspString) =
        NotebookCellTextDocumentFilter(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``notebook`` = ``notebook``
                    ``language`` = ``language``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``notebook``
                    writer.WritePropertyName("notebook")
                    value.WriteTo(writer)

                    match backingObj.``language`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("language")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(NotebookCellTextDocumentFilter.FromElement(element))

/// Matching options for the file operation pattern.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationPatternOptions
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``ignoreCase``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationPatternOptions(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The pattern should be matched ignoring casing.
    member _.IgnoreCase =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``ignoreCase`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("ignoreCase") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``ignoreCase``: global.FSharp.Core.bool) =
        FileOperationPatternOptions(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``ignoreCase`` = ``ignoreCase`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``ignoreCase`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("ignoreCase", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "ignoreCase" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FileOperationPatternOptions.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecutionSummary
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``executionOrder``: global.FSharp.Core.int
                ``success``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecutionSummary(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A strict monotonically increasing value
    /// indicating the execution order of a cell
    /// inside a notebook.
    member _.ExecutionOrder =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``executionOrder``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("executionOrder")
            prop.GetInt32()

    /// Whether the execution was successful or
    /// not if known by the client.
    member _.Success =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``success`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("success") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(``executionOrder``: global.FSharp.Core.int, ?``success``: global.FSharp.Core.bool) =
        ExecutionSummary(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``executionOrder`` = ``executionOrder``
                    ``success`` = ``success``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``executionOrder``
                    writer.WriteNumber("executionOrder", value)

                    match backingObj.``success`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("success", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "executionOrder" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidInteger prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "success" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ExecutionSummary.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Workspace specific client capabilities.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``applyEdit``: global.FSharp.Core.bool option
                ``workspaceEdit``: WorkspaceEditClientCapabilities option
                ``didChangeConfiguration``: DidChangeConfigurationClientCapabilities option
                ``didChangeWatchedFiles``: DidChangeWatchedFilesClientCapabilities option
                ``symbol``: WorkspaceSymbolClientCapabilities option
                ``executeCommand``: ExecuteCommandClientCapabilities option
                ``workspaceFolders``: global.FSharp.Core.bool option
                ``configuration``: global.FSharp.Core.bool option
                ``semanticTokens``: SemanticTokensWorkspaceClientCapabilities option
                ``codeLens``: CodeLensWorkspaceClientCapabilities option
                ``fileOperations``: FileOperationClientCapabilities option
                ``inlineValue``: InlineValueWorkspaceClientCapabilities option
                ``inlayHint``: InlayHintWorkspaceClientCapabilities option
                ``diagnostics``: DiagnosticWorkspaceClientCapabilities option
                ``foldingRange``: FoldingRangeWorkspaceClientCapabilities option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client supports applying batch edits
    /// to the workspace by supporting the request
    /// &apos;workspace/applyEdit&apos;
    member _.ApplyEdit =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``applyEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("applyEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Capabilities specific to `WorkspaceEdit`s.
    member _.WorkspaceEdit =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workspaceEdit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceEdit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceEditClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/didChangeConfiguration` notification.
    member _.DidChangeConfiguration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didChangeConfiguration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didChangeConfiguration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DidChangeConfigurationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
    member _.DidChangeWatchedFiles =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didChangeWatchedFiles`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didChangeWatchedFiles") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DidChangeWatchedFilesClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/symbol` request.
    member _.Symbol =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``symbol`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("symbol") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(WorkspaceSymbolClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `workspace/executeCommand` request.
    member _.ExecuteCommand =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``executeCommand`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executeCommand") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ExecuteCommandClientCapabilities.FromElement(prop))

    /// The client has support for workspace folders.
    ///
    /// @since 3.6.0
    member _.WorkspaceFolders =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workspaceFolders`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workspaceFolders") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports `workspace/configuration` requests.
    ///
    /// @since 3.6.0
    member _.Configuration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``configuration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("configuration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Capabilities specific to the semantic token requests scoped to the
    /// workspace.
    ///
    /// @since 3.16.0.
    member _.SemanticTokens =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``semanticTokens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("semanticTokens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SemanticTokensWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the code lens requests scoped to the
    /// workspace.
    ///
    /// @since 3.16.0.
    member _.CodeLens =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeLens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeLens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeLensWorkspaceClientCapabilities.FromElement(prop))

    /// The client has support for file notifications/requests for user operations on files.
    ///
    /// Since 3.16.0
    member _.FileOperations =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``fileOperations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("fileOperations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FileOperationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the inline values requests scoped to the
    /// workspace.
    ///
    /// @since 3.17.0.
    member _.InlineValue =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlineValue`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineValue") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlineValueWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the inlay hint requests scoped to the
    /// workspace.
    ///
    /// @since 3.17.0.
    member _.InlayHint =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlayHint`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlayHint") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlayHintWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the diagnostic requests scoped to the
    /// workspace.
    ///
    /// @since 3.17.0.
    member _.Diagnostics =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``diagnostics`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnostics") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DiagnosticWorkspaceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the folding range requests scoped to the workspace.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.FoldingRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``foldingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FoldingRangeWorkspaceClientCapabilities.FromElement(prop))

    static member Create
        (
            ?``applyEdit``: global.FSharp.Core.bool,
            ?``workspaceEdit``: WorkspaceEditClientCapabilities,
            ?``didChangeConfiguration``: DidChangeConfigurationClientCapabilities,
            ?``didChangeWatchedFiles``: DidChangeWatchedFilesClientCapabilities,
            ?``symbol``: WorkspaceSymbolClientCapabilities,
            ?``executeCommand``: ExecuteCommandClientCapabilities,
            ?``workspaceFolders``: global.FSharp.Core.bool,
            ?``configuration``: global.FSharp.Core.bool,
            ?``semanticTokens``: SemanticTokensWorkspaceClientCapabilities,
            ?``codeLens``: CodeLensWorkspaceClientCapabilities,
            ?``fileOperations``: FileOperationClientCapabilities,
            ?``inlineValue``: InlineValueWorkspaceClientCapabilities,
            ?``inlayHint``: InlayHintWorkspaceClientCapabilities,
            ?``diagnostics``: DiagnosticWorkspaceClientCapabilities,
            ?``foldingRange``: FoldingRangeWorkspaceClientCapabilities
        ) =
        WorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``applyEdit`` = ``applyEdit``
                    ``workspaceEdit`` = ``workspaceEdit``
                    ``didChangeConfiguration`` = ``didChangeConfiguration``
                    ``didChangeWatchedFiles`` = ``didChangeWatchedFiles``
                    ``symbol`` = ``symbol``
                    ``executeCommand`` = ``executeCommand``
                    ``workspaceFolders`` = ``workspaceFolders``
                    ``configuration`` = ``configuration``
                    ``semanticTokens`` = ``semanticTokens``
                    ``codeLens`` = ``codeLens``
                    ``fileOperations`` = ``fileOperations``
                    ``inlineValue`` = ``inlineValue``
                    ``inlayHint`` = ``inlayHint``
                    ``diagnostics`` = ``diagnostics``
                    ``foldingRange`` = ``foldingRange``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``applyEdit`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("applyEdit", value)

                    match backingObj.``workspaceEdit`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("workspaceEdit")
                        value.WriteTo(writer)

                    match backingObj.``didChangeConfiguration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("didChangeConfiguration")
                        value.WriteTo(writer)

                    match backingObj.``didChangeWatchedFiles`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("didChangeWatchedFiles")
                        value.WriteTo(writer)

                    match backingObj.``symbol`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("symbol")
                        value.WriteTo(writer)

                    match backingObj.``executeCommand`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("executeCommand")
                        value.WriteTo(writer)

                    match backingObj.``workspaceFolders`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workspaceFolders", value)

                    match backingObj.``configuration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("configuration", value)

                    match backingObj.``semanticTokens`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("semanticTokens")
                        value.WriteTo(writer)

                    match backingObj.``codeLens`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeLens")
                        value.WriteTo(writer)

                    match backingObj.``fileOperations`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("fileOperations")
                        value.WriteTo(writer)

                    match backingObj.``inlineValue`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlineValue")
                        value.WriteTo(writer)

                    match backingObj.``inlayHint`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlayHint")
                        value.WriteTo(writer)

                    match backingObj.``diagnostics`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("diagnostics")
                        value.WriteTo(writer)

                    match backingObj.``foldingRange`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("foldingRange")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "applyEdit" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspaceEdit" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceEditClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didChangeConfiguration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DidChangeConfigurationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "didChangeWatchedFiles" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DidChangeWatchedFilesClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "symbol" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (WorkspaceSymbolClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "executeCommand" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ExecuteCommandClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "workspaceFolders" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "configuration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "semanticTokens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SemanticTokensWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "codeLens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeLensWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "fileOperations" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FileOperationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlineValue" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineValueWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlayHint" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlayHintWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "diagnostics" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DiagnosticWorkspaceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "foldingRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FoldingRangeWorkspaceClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(WorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Text document specific client capabilities.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``synchronization``: TextDocumentSyncClientCapabilities option
                ``completion``: CompletionClientCapabilities option
                ``hover``: HoverClientCapabilities option
                ``signatureHelp``: SignatureHelpClientCapabilities option
                ``declaration``: DeclarationClientCapabilities option
                ``definition``: DefinitionClientCapabilities option
                ``typeDefinition``: TypeDefinitionClientCapabilities option
                ``implementation``: ImplementationClientCapabilities option
                ``references``: ReferenceClientCapabilities option
                ``documentHighlight``: DocumentHighlightClientCapabilities option
                ``documentSymbol``: DocumentSymbolClientCapabilities option
                ``codeAction``: CodeActionClientCapabilities option
                ``codeLens``: CodeLensClientCapabilities option
                ``documentLink``: DocumentLinkClientCapabilities option
                ``colorProvider``: DocumentColorClientCapabilities option
                ``formatting``: DocumentFormattingClientCapabilities option
                ``rangeFormatting``: DocumentRangeFormattingClientCapabilities option
                ``onTypeFormatting``: DocumentOnTypeFormattingClientCapabilities option
                ``rename``: RenameClientCapabilities option
                ``foldingRange``: FoldingRangeClientCapabilities option
                ``selectionRange``: SelectionRangeClientCapabilities option
                ``publishDiagnostics``: PublishDiagnosticsClientCapabilities option
                ``callHierarchy``: CallHierarchyClientCapabilities option
                ``semanticTokens``: SemanticTokensClientCapabilities option
                ``linkedEditingRange``: LinkedEditingRangeClientCapabilities option
                ``moniker``: MonikerClientCapabilities option
                ``typeHierarchy``: TypeHierarchyClientCapabilities option
                ``inlineValue``: InlineValueClientCapabilities option
                ``inlayHint``: InlayHintClientCapabilities option
                ``diagnostic``: DiagnosticClientCapabilities option
                ``inlineCompletion``: InlineCompletionClientCapabilities option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Defines which synchronization capabilities the client supports.
    member _.Synchronization =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``synchronization`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("synchronization") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TextDocumentSyncClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/completion` request.
    member _.Completion =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``completion`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completion") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CompletionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/hover` request.
    member _.Hover =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``hover`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("hover") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(HoverClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/signatureHelp` request.
    member _.SignatureHelp =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``signatureHelp`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("signatureHelp") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SignatureHelpClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/declaration` request.
    ///
    /// @since 3.14.0
    member _.Declaration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``declaration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("declaration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DeclarationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/definition` request.
    member _.Definition =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``definition`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("definition") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DefinitionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/typeDefinition` request.
    ///
    /// @since 3.6.0
    member _.TypeDefinition =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``typeDefinition`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeDefinition") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TypeDefinitionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/implementation` request.
    ///
    /// @since 3.6.0
    member _.Implementation =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``implementation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("implementation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ImplementationClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/references` request.
    member _.References =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``references`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("references") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ReferenceClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentHighlight` request.
    member _.DocumentHighlight =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentHighlight`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentHighlight") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentHighlightClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentSymbol` request.
    member _.DocumentSymbol =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentSymbol`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentSymbol") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentSymbolClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/codeAction` request.
    member _.CodeAction =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeAction`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeAction") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeActionClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/codeLens` request.
    member _.CodeLens =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeLens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeLens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CodeLensClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentLink` request.
    member _.DocumentLink =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentLink`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentLink") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentLinkClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/documentColor` and the
    /// `textDocument/colorPresentation` request.
    ///
    /// @since 3.6.0
    member _.ColorProvider =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``colorProvider`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("colorProvider") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentColorClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/formatting` request.
    member _.Formatting =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``formatting`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("formatting") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentFormattingClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/rangeFormatting` request.
    member _.RangeFormatting =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rangeFormatting`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangeFormatting") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentRangeFormattingClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/onTypeFormatting` request.
    member _.OnTypeFormatting =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``onTypeFormatting`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("onTypeFormatting") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DocumentOnTypeFormattingClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/rename` request.
    member _.Rename =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(RenameClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/foldingRange` request.
    ///
    /// @since 3.10.0
    member _.FoldingRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``foldingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FoldingRangeClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/selectionRange` request.
    ///
    /// @since 3.15.0
    member _.SelectionRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``selectionRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("selectionRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SelectionRangeClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/publishDiagnostics` notification.
    member _.PublishDiagnostics =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``publishDiagnostics`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("publishDiagnostics") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(PublishDiagnosticsClientCapabilities.FromElement(prop))

    /// Capabilities specific to the various call hierarchy requests.
    ///
    /// @since 3.16.0
    member _.CallHierarchy =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``callHierarchy`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("callHierarchy") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(CallHierarchyClientCapabilities.FromElement(prop))

    /// Capabilities specific to the various semantic token request.
    ///
    /// @since 3.16.0
    member _.SemanticTokens =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``semanticTokens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("semanticTokens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(SemanticTokensClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/linkedEditingRange` request.
    ///
    /// @since 3.16.0
    member _.LinkedEditingRange =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``linkedEditingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkedEditingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LinkedEditingRangeClientCapabilities.FromElement(prop))

    /// Client capabilities specific to the `textDocument/moniker` request.
    ///
    /// @since 3.16.0
    member _.Moniker =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``moniker`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("moniker") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(MonikerClientCapabilities.FromElement(prop))

    /// Capabilities specific to the various type hierarchy requests.
    ///
    /// @since 3.17.0
    member _.TypeHierarchy =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``typeHierarchy`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("typeHierarchy") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(TypeHierarchyClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/inlineValue` request.
    ///
    /// @since 3.17.0
    member _.InlineValue =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlineValue`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineValue") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlineValueClientCapabilities.FromElement(prop))

    /// Capabilities specific to the `textDocument/inlayHint` request.
    ///
    /// @since 3.17.0
    member _.InlayHint =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlayHint`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlayHint") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlayHintClientCapabilities.FromElement(prop))

    /// Capabilities specific to the diagnostic pull model.
    ///
    /// @since 3.17.0
    member _.Diagnostic =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``diagnostic`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("diagnostic") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(DiagnosticClientCapabilities.FromElement(prop))

    /// Client capabilities specific to inline completions.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.InlineCompletion =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``inlineCompletion`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("inlineCompletion") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InlineCompletionClientCapabilities.FromElement(prop))

    static member Create
        (
            ?``synchronization``: TextDocumentSyncClientCapabilities,
            ?``completion``: CompletionClientCapabilities,
            ?``hover``: HoverClientCapabilities,
            ?``signatureHelp``: SignatureHelpClientCapabilities,
            ?``declaration``: DeclarationClientCapabilities,
            ?``definition``: DefinitionClientCapabilities,
            ?``typeDefinition``: TypeDefinitionClientCapabilities,
            ?``implementation``: ImplementationClientCapabilities,
            ?``references``: ReferenceClientCapabilities,
            ?``documentHighlight``: DocumentHighlightClientCapabilities,
            ?``documentSymbol``: DocumentSymbolClientCapabilities,
            ?``codeAction``: CodeActionClientCapabilities,
            ?``codeLens``: CodeLensClientCapabilities,
            ?``documentLink``: DocumentLinkClientCapabilities,
            ?``colorProvider``: DocumentColorClientCapabilities,
            ?``formatting``: DocumentFormattingClientCapabilities,
            ?``rangeFormatting``: DocumentRangeFormattingClientCapabilities,
            ?``onTypeFormatting``: DocumentOnTypeFormattingClientCapabilities,
            ?``rename``: RenameClientCapabilities,
            ?``foldingRange``: FoldingRangeClientCapabilities,
            ?``selectionRange``: SelectionRangeClientCapabilities,
            ?``publishDiagnostics``: PublishDiagnosticsClientCapabilities,
            ?``callHierarchy``: CallHierarchyClientCapabilities,
            ?``semanticTokens``: SemanticTokensClientCapabilities,
            ?``linkedEditingRange``: LinkedEditingRangeClientCapabilities,
            ?``moniker``: MonikerClientCapabilities,
            ?``typeHierarchy``: TypeHierarchyClientCapabilities,
            ?``inlineValue``: InlineValueClientCapabilities,
            ?``inlayHint``: InlayHintClientCapabilities,
            ?``diagnostic``: DiagnosticClientCapabilities,
            ?``inlineCompletion``: InlineCompletionClientCapabilities
        ) =
        TextDocumentClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``synchronization`` = ``synchronization``
                    ``completion`` = ``completion``
                    ``hover`` = ``hover``
                    ``signatureHelp`` = ``signatureHelp``
                    ``declaration`` = ``declaration``
                    ``definition`` = ``definition``
                    ``typeDefinition`` = ``typeDefinition``
                    ``implementation`` = ``implementation``
                    ``references`` = ``references``
                    ``documentHighlight`` = ``documentHighlight``
                    ``documentSymbol`` = ``documentSymbol``
                    ``codeAction`` = ``codeAction``
                    ``codeLens`` = ``codeLens``
                    ``documentLink`` = ``documentLink``
                    ``colorProvider`` = ``colorProvider``
                    ``formatting`` = ``formatting``
                    ``rangeFormatting`` = ``rangeFormatting``
                    ``onTypeFormatting`` = ``onTypeFormatting``
                    ``rename`` = ``rename``
                    ``foldingRange`` = ``foldingRange``
                    ``selectionRange`` = ``selectionRange``
                    ``publishDiagnostics`` = ``publishDiagnostics``
                    ``callHierarchy`` = ``callHierarchy``
                    ``semanticTokens`` = ``semanticTokens``
                    ``linkedEditingRange`` = ``linkedEditingRange``
                    ``moniker`` = ``moniker``
                    ``typeHierarchy`` = ``typeHierarchy``
                    ``inlineValue`` = ``inlineValue``
                    ``inlayHint`` = ``inlayHint``
                    ``diagnostic`` = ``diagnostic``
                    ``inlineCompletion`` = ``inlineCompletion``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``synchronization`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("synchronization")
                        value.WriteTo(writer)

                    match backingObj.``completion`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("completion")
                        value.WriteTo(writer)

                    match backingObj.``hover`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("hover")
                        value.WriteTo(writer)

                    match backingObj.``signatureHelp`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("signatureHelp")
                        value.WriteTo(writer)

                    match backingObj.``declaration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("declaration")
                        value.WriteTo(writer)

                    match backingObj.``definition`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("definition")
                        value.WriteTo(writer)

                    match backingObj.``typeDefinition`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("typeDefinition")
                        value.WriteTo(writer)

                    match backingObj.``implementation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("implementation")
                        value.WriteTo(writer)

                    match backingObj.``references`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("references")
                        value.WriteTo(writer)

                    match backingObj.``documentHighlight`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentHighlight")
                        value.WriteTo(writer)

                    match backingObj.``documentSymbol`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentSymbol")
                        value.WriteTo(writer)

                    match backingObj.``codeAction`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeAction")
                        value.WriteTo(writer)

                    match backingObj.``codeLens`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeLens")
                        value.WriteTo(writer)

                    match backingObj.``documentLink`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("documentLink")
                        value.WriteTo(writer)

                    match backingObj.``colorProvider`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("colorProvider")
                        value.WriteTo(writer)

                    match backingObj.``formatting`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("formatting")
                        value.WriteTo(writer)

                    match backingObj.``rangeFormatting`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("rangeFormatting")
                        value.WriteTo(writer)

                    match backingObj.``onTypeFormatting`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("onTypeFormatting")
                        value.WriteTo(writer)

                    match backingObj.``rename`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("rename")
                        value.WriteTo(writer)

                    match backingObj.``foldingRange`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("foldingRange")
                        value.WriteTo(writer)

                    match backingObj.``selectionRange`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("selectionRange")
                        value.WriteTo(writer)

                    match backingObj.``publishDiagnostics`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("publishDiagnostics")
                        value.WriteTo(writer)

                    match backingObj.``callHierarchy`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("callHierarchy")
                        value.WriteTo(writer)

                    match backingObj.``semanticTokens`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("semanticTokens")
                        value.WriteTo(writer)

                    match backingObj.``linkedEditingRange`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("linkedEditingRange")
                        value.WriteTo(writer)

                    match backingObj.``moniker`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("moniker")
                        value.WriteTo(writer)

                    match backingObj.``typeHierarchy`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("typeHierarchy")
                        value.WriteTo(writer)

                    match backingObj.``inlineValue`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlineValue")
                        value.WriteTo(writer)

                    match backingObj.``inlayHint`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlayHint")
                        value.WriteTo(writer)

                    match backingObj.``diagnostic`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("diagnostic")
                        value.WriteTo(writer)

                    match backingObj.``inlineCompletion`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("inlineCompletion")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "synchronization" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TextDocumentSyncClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "completion" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CompletionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "hover" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (HoverClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "signatureHelp" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SignatureHelpClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "declaration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DeclarationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "definition" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DefinitionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "typeDefinition" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeDefinitionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "implementation" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ImplementationClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "references" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ReferenceClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "documentHighlight" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentHighlightClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "documentSymbol" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentSymbolClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "codeAction" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeActionClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "codeLens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CodeLensClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "documentLink" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentLinkClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "colorProvider" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentColorClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "formatting" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentFormattingClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "rangeFormatting" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentRangeFormattingClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "onTypeFormatting" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DocumentOnTypeFormattingClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "rename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (RenameClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "foldingRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (FoldingRangeClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "selectionRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SelectionRangeClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "publishDiagnostics" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (PublishDiagnosticsClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "callHierarchy" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (CallHierarchyClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "semanticTokens" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (SemanticTokensClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkedEditingRange" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (LinkedEditingRangeClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "moniker" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (MonikerClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "typeHierarchy" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (TypeHierarchyClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlineValue" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineValueClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlayHint" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlayHintClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "diagnostic" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (DiagnosticClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "inlineCompletion" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (InlineCompletionClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(TextDocumentClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Capabilities specific to the notebook document support.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``synchronization``: NotebookDocumentSyncClientCapabilities
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Capabilities specific to notebook document synchronization
    ///
    /// @since 3.17.0
    member _.Synchronization =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``synchronization``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("synchronization")
            NotebookDocumentSyncClientCapabilities.FromElement(prop)

    static member Create(``synchronization``: NotebookDocumentSyncClientCapabilities) =
        NotebookDocumentClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``synchronization`` = ``synchronization``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``synchronization``
                    writer.WritePropertyName("synchronization")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "synchronization" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (NotebookDocumentSyncClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(NotebookDocumentClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WindowClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``workDoneProgress``: global.FSharp.Core.bool option
                ``showMessage``: ShowMessageRequestClientCapabilities option
                ``showDocument``: ShowDocumentClientCapabilities option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WindowClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// It indicates whether the client supports server initiated
    /// progress using the `window/workDoneProgress/create` request.
    ///
    /// The capability also controls Whether client supports handling
    /// of progress notifications. If set servers are allowed to report a
    /// `workDoneProgress` property in the request specific server
    /// capabilities.
    ///
    /// @since 3.15.0
    member _.WorkDoneProgress =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``workDoneProgress`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("workDoneProgress") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Capabilities specific to the showMessage request.
    ///
    /// @since 3.16.0
    member _.ShowMessage =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``showMessage`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("showMessage") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ShowMessageRequestClientCapabilities.FromElement(prop))

    /// Capabilities specific to the showDocument request.
    ///
    /// @since 3.16.0
    member _.ShowDocument =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``showDocument`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("showDocument") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(ShowDocumentClientCapabilities.FromElement(prop))

    static member Create
        (
            ?``workDoneProgress``: global.FSharp.Core.bool,
            ?``showMessage``: ShowMessageRequestClientCapabilities,
            ?``showDocument``: ShowDocumentClientCapabilities
        ) =
        WindowClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``workDoneProgress`` = ``workDoneProgress``
                    ``showMessage`` = ``showMessage``
                    ``showDocument`` = ``showDocument``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``workDoneProgress`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("workDoneProgress", value)

                    match backingObj.``showMessage`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("showMessage")
                        value.WriteTo(writer)

                    match backingObj.``showDocument`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("showDocument")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "workDoneProgress" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "showMessage" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ShowMessageRequestClientCapabilities.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "showDocument" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (ShowDocumentClientCapabilities.Parse(prop)))
        then
            global.FSharp.Core.Ok(WindowClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// General client capabilities.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type GeneralClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``staleRequestSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``regularExpressions``: RegularExpressionsClientCapabilities option
                ``markdown``: MarkdownClientCapabilities option
                ``positionEncodings``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        GeneralClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Client capability that signals how the client
    /// handles stale requests (e.g. a request
    /// for which the client will not process the response
    /// anymore since the information is outdated).
    ///
    /// @since 3.17.0
    member _.StaleRequestSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``staleRequestSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("staleRequestSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Client capabilities specific to regular expressions.
    ///
    /// @since 3.16.0
    member _.RegularExpressions =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``regularExpressions`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("regularExpressions") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(RegularExpressionsClientCapabilities.FromElement(prop))

    /// Client capabilities specific to the client&apos;s markdown parser.
    ///
    /// @since 3.16.0
    member _.Markdown =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``markdown`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("markdown") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(MarkdownClientCapabilities.FromElement(prop))

    /// The position encodings supported by the client. Client and server
    /// have to agree on the same position encoding to ensure that offsets
    /// (e.g. character position in a line) are interpreted the same on both
    /// sides.
    ///
    /// To keep the protocol backwards compatible the following applies: if
    /// the value &apos;utf-16&apos; is missing from the array of position encodings
    /// servers can assume that the client supports UTF-16. UTF-16 is
    /// therefore a mandatory encoding.
    ///
    /// If omitted it defaults to [&apos;utf-16&apos;].
    ///
    /// Implementation considerations: since the conversion from one encoding
    /// into another requires the content of the file / line the conversion
    /// is best done where the file is read which is usually on the server
    /// side.
    ///
    /// @since 3.17.0
    member _.PositionEncodings =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``positionEncodings`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("positionEncodings") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``staleRequestSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``regularExpressions``: RegularExpressionsClientCapabilities,
            ?``markdown``: MarkdownClientCapabilities,
            ?``positionEncodings``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        GeneralClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``staleRequestSupport`` = ``staleRequestSupport``
                    ``regularExpressions`` = ``regularExpressions``
                    ``markdown`` = ``markdown``
                    ``positionEncodings`` = ``positionEncodings``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``staleRequestSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("staleRequestSupport")
                        value.WriteTo(writer)

                    match backingObj.``regularExpressions`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("regularExpressions")
                        value.WriteTo(writer)

                    match backingObj.``markdown`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("markdown")
                        value.WriteTo(writer)

                    match backingObj.``positionEncodings`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("positionEncodings")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(GeneralClientCapabilities.FromElement(element))

/// A relative pattern is a helper to construct glob patterns that are matched
/// relatively to a base URI. The common value for a `baseUri` is a workspace
/// folder root, but it can be another absolute URI as well.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RelativePattern
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``baseUri``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``pattern``: Pattern
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RelativePattern(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// A workspace folder or a base URI to which this pattern will be matched
    /// against relatively.
    member _.BaseUri =
        // Complex type kind: or.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``baseUri``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("baseUri")
            LspJsonBacking.Element prop

    /// The actual glob pattern;
    member _.Pattern =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``pattern``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("pattern")
            (global.Amongonz.LspTypes.LspString.FromElement(prop): Pattern)

    static member Create(``baseUri``: global.Amongonz.LspTypes.LspJsonBacking<obj>, ``pattern``: Pattern) =
        RelativePattern(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``baseUri`` = ``baseUri``
                    ``pattern`` = ``pattern``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``baseUri``
                    writer.WritePropertyName("baseUri")
                    value.WriteTo(writer)
                    let value = backingObj.``pattern``
                    writer.WritePropertyName("pattern")
                    value.WriteTo(writer)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(RelativePattern.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceEditClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``documentChanges``: global.FSharp.Core.bool option
                ``resourceOperations``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``failureHandling``: FailureHandlingKind option
                ``normalizesLineEndings``: global.FSharp.Core.bool option
                ``changeAnnotationSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceEditClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client supports versioned document changes in `WorkspaceEdit`s
    member _.DocumentChanges =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``documentChanges`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("documentChanges") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The resource operations the client supports. Clients should at least
    /// support &apos;create&apos;, &apos;rename&apos; and &apos;delete&apos; files and folders.
    ///
    /// @since 3.13.0
    member _.ResourceOperations =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resourceOperations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resourceOperations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The failure handling strategy of a client if applying the workspace edit
    /// fails.
    ///
    /// @since 3.13.0
    member _.FailureHandling =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``failureHandling`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("failureHandling") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(FailureHandlingKind.FromElement(prop))

    /// Whether the client normalizes line endings to the client specific
    /// setting.
    /// If set to `true` the client will normalize line ending characters
    /// in a workspace edit to the client-specified new line
    /// character.
    ///
    /// @since 3.16.0
    member _.NormalizesLineEndings =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``normalizesLineEndings`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("normalizesLineEndings") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client in general supports change annotations on text edits,
    /// create file, rename file and delete file changes.
    ///
    /// @since 3.16.0
    member _.ChangeAnnotationSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``changeAnnotationSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("changeAnnotationSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``documentChanges``: global.FSharp.Core.bool,
            ?``resourceOperations``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``failureHandling``: FailureHandlingKind,
            ?``normalizesLineEndings``: global.FSharp.Core.bool,
            ?``changeAnnotationSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        WorkspaceEditClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``documentChanges`` = ``documentChanges``
                    ``resourceOperations`` = ``resourceOperations``
                    ``failureHandling`` = ``failureHandling``
                    ``normalizesLineEndings`` = ``normalizesLineEndings``
                    ``changeAnnotationSupport`` = ``changeAnnotationSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``documentChanges`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("documentChanges", value)

                    match backingObj.``resourceOperations`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resourceOperations")
                        value.WriteTo(writer)

                    match backingObj.``failureHandling`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("failureHandling")
                        value.WriteTo(writer)

                    match backingObj.``normalizesLineEndings`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("normalizesLineEndings", value)

                    match backingObj.``changeAnnotationSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("changeAnnotationSupport")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceEditClientCapabilities.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeConfigurationClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeConfigurationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Did change configuration notification supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DidChangeConfigurationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DidChangeConfigurationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DidChangeWatchedFilesClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``relativePatternSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DidChangeWatchedFilesClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Did change watched files notification supports dynamic registration. Please note
    /// that the current protocol doesn&apos;t support static configuration for file changes
    /// from the server side.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client has support for {@link  RelativePattern relative pattern}
    /// or not.
    ///
    /// @since 3.17.0
    member _.RelativePatternSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``relativePatternSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relativePatternSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``relativePatternSupport``: global.FSharp.Core.bool) =
        DidChangeWatchedFilesClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``relativePatternSupport`` = ``relativePatternSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``relativePatternSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("relativePatternSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "relativePatternSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DidChangeWatchedFilesClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities for a {@link WorkspaceSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceSymbolClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceSymbolClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Symbol request supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
    member _.SymbolKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``symbolKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("symbolKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports tags on `SymbolInformation`.
    /// Clients supporting tags have to handle unknown tags gracefully.
    ///
    /// @since 3.16.0
    member _.TagSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tagSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tagSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client support partial workspace symbols. The client will send the
    /// request `workspaceSymbol/resolve` to the server to resolve additional
    /// properties.
    ///
    /// @since 3.17.0
    member _.ResolveSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        WorkspaceSymbolClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``symbolKind`` = ``symbolKind``
                    ``tagSupport`` = ``tagSupport``
                    ``resolveSupport`` = ``resolveSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``symbolKind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("symbolKind")
                        value.WriteTo(writer)

                    match backingObj.``tagSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tagSupport")
                        value.WriteTo(writer)

                    match backingObj.``resolveSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resolveSupport")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(WorkspaceSymbolClientCapabilities.FromElement(element))

/// The client capabilities of a {@link ExecuteCommandRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ExecuteCommandClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ExecuteCommandClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Execute command supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        ExecuteCommandClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ExecuteCommandClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensWorkspaceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``refreshSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from
    /// the server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// semantic tokens currently shown. It should be used with absolute care
    /// and is useful for situation where a server for example detects a project
    /// wide change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        SemanticTokensWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``refreshSupport`` = ``refreshSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``refreshSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("refreshSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SemanticTokensWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensWorkspaceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``refreshSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from the
    /// server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// code lenses currently shown. It should be used with absolute care and is
    /// useful for situation where a server for example detect a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        CodeLensWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``refreshSupport`` = ``refreshSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``refreshSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("refreshSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CodeLensWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Capabilities relating to events from file operations by the user in the client.
///
/// These events do not come from the file system, they come from user operations
/// like renaming a file in the UI.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FileOperationClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``didCreate``: global.FSharp.Core.bool option
                ``willCreate``: global.FSharp.Core.bool option
                ``didRename``: global.FSharp.Core.bool option
                ``willRename``: global.FSharp.Core.bool option
                ``didDelete``: global.FSharp.Core.bool option
                ``willDelete``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FileOperationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client supports dynamic registration for file requests/notifications.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending didCreateFiles notifications.
    member _.DidCreate =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending willCreateFiles requests.
    member _.WillCreate =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willCreate`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willCreate") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending didRenameFiles notifications.
    member _.DidRename =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending willRenameFiles requests.
    member _.WillRename =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willRename`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willRename") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending didDeleteFiles notifications.
    member _.DidDelete =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client has support for sending willDeleteFiles requests.
    member _.WillDelete =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willDelete`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willDelete") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``didCreate``: global.FSharp.Core.bool,
            ?``willCreate``: global.FSharp.Core.bool,
            ?``didRename``: global.FSharp.Core.bool,
            ?``willRename``: global.FSharp.Core.bool,
            ?``didDelete``: global.FSharp.Core.bool,
            ?``willDelete``: global.FSharp.Core.bool
        ) =
        FileOperationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``didCreate`` = ``didCreate``
                    ``willCreate`` = ``willCreate``
                    ``didRename`` = ``didRename``
                    ``willRename`` = ``willRename``
                    ``didDelete`` = ``didDelete``
                    ``willDelete`` = ``willDelete``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``didCreate`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("didCreate", value)

                    match backingObj.``willCreate`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("willCreate", value)

                    match backingObj.``didRename`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("didRename", value)

                    match backingObj.``willRename`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("willRename", value)

                    match backingObj.``didDelete`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("didDelete", value)

                    match backingObj.``willDelete`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("willDelete", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willCreate" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willRename" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willDelete" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FileOperationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client workspace capabilities specific to inline values.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueWorkspaceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``refreshSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from the
    /// server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// inline values currently shown. It should be used with absolute care and is
    /// useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        InlineValueWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``refreshSupport`` = ``refreshSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``refreshSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("refreshSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client workspace capabilities specific to inlay hints.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintWorkspaceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``refreshSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from
    /// the server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// inlay hints currently shown. It should be used with absolute care and
    /// is useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        InlayHintWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``refreshSupport`` = ``refreshSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``refreshSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("refreshSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlayHintWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Workspace client capabilities specific to diagnostic pull requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticWorkspaceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``refreshSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from
    /// the server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// pulled diagnostics currently shown. It should be used with absolute care and
    /// is useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        DiagnosticWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``refreshSupport`` = ``refreshSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``refreshSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("refreshSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client workspace capabilities specific to folding ranges
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeWorkspaceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``refreshSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeWorkspaceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the client implementation supports a refresh request sent from the
    /// server to the client.
    ///
    /// Note that this event is global and will force the client to refresh all
    /// folding ranges currently shown. It should be used with absolute care and is
    /// useful for situation where a server for example detects a project wide
    /// change that requires such a calculation.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RefreshSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``refreshSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("refreshSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``refreshSupport``: global.FSharp.Core.bool) =
        FoldingRangeWorkspaceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``refreshSupport`` = ``refreshSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``refreshSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("refreshSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "refreshSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(FoldingRangeWorkspaceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentSyncClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``willSave``: global.FSharp.Core.bool option
                ``willSaveWaitUntil``: global.FSharp.Core.bool option
                ``didSave``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentSyncClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether text document synchronization supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports sending will save notifications.
    member _.WillSave =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willSave`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSave") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports sending a will save request and
    /// waits for a response providing text edits which will
    /// be applied to the document before it is saved.
    member _.WillSaveWaitUntil =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``willSaveWaitUntil`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("willSaveWaitUntil") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports did save notifications.
    member _.DidSave =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``didSave`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("didSave") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``willSave``: global.FSharp.Core.bool,
            ?``willSaveWaitUntil``: global.FSharp.Core.bool,
            ?``didSave``: global.FSharp.Core.bool
        ) =
        TextDocumentSyncClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``willSave`` = ``willSave``
                    ``willSaveWaitUntil`` = ``willSaveWaitUntil``
                    ``didSave`` = ``didSave``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``willSave`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("willSave", value)

                    match backingObj.``willSaveWaitUntil`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("willSaveWaitUntil", value)

                    match backingObj.``didSave`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("didSave", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willSave" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "willSaveWaitUntil" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "didSave" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TextDocumentSyncClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Completion client capabilities
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CompletionClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``completionItemKind``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``insertTextMode``: InsertTextMode option
                ``contextSupport``: global.FSharp.Core.bool option
                ``completionList``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CompletionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether completion supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports the following `CompletionItem` specific
    /// capabilities.
    member _.CompletionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``completionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    member _.CompletionItemKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``completionItemKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionItemKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Defines how the client handles whitespace and indentation
    /// when accepting a completion item that uses multi line
    /// text in either `insertText` or `textEdit`.
    ///
    /// @since 3.17.0
    member _.InsertTextMode =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``insertTextMode`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("insertTextMode") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(InsertTextMode.FromElement(prop))

    /// The client supports to send additional context information for a
    /// `textDocument/completion` request.
    member _.ContextSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``contextSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("contextSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports the following `CompletionList` specific
    /// capabilities.
    ///
    /// @since 3.17.0
    member _.CompletionList =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``completionList`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("completionList") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``completionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``completionItemKind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``insertTextMode``: InsertTextMode,
            ?``contextSupport``: global.FSharp.Core.bool,
            ?``completionList``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        CompletionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``completionItem`` = ``completionItem``
                    ``completionItemKind`` = ``completionItemKind``
                    ``insertTextMode`` = ``insertTextMode``
                    ``contextSupport`` = ``contextSupport``
                    ``completionList`` = ``completionList``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``completionItem`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("completionItem")
                        value.WriteTo(writer)

                    match backingObj.``completionItemKind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("completionItemKind")
                        value.WriteTo(writer)

                    match backingObj.``insertTextMode`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("insertTextMode", int value)

                    match backingObj.``contextSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("contextSupport", value)

                    match backingObj.``completionList`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("completionList")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CompletionClientCapabilities.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type HoverClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``contentFormat``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        HoverClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether hover supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports the following content formats for the content
    /// property. The order describes the preferred format of the client.
    member _.ContentFormat =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``contentFormat`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("contentFormat") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``contentFormat``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        HoverClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``contentFormat`` = ``contentFormat``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``contentFormat`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("contentFormat")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(HoverClientCapabilities.FromElement(element))

/// Client Capabilities for a {@link SignatureHelpRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SignatureHelpClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``signatureInformation``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``contextSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SignatureHelpClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether signature help supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports the following `SignatureInformation`
    /// specific properties.
    member _.SignatureInformation =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``signatureInformation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("signatureInformation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports to send additional context information for a
    /// `textDocument/signatureHelp` request. A client that opts into
    /// contextSupport will also support the `retriggerCharacters` on
    /// `SignatureHelpOptions`.
    ///
    /// @since 3.15.0
    member _.ContextSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``contextSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("contextSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``signatureInformation``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``contextSupport``: global.FSharp.Core.bool
        ) =
        SignatureHelpClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``signatureInformation`` = ``signatureInformation``
                    ``contextSupport`` = ``contextSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``signatureInformation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("signatureInformation")
                        value.WriteTo(writer)

                    match backingObj.``contextSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("contextSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SignatureHelpClientCapabilities.FromElement(element))

/// @since 3.14.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DeclarationClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``linkSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DeclarationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether declaration supports dynamic registration. If this is set to `true`
    /// the client supports the new `DeclarationRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of declaration links.
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        DeclarationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``linkSupport`` = ``linkSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``linkSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("linkSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DeclarationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client Capabilities for a {@link DefinitionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DefinitionClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``linkSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DefinitionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether definition supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of definition links.
    ///
    /// @since 3.14.0
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        DefinitionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``linkSupport`` = ``linkSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``linkSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("linkSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DefinitionClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Since 3.6.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeDefinitionClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``linkSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeDefinitionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `TypeDefinitionRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of definition links.
    ///
    /// Since 3.14.0
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        TypeDefinitionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``linkSupport`` = ``linkSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``linkSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("linkSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeDefinitionClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.6.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ImplementationClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``linkSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ImplementationClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `ImplementationRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports additional metadata in the form of definition links.
    ///
    /// @since 3.14.0
    member _.LinkSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``linkSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("linkSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool, ?``linkSupport``: global.FSharp.Core.bool) =
        ImplementationClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``linkSupport`` = ``linkSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``linkSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("linkSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "linkSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ImplementationClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client Capabilities for a {@link ReferencesRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ReferenceClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ReferenceClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether references supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        ReferenceClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ReferenceClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client Capabilities for a {@link DocumentHighlightRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentHighlightClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentHighlightClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether document highlight supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentHighlightClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentHighlightClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client Capabilities for a {@link DocumentSymbolRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSymbolClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``hierarchicalDocumentSymbolSupport``: global.FSharp.Core.bool option
                ``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``labelSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSymbolClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether document symbol supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Specific capabilities for the `SymbolKind` in the
    /// `textDocument/documentSymbol` request.
    member _.SymbolKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``symbolKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("symbolKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports hierarchical document symbols.
    member _.HierarchicalDocumentSymbolSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``hierarchicalDocumentSymbolSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("hierarchicalDocumentSymbolSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports tags on `SymbolInformation`. Tags are supported on
    /// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
    /// Clients supporting tags have to handle unknown tags gracefully.
    ///
    /// @since 3.16.0
    member _.TagSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tagSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tagSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// The client supports an additional label presented in the UI when
    /// registering a document symbol provider.
    ///
    /// @since 3.16.0
    member _.LabelSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``labelSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("labelSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``symbolKind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``hierarchicalDocumentSymbolSupport``: global.FSharp.Core.bool,
            ?``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``labelSupport``: global.FSharp.Core.bool
        ) =
        DocumentSymbolClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``symbolKind`` = ``symbolKind``
                    ``hierarchicalDocumentSymbolSupport`` = ``hierarchicalDocumentSymbolSupport``
                    ``tagSupport`` = ``tagSupport``
                    ``labelSupport`` = ``labelSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``symbolKind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("symbolKind")
                        value.WriteTo(writer)

                    match backingObj.``hierarchicalDocumentSymbolSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("hierarchicalDocumentSymbolSupport", value)

                    match backingObj.``tagSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tagSupport")
                        value.WriteTo(writer)

                    match backingObj.``labelSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("labelSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(DocumentSymbolClientCapabilities.FromElement(element))

/// The Client Capabilities of a {@link CodeActionRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeActionClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``codeActionLiteralSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``isPreferredSupport``: global.FSharp.Core.bool option
                ``disabledSupport``: global.FSharp.Core.bool option
                ``dataSupport``: global.FSharp.Core.bool option
                ``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``honorsChangeAnnotations``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeActionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether code action supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client support code action literals of type `CodeAction` as a valid
    /// response of the `textDocument/codeAction` request. If the property is not
    /// set the request can only return `Command` literals.
    ///
    /// @since 3.8.0
    member _.CodeActionLiteralSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeActionLiteralSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeActionLiteralSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Whether code action supports the `isPreferred` property.
    ///
    /// @since 3.15.0
    member _.IsPreferredSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``isPreferredSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("isPreferredSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether code action supports the `disabled` property.
    ///
    /// @since 3.16.0
    member _.DisabledSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``disabledSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("disabledSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether code action supports the `data` property which is
    /// preserved between a `textDocument/codeAction` and a
    /// `codeAction/resolve` request.
    ///
    /// @since 3.16.0
    member _.DataSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dataSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dataSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports resolving additional code action
    /// properties via a separate `codeAction/resolve` request.
    ///
    /// @since 3.16.0
    member _.ResolveSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Whether the client honors the change annotations in
    /// text edits and resource operations returned via the
    /// `CodeAction#edit` property by for example presenting
    /// the workspace edit in the user interface and asking
    /// for confirmation.
    ///
    /// @since 3.16.0
    member _.HonorsChangeAnnotations =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``honorsChangeAnnotations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("honorsChangeAnnotations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``codeActionLiteralSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``isPreferredSupport``: global.FSharp.Core.bool,
            ?``disabledSupport``: global.FSharp.Core.bool,
            ?``dataSupport``: global.FSharp.Core.bool,
            ?``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``honorsChangeAnnotations``: global.FSharp.Core.bool
        ) =
        CodeActionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``codeActionLiteralSupport`` = ``codeActionLiteralSupport``
                    ``isPreferredSupport`` = ``isPreferredSupport``
                    ``disabledSupport`` = ``disabledSupport``
                    ``dataSupport`` = ``dataSupport``
                    ``resolveSupport`` = ``resolveSupport``
                    ``honorsChangeAnnotations`` = ``honorsChangeAnnotations``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``codeActionLiteralSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("codeActionLiteralSupport")
                        value.WriteTo(writer)

                    match backingObj.``isPreferredSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("isPreferredSupport", value)

                    match backingObj.``disabledSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("disabledSupport", value)

                    match backingObj.``dataSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dataSupport", value)

                    match backingObj.``resolveSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resolveSupport")
                        value.WriteTo(writer)

                    match backingObj.``honorsChangeAnnotations`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("honorsChangeAnnotations", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(CodeActionClientCapabilities.FromElement(element))

/// The client capabilities  of a {@link CodeLensRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CodeLensClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CodeLensClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether code lens supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        CodeLensClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CodeLensClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The client capabilities of a {@link DocumentLinkRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentLinkClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``tooltipSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentLinkClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether document link supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports the `tooltip` property on `DocumentLink`.
    ///
    /// @since 3.15.0
    member _.TooltipSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tooltipSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tooltipSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``tooltipSupport``: global.FSharp.Core.bool)
        =
        DocumentLinkClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``tooltipSupport`` = ``tooltipSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``tooltipSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("tooltipSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "tooltipSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentLinkClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentColorClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentColorClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `DocumentColorRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentColorClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentColorClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities of a {@link DocumentFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFormattingClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFormattingClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether formatting supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentFormattingClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentFormattingClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities of a {@link DocumentRangeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentRangeFormattingClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``rangesSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentRangeFormattingClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether range formatting supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports formatting multiple ranges at once.
    ///
    /// @since 3.18.0
    /// @proposed
    member _.RangesSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rangesSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangesSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``rangesSupport``: global.FSharp.Core.bool)
        =
        DocumentRangeFormattingClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``rangesSupport`` = ``rangesSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``rangesSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("rangesSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "rangesSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentRangeFormattingClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities of a {@link DocumentOnTypeFormattingRequest}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentOnTypeFormattingClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentOnTypeFormattingClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether on type formatting supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        DocumentOnTypeFormattingClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DocumentOnTypeFormattingClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RenameClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``prepareSupport``: global.FSharp.Core.bool option
                ``prepareSupportDefaultBehavior``: PrepareSupportDefaultBehavior option
                ``honorsChangeAnnotations``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RenameClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether rename supports dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports testing for validity of rename operations
    /// before execution.
    ///
    /// @since 3.12.0
    member _.PrepareSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``prepareSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports the default behavior result.
    ///
    /// The value indicates the default behavior used by the
    /// client.
    ///
    /// @since 3.16.0
    member _.PrepareSupportDefaultBehavior =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``prepareSupportDefaultBehavior`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("prepareSupportDefaultBehavior") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(PrepareSupportDefaultBehavior.FromElement(prop))

    /// Whether the client honors the change annotations in
    /// text edits and resource operations returned via the
    /// rename request&apos;s workspace edit by for example presenting
    /// the workspace edit in the user interface and asking
    /// for confirmation.
    ///
    /// @since 3.16.0
    member _.HonorsChangeAnnotations =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``honorsChangeAnnotations`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("honorsChangeAnnotations") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``prepareSupport``: global.FSharp.Core.bool,
            ?``prepareSupportDefaultBehavior``: PrepareSupportDefaultBehavior,
            ?``honorsChangeAnnotations``: global.FSharp.Core.bool
        ) =
        RenameClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``prepareSupport`` = ``prepareSupport``
                    ``prepareSupportDefaultBehavior`` = ``prepareSupportDefaultBehavior``
                    ``honorsChangeAnnotations`` = ``honorsChangeAnnotations``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``prepareSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("prepareSupport", value)

                    match backingObj.``prepareSupportDefaultBehavior`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("prepareSupportDefaultBehavior", int value)

                    match backingObj.``honorsChangeAnnotations`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("honorsChangeAnnotations", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "prepareSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "prepareSupportDefaultBehavior" element
               |> global.FSharp.Core.ValueOption.forall (fun prop -> true)
            && global.Amongonz.LspTypes.Validation.optionalProperty "honorsChangeAnnotations" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(RenameClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type FoldingRangeClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``rangeLimit``: global.FSharp.Core.int option
                ``lineFoldingOnly``: global.FSharp.Core.bool option
                ``foldingRangeKind``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``foldingRange``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        FoldingRangeClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for folding range
    /// providers. If this is set to `true` the client supports the new
    /// `FoldingRangeRegistrationOptions` return value for the corresponding
    /// server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The maximum number of folding ranges that the client prefers to receive
    /// per document. The value serves as a hint, servers are free to follow the
    /// limit.
    member _.RangeLimit =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``rangeLimit`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("rangeLimit") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetInt32())

    /// If set, the client signals that it only supports folding complete lines.
    /// If set, client will ignore specified `startCharacter` and `endCharacter`
    /// properties in a FoldingRange.
    member _.LineFoldingOnly =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``lineFoldingOnly`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("lineFoldingOnly") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Specific options for the folding range kind.
    ///
    /// @since 3.17.0
    member _.FoldingRangeKind =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``foldingRangeKind`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRangeKind") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Specific options for the folding range.
    ///
    /// @since 3.17.0
    member _.FoldingRange =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``foldingRange`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("foldingRange") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``rangeLimit``: global.FSharp.Core.int,
            ?``lineFoldingOnly``: global.FSharp.Core.bool,
            ?``foldingRangeKind``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``foldingRange``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        FoldingRangeClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``rangeLimit`` = ``rangeLimit``
                    ``lineFoldingOnly`` = ``lineFoldingOnly``
                    ``foldingRangeKind`` = ``foldingRangeKind``
                    ``foldingRange`` = ``foldingRange``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``rangeLimit`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteNumber("rangeLimit", value)

                    match backingObj.``lineFoldingOnly`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("lineFoldingOnly", value)

                    match backingObj.``foldingRangeKind`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("foldingRangeKind")
                        value.WriteTo(writer)

                    match backingObj.``foldingRange`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("foldingRange")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(FoldingRangeClientCapabilities.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SelectionRangeClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SelectionRangeClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
    /// the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
    /// capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        SelectionRangeClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(SelectionRangeClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// The publish diagnostic client capabilities.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PublishDiagnosticsClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``relatedInformation``: global.FSharp.Core.bool option
                ``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
                ``versionSupport``: global.FSharp.Core.bool option
                ``codeDescriptionSupport``: global.FSharp.Core.bool option
                ``dataSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PublishDiagnosticsClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether the clients accepts diagnostics with related information.
    member _.RelatedInformation =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``relatedInformation`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedInformation") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports the tag property to provide meta data about a diagnostic.
    /// Clients supporting tags have to handle unknown tags gracefully.
    ///
    /// @since 3.15.0
    member _.TagSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``tagSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("tagSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    /// Whether the client interprets the version property of the
    /// `textDocument/publishDiagnostics` notification&apos;s parameter.
    ///
    /// @since 3.15.0
    member _.VersionSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``versionSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("versionSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Client supports a codeDescription property
    ///
    /// @since 3.16.0
    member _.CodeDescriptionSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``codeDescriptionSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("codeDescriptionSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether code action supports the `data` property which is
    /// preserved between a `textDocument/publishDiagnostics` and
    /// `textDocument/codeAction` request.
    ///
    /// @since 3.16.0
    member _.DataSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dataSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dataSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ?``relatedInformation``: global.FSharp.Core.bool,
            ?``tagSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``versionSupport``: global.FSharp.Core.bool,
            ?``codeDescriptionSupport``: global.FSharp.Core.bool,
            ?``dataSupport``: global.FSharp.Core.bool
        ) =
        PublishDiagnosticsClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``relatedInformation`` = ``relatedInformation``
                    ``tagSupport`` = ``tagSupport``
                    ``versionSupport`` = ``versionSupport``
                    ``codeDescriptionSupport`` = ``codeDescriptionSupport``
                    ``dataSupport`` = ``dataSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``relatedInformation`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("relatedInformation", value)

                    match backingObj.``tagSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("tagSupport")
                        value.WriteTo(writer)

                    match backingObj.``versionSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("versionSupport", value)

                    match backingObj.``codeDescriptionSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("codeDescriptionSupport", value)

                    match backingObj.``dataSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dataSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(PublishDiagnosticsClientCapabilities.FromElement(element))

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type CallHierarchyClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        CallHierarchyClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        CallHierarchyClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(CallHierarchyClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type SemanticTokensClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``requests``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``formats``: global.Amongonz.LspTypes.LspJsonBacking<obj>
                ``overlappingTokenSupport``: global.FSharp.Core.bool option
                ``multilineTokenSupport``: global.FSharp.Core.bool option
                ``serverCancelSupport``: global.FSharp.Core.bool option
                ``augmentsSyntaxTokens``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        SemanticTokensClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Which requests the client supports and might send to the server
    /// depending on the server&apos;s capability. Please note that clients might not
    /// show semantic tokens or degrade some of the user experience if a range
    /// or full request is advertised by the client but not provided by the
    /// server. If for example the client capability `requests.full` and
    /// `request.range` are both set to true but the server only provides a
    /// range provider the client might not render a minimap correctly or might
    /// even decide to not show any semantic tokens at all.
    member _.Requests =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``requests``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("requests")
            LspJsonBacking.Element prop

    /// The token types that the client supports.
    member _.TokenTypes =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``tokenTypes``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenTypes")
            LspJsonBacking.Element prop

    /// The token modifiers that the client supports.
    member _.TokenModifiers =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``tokenModifiers``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("tokenModifiers")
            LspJsonBacking.Element prop

    /// The token formats the clients supports.
    member _.Formats =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``formats``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("formats")
            LspJsonBacking.Element prop

    /// Whether the client supports tokens that can overlap each other.
    member _.OverlappingTokenSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``overlappingTokenSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("overlappingTokenSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client supports tokens that can span multiple lines.
    member _.MultilineTokenSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``multilineTokenSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("multilineTokenSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client allows the server to actively cancel a
    /// semantic token request, e.g. supports returning
    /// LSPErrorCodes.ServerCancelled. If a server does the client
    /// needs to retrigger the request.
    ///
    /// @since 3.17.0
    member _.ServerCancelSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``serverCancelSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("serverCancelSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the client uses semantic tokens to augment existing
    /// syntax tokens. If set to `true` client side created syntax
    /// tokens and semantic tokens are both used for colorization. If
    /// set to `false` the client only uses the returned semantic tokens
    /// for colorization.
    ///
    /// If the value is `undefined` then the client behavior is not
    /// specified.
    ///
    /// @since 3.17.0
    member _.AugmentsSyntaxTokens =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``augmentsSyntaxTokens`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("augmentsSyntaxTokens") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (
            ``requests``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``tokenTypes``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``tokenModifiers``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ``formats``: global.Amongonz.LspTypes.LspJsonBacking<obj>,
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``overlappingTokenSupport``: global.FSharp.Core.bool,
            ?``multilineTokenSupport``: global.FSharp.Core.bool,
            ?``serverCancelSupport``: global.FSharp.Core.bool,
            ?``augmentsSyntaxTokens``: global.FSharp.Core.bool
        ) =
        SemanticTokensClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``requests`` = ``requests``
                    ``tokenTypes`` = ``tokenTypes``
                    ``tokenModifiers`` = ``tokenModifiers``
                    ``formats`` = ``formats``
                    ``overlappingTokenSupport`` = ``overlappingTokenSupport``
                    ``multilineTokenSupport`` = ``multilineTokenSupport``
                    ``serverCancelSupport`` = ``serverCancelSupport``
                    ``augmentsSyntaxTokens`` = ``augmentsSyntaxTokens``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    let value = backingObj.``requests``
                    writer.WritePropertyName("requests")
                    value.WriteTo(writer)
                    let value = backingObj.``tokenTypes``
                    writer.WritePropertyName("tokenTypes")
                    value.WriteTo(writer)
                    let value = backingObj.``tokenModifiers``
                    writer.WritePropertyName("tokenModifiers")
                    value.WriteTo(writer)
                    let value = backingObj.``formats``
                    writer.WritePropertyName("formats")
                    value.WriteTo(writer)

                    match backingObj.``overlappingTokenSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("overlappingTokenSupport", value)

                    match backingObj.``multilineTokenSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("multilineTokenSupport", value)

                    match backingObj.``serverCancelSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("serverCancelSupport", value)

                    match backingObj.``augmentsSyntaxTokens`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("augmentsSyntaxTokens", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(SemanticTokensClientCapabilities.FromElement(element))

/// Client capabilities for the linked editing range request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LinkedEditingRangeClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LinkedEditingRangeClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        LinkedEditingRangeClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(LinkedEditingRangeClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities specific to the moniker request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MonikerClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MonikerClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether moniker supports dynamic registration. If this is set to `true`
    /// the client supports the new `MonikerRegistrationOptions` return value
    /// for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        MonikerClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(MonikerClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TypeHierarchyClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TypeHierarchyClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        TypeHierarchyClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(TypeHierarchyClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities specific to inline values.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValueClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValueClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for inline value providers.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        InlineValueClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineValueClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Inlay hint client capabilities.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlayHintClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlayHintClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether inlay hints support dynamic registration.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Indicates which properties a client can resolve lazily on an inlay
    /// hint.
    member _.ResolveSupport =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``resolveSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("resolveSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ?``dynamicRegistration``: global.FSharp.Core.bool,
            ?``resolveSupport``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        InlayHintClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``resolveSupport`` = ``resolveSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``resolveSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("resolveSupport")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(InlayHintClientCapabilities.FromElement(element))

/// Client capabilities specific to diagnostic pull requests.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DiagnosticClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``relatedDocumentSupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DiagnosticClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is set to `true`
    /// the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// Whether the clients supports related documents for document diagnostic pulls.
    member _.RelatedDocumentSupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``relatedDocumentSupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("relatedDocumentSupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``relatedDocumentSupport``: global.FSharp.Core.bool) =
        DiagnosticClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``relatedDocumentSupport`` = ``relatedDocumentSupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``relatedDocumentSupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("relatedDocumentSupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "relatedDocumentSupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(DiagnosticClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities specific to inline completions.
///
/// @since 3.18.0
/// @proposed
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineCompletionClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineCompletionClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration for inline completion providers.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create(?``dynamicRegistration``: global.FSharp.Core.bool) =
        InlineCompletionClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(InlineCompletionClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Notebook specific client capabilities.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentSyncClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``dynamicRegistration``: global.FSharp.Core.bool option
                ``executionSummarySupport``: global.FSharp.Core.bool option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentSyncClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Whether implementation supports dynamic registration. If this is
    /// set to `true` the client supports the new
    /// `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)`
    /// return value for the corresponding server capability as well.
    member _.DynamicRegistration =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``dynamicRegistration`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("dynamicRegistration") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    /// The client supports sending execution summary data per cell.
    member _.ExecutionSummarySupport =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``executionSummarySupport`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("executionSummarySupport") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(prop.GetBoolean())

    static member Create
        (?``dynamicRegistration``: global.FSharp.Core.bool, ?``executionSummarySupport``: global.FSharp.Core.bool) =
        NotebookDocumentSyncClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``dynamicRegistration`` = ``dynamicRegistration``
                    ``executionSummarySupport`` = ``executionSummarySupport``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``dynamicRegistration`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("dynamicRegistration", value)

                    match backingObj.``executionSummarySupport`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value -> writer.WriteBoolean("executionSummarySupport", value)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "dynamicRegistration" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
            && global.Amongonz.LspTypes.Validation.optionalProperty "executionSummarySupport" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(NotebookDocumentSyncClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Show message request client capabilities
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowMessageRequestClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``messageActionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowMessageRequestClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// Capabilities specific to the `MessageActionItem` type.
    member _.MessageActionItem =
        // Complex type kind: literal.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``messageActionItem`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("messageActionItem") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create(?``messageActionItem``: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
        ShowMessageRequestClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``messageActionItem`` = ``messageActionItem``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()

                    match backingObj.``messageActionItem`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("messageActionItem")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(ShowMessageRequestClientCapabilities.FromElement(element))

/// Client capabilities for the showDocument request.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ShowDocumentClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``support``: global.FSharp.Core.bool
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ShowDocumentClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The client has support for the showDocument
    /// request.
    member _.Support =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``support``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("support")
            prop.GetBoolean()

    static member Create(``support``: global.FSharp.Core.bool) =
        ShowDocumentClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {| ``support`` = ``support`` |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``support``
                    writer.WriteBoolean("support", value)
                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "support" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.Amongonz.LspTypes.Validation.isValidBool prop)
        then
            global.FSharp.Core.Ok(ShowDocumentClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities specific to regular expressions.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type RegularExpressionsClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``engine``: global.Amongonz.LspTypes.LspString
                ``version``: global.Amongonz.LspTypes.LspString option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        RegularExpressionsClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The engine&apos;s name.
    member _.Engine =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``engine``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("engine")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The engine&apos;s version.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``version`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("version") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    static member Create
        (``engine``: global.Amongonz.LspTypes.LspString, ?``version``: global.Amongonz.LspTypes.LspString)
        =
        RegularExpressionsClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``engine`` = ``engine``
                    ``version`` = ``version``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``engine``
                    writer.WritePropertyName("engine")
                    value.WriteTo(writer)

                    match backingObj.``version`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("version")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        if
            true
            && global.Amongonz.LspTypes.Validation.optionalProperty "engine" element
               |> global.FSharp.Core.ValueOption.exists (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
            && global.Amongonz.LspTypes.Validation.optionalProperty "version" element
               |> global.FSharp.Core.ValueOption.forall (fun prop ->
                   global.FSharp.Core.Result.isOk (global.Amongonz.LspTypes.LspString.Parse(prop)))
        then
            global.FSharp.Core.Ok(RegularExpressionsClientCapabilities.FromElement(element))
        else
            global.FSharp.Core.Error()

/// Client capabilities specific to the used markdown parser.
///
/// @since 3.16.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkdownClientCapabilities
    private
    (backing:
        global.Amongonz.LspTypes.LspJsonBacking<
            {|
                ``parser``: global.Amongonz.LspTypes.LspString
                ``version``: global.Amongonz.LspTypes.LspString option
                ``allowedTags``: global.Amongonz.LspTypes.LspJsonBacking<obj> option
            |}
         >) =
    member _.GetBacking() = backing.GetBoxed()
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MarkdownClientCapabilities(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    /// The name of the parser.
    member _.Parser =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) -> backingObj.``parser``
        | LspJsonBacking.Element elem ->
            let prop = elem.GetProperty("parser")
            global.Amongonz.LspTypes.LspString.FromElement(prop)

    /// The version of the parser.
    member _.Version =
        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``version`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("version") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(global.Amongonz.LspTypes.LspString.FromElement(prop))

    /// A list of HTML tags that the client allows / supports in
    /// Markdown.
    ///
    /// @since 3.17.0
    member _.AllowedTags =
        // Complex type kind: array.

        match backing with
        | LspJsonBacking.Obj(backingObj, _) ->
            match backingObj.``allowedTags`` with
            | None -> ValueNone
            | Some value -> ValueSome value
        | LspJsonBacking.Element elem ->
            match elem.TryGetProperty("allowedTags") with
            | false, _ -> ValueNone
            | true, prop -> ValueSome(LspJsonBacking.Element prop)

    static member Create
        (
            ``parser``: global.Amongonz.LspTypes.LspString,
            ?``version``: global.Amongonz.LspTypes.LspString,
            ?``allowedTags``: global.Amongonz.LspTypes.LspJsonBacking<obj>
        ) =
        MarkdownClientCapabilities(
            global.Amongonz.LspTypes.LspJsonBacking.Obj(
                {|
                    ``parser`` = ``parser``
                    ``version`` = ``version``
                    ``allowedTags`` = ``allowedTags``
                |},
                (fun backingObj writer ->
                    writer.WriteStartObject()
                    let value = backingObj.``parser``
                    writer.WritePropertyName("parser")
                    value.WriteTo(writer)

                    match backingObj.``version`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("version")
                        value.WriteTo(writer)

                    match backingObj.``allowedTags`` with
                    | global.FSharp.Core.None -> ()
                    | global.FSharp.Core.Some value ->
                        writer.WritePropertyName("allowedTags")
                        value.WriteTo(writer)

                    writer.WriteEndObject())
            )
        )

    static member Parse(element: global.System.Text.Json.JsonElement) =
        global.FSharp.Core.Ok(MarkdownClientCapabilities.FromElement(element))

/// The definition of a symbol represented as one or many {@link Location locations}.
/// For most programming languages there is only one location at which a symbol is
/// defined.
///
/// Servers should prefer returning `DefinitionLink` over `Definition` if supported
/// by the client.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Definition(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Definition(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(Definition.FromElement(element))

/// Information about where a symbol is defined.
///
/// Provides additional metadata over normal {@link Location location} definitions, including the range of
/// the defining symbol
type DefinitionLink = LocationLink

/// LSP arrays.
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LSPArray(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: array.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LSPArray(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(LSPArray.FromElement(element))

/// The LSP any type.
/// Please note that strictly speaking a property with the value `undefined`
/// can&apos;t be converted into JSON preserving the property name. However for
/// convenience it is allowed and assumed that all these properties are
/// optional as well.
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LSPAny(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LSPAny(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(LSPAny.FromElement(element))

/// The declaration of a symbol representation as one or many {@link Location locations}.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type Declaration(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        Declaration(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(Declaration.FromElement(element))

/// Information about where a symbol is declared.
///
/// Provides additional metadata over normal {@link Location location} declarations, including the range of
/// the declaring symbol.
///
/// Servers should prefer returning `DeclarationLink` over `Declaration` if supported
/// by the client.
type DeclarationLink = LocationLink

/// Inline value information can be provided by different means:
/// - directly as a text value (class InlineValueText).
/// - as a name to use for a variable lookup (class InlineValueVariableLookup)
/// - as an evaluatable expression (class InlineValueEvaluatableExpression)
/// The InlineValue types combines all inline value types into one type.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type InlineValue(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        InlineValue(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(InlineValue.FromElement(element))

/// The result of a document diagnostic pull request. A report can
/// either be a full report containing all diagnostics for the
/// requested document or an unchanged report indicating that nothing
/// has changed in terms of diagnostics in comparison to the last
/// pull request.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentDiagnosticReport(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(DocumentDiagnosticReport.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type PrepareRenameResult(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        PrepareRenameResult(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(PrepareRenameResult.FromElement(element))

/// A document selector is the combination of one or many document filters.
///
/// @sample `let sel:DocumentSelector = [{ language: &apos;typescript&apos; }, { language: &apos;json&apos;, pattern: &apos;**tsconfig.json&apos; }]`;
///
/// The use of a string as a document filter is deprecated @since 3.16.0.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentSelector(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: array.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentSelector(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(DocumentSelector.FromElement(element))

[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type ProgressToken(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        ProgressToken(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(ProgressToken.FromElement(element))

/// An identifier to refer to a change annotation stored with a workspace edit.
type ChangeAnnotationIdentifier = global.Amongonz.LspTypes.LspString

/// A workspace diagnostic document report.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type WorkspaceDocumentDiagnosticReport(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        WorkspaceDocumentDiagnosticReport(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(WorkspaceDocumentDiagnosticReport.FromElement(element))

/// An event describing a change to a text document. If only a text is provided
/// it is considered to be the full content of the document.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentContentChangeEvent(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentContentChangeEvent(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(TextDocumentContentChangeEvent.FromElement(element))

/// MarkedString can be used to render human readable text. It is either a markdown string
/// or a code-block that provides a language and a code snippet. The language identifier
/// is semantically equal to the optional language identifier in fenced code blocks in GitHub
/// issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
///
/// The pair of a language and a value is an equivalent to markdown:
/// ```${language}
/// ${value}
/// ```
///
/// Note that markdown strings will be sanitized - that means html will be escaped.
/// @deprecated use MarkupContent instead.
[<global.System.Obsolete("use MarkupContent instead.")>]
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type MarkedString(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        MarkedString(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(MarkedString.FromElement(element))

/// A document filter describes a top level text document or
/// a notebook cell document.
///
/// @since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type DocumentFilter(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        DocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(DocumentFilter.FromElement(element))

/// LSP object definition.
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type LSPObject(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: map.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        LSPObject(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(LSPObject.FromElement(element))

/// The glob pattern. Either a string pattern or a relative pattern.
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type GlobPattern(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        GlobPattern(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(GlobPattern.FromElement(element))

/// A document filter denotes a document by different properties like
/// the {@link TextDocument.languageId language}, the {@link Uri.scheme scheme} of
/// its resource, or a glob-pattern that is applied to the {@link TextDocument.fileName path}.
///
/// Glob patterns can have the following syntax:
/// - `*` to match one or more characters in a path segment
/// - `?` to match on one character in a path segment
/// - `**` to match any number of path segments, including none
/// - `{}` to group sub patterns into an OR expression. (e.g. `**/*.{ts,js}` matches all TypeScript and JavaScript files)
/// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
/// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
///
/// @sample A language filter that applies to typescript files on disk: `{ language: &apos;typescript&apos;, scheme: &apos;file&apos; }`
/// @sample A language filter that applies to all package.json paths: `{ language: &apos;json&apos;, pattern: &apos;**package.json&apos; }`
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type TextDocumentFilter(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        TextDocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(TextDocumentFilter.FromElement(element))

/// A notebook document filter denotes a notebook document by
/// different properties. The properties will be match
/// against the notebook&apos;s URI (same as with documents)
///
/// @since 3.17.0
[<global.FSharp.Core.Struct; global.System.Runtime.CompilerServices.IsReadOnly>]
type NotebookDocumentFilter(backing: global.Amongonz.LspTypes.LspJsonBacking<obj>) =
    // Complex type kind: or.

    member _.GetBacking() = backing
    member _.WriteTo(writer) = backing.WriteTo(writer)

    static member FromElement(element) =
        NotebookDocumentFilter(global.Amongonz.LspTypes.LspJsonBacking.Element element)

    static member Parse(element) =
        global.FSharp.Core.Ok(NotebookDocumentFilter.FromElement(element))

/// The glob pattern to watch relative to the base path. Glob patterns can have the following syntax:
/// - `*` to match one or more characters in a path segment
/// - `?` to match on one character in a path segment
/// - `**` to match any number of path segments, including none
/// - `{}` to group conditions (e.g. `**/*.{ts,js}` matches all TypeScript and JavaScript files)
/// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
/// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)
///
/// @since 3.17.0
type Pattern = global.Amongonz.LspTypes.LspString
